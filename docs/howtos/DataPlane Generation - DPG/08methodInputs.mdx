import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Method Inputs

This doc details what method input signatures language emitters will output.

## Basic

### HTTP Get

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
@get
op get(): User;
```

</TabItem>

<TabItem value="python" label="Python">

```python
def get() -> User:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
//protocol method
public virtual async Task<Response> GetUserAsync(RequestContext context){}
public virtual Response GetUser(RequestContext context){}
//convenience method
public virtual async Task<Response<User>> GetUser(CancellationToken cancellationToken = default)
public virtual Response<User> GetUser(CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

// RLC
export interface GetUser200Response extends HttpResponse {
  status: "200";
  body: User;
}

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/analyze' has methods for the following verbs: post */
    (path: "/users"): {
      get(
        options: RequestParameters
      ): StreamableMethod<GetUser200Response | GetUserDefaultResponse>;
    };
  };
};

// Modular Api Layer
export async function get(): Promise<User>;

// Modular classical client layer
export class DemoServiceClient {
  get(options: GetUserOptionalParams): Promise<User>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
public User get();
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### HTTP Post

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
@post
op post(@body body: User): void;
```

</TabItem>

<TabItem value="python" label="Python">

For model inputs, Python automatically generates an overload that allows SDK users to input through a file stream.

```python
@overload
def post(body: User, **kwargs: Any) -> None:
  ...

@overload
def post(body: JSON, **kwargs: Any) -> None:
  ...

@overload
def post(body: IO[bytes], **kwargs: Any) -> None:
  ...

def post(body: [User, JSON, IO[bytes]], **kwargs: Any) -> None:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
//protocol method
public virtual async Task<Response> PostAsync(RequestContent content, RequestContext context = null)
public virtual Response Post(RequestContent content, RequestContext context = null)
//convenience method
public virtual async Task<Response> PostAsync(User user, CancellationToken cancellationToken = default)
public virtual Response Post(User user, CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (path: "/users"): {
      post(
        options: {
          body: User;
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular Api Layer
export async function post(body: User, options: PostOptionalParams): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  post(body: User, options: PostOptionalParams): Promise<void>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
public void post(User user);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

## Spread

Please use the _spread_ feature with caution.

- The model to be spread should have less than 6 settable properties. See [simple methods](https://azure.github.io/azure-sdk/dotnet_introduction.html#dotnet-parameters).
- The model to be spread should be stable across api-versions. Adding an optional property across api-versions could result in one additional method overload in SDK client.
- The model to be spread should not be used in [JSON Merge Patch](https://datatracker.ietf.org/doc/html/rfc7386).

### Alias

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
alias User = {
  firstName: string;
  lastName: string;
};

@post
op upload(...User): void;
```

</TabItem>

<TabItem value="python" label="Python">

For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
def upload(first_name: str, last_name: str) -> None:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
//protocol method
public virtual async Task<Response> UploadAsync(RequestContent content, RequestContext context = null)
public virtual Response Upload(RequestContent content, RequestContext context = null)
//convenience method
public virtual async Task<Response> UploadAsync(string firstName, string lastName, CancellationToken cancellationToken = default)
public virtual Response Upload(string firstName, string lastName, CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (path: "/users"): {
      post(
        options: {
          body: {
            firstName: string;
            lastName: string;
          };
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular Api Layer
export async function upload(
  firstName: string,
  lastName: string,
  options: UploadOptionalParams
): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  upload(firstName: string, lastName: string, options: UploadOptionalParams): Promise<void>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
public void upload(String firstName, String lastName);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### Alias with @header/@query/@path properties

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
alias User = {
  @path id: string;
  firstName: string;
  lastName: string;
};

op upload(...User): void;
```

</TabItem>

<TabItem value="python" label="Python">

For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
def upload(self, first_name: str, last_name: str, *, content_type: str = "application/json") -> None:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
//protocol method
public virtual async Task<Response> UploadAsync(string id, RequestContent content, RequestContext context = null)
public virtual Response Upload(string id, RequestContent content, RequestContext context = null)
//convenience method
public virtual async Task<Response> UploadAsync(string id, string firstName, string lastName, CancellationToken cancellationToken = default)
public virtual Response Upload(string id, string firstName, string lastName, CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (
      path: "/users/{id}",
      id
    ): {
      post(
        options: {
          body: {
            firstName: string;
            lastName: string;
          };
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular Api Layer
export async function upload(
  id: string,
  firstName: string,
  lastName: string,
  options: UploadOptionalParams
): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  upload(
    id: string,
    firstName: string,
    lastName: string,
    options: UploadOptionalParams
  ): Promise<void>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
public void upload(String id, String firstName, String lastName);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### Named model

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
model User {
  firstName: string;
  lastName: string;
}

op upload(...User): void;
```

</TabItem>

<TabItem value="python" label="Python">
For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
def upload(self, first_name: str, last_name: str, *, content_type: str = "application/json") -> None:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
public partial class User
{
  public User(string firstName, string lastName){}
  public string FirstName { get; }
  public string LastName { get; }
}
//protocol method
public virtual async Task<Response> UploadAsync(RequestContent content, RequestContext context = null)
public virtual Response Upload(RequestContent content, RequestContext context = null)
//convenience method
public virtual async Task<Response> UploadAsync(User user, CancellationToken cancellationToken = default)
public virtual Response Upload(User user, CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (path: "/users"): {
      post(
        options: {
          body: User;
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular Api Layer
export async function upload(body: User, options: UploadOptionalParams): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  upload(body: User, options: UploadOptionalParams): Promise<void>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
// Model class
@Immutable
public final class User implements JsonSerializable<User> {
    public User(String firstName, String lastName);
    public String getFirstName();
    public String getLastName();
}

// Client API
public void upload(User user);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### Model with `@body` property

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
model User {
  firstName: string;
  lastName: string;
}

model UserRequest {
  @body user: User;
}

op upload(...UserRequest): void;
```

</TabItem>

<TabItem value="python" label="Python">

For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
def upload(self, body: [User, JSON, IO[bytes]], *, content_type: str = "application/json") -> None:
  ...
```

</TabItem>

<TabItem value="csharp" label="CSharp" >

```csharp
public partial class User
{
  public User(string firstName, string lastName){}
  public string FirstName { get; }
  public string LastName { get; }
}
//protocol method
public virtual async Task<Response> UploadAsync(RequestContent content, RequestContext context = null)
public virtual Response Upload(RequestContent content, RequestContext context = null)
//convenience method
public virtual async Task<Response> UploadAsync(User user, CancellationToken cancellationToken = default)
public virtual Response Upload(User user, CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (path: "/users"): {
      post(
        options: {
          body: User;
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular Api Layer
export async function upload(user: User, options: UploadOptionalParams): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  upload(user: User, options: UploadOptionalParams): Promise<void>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
// Model class
@Immutable
public final class User implements JsonSerializable<User> {
    public User(String firstName, String lastName);
    public String getFirstName();
    public String getLastName();
}

// Client API
public void upload(User user);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### Model with @header/@query/@path properties

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
model BlobProperties {
  @path
  name: string;

  @header testHeader: string;
}

@route("blob_properties/{name}")
op getBlobProperties(...BlobProperties): void;
```

</TabItem>

<TabItem value="python" label="Python">
For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python

def get_blob_properties(self, name: str, *, test_header: string, content_type: str = "application/json") -> None:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
//protocol method
public virtual async Task<Response> GetBlobPropertiesAsync(string name, string testHeader, RequestContext context = null)
public virtual Response GetBlobProperties(string name, string testHeader, RequestContext context = null)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (path: "/blob_properties/{name}", name): {
      post(
        options: {
          headers: {
            "test-header": string;
          } & RawHttpHeaders
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular Options
export interface GetBlobPropertiesOptionalParams extends OperationOptions {
  requestOptions: {
    headers: {
      test-header: string
    } & RawHttpHeadersInput
  }
}

// Modular api layer
export async function getBlobProperties(name: string, options: GetBlobPropertiesOptionalParams): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  getBlobProperties(name: string, options: GetBlobPropertiesOptionalParams): Promise<void>
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
public void getBlobProperties(String name, String testHeader);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### Model mixed with normal and @header/@query/@path properties

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
model Schema {
  @header contentType: "application/json";
  schema: bytes;
}

@post
op register(...Schema): void;
```

</TabItem>

<TabItem value="python" label="Python">
For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
class Schema:
  schema: bytes

def register(self, body: [Schema, JSON, IO[bytes]], *, content_type: str = "application/json") -> None:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp
public partial class Schema
{
  public Schema(BinaryData schemaProperty){}
  public BinaryData SchemaProperty { get; }
}
//protocol method
public virtual async Task<Response> RegisterAsync(RequestContent content, RequestContext context = null)
public virtual Response Register(RequestContent content, RequestContext context = null)
//convenience method
public virtual async Task<Response> RegisterAsync(Schema schema, CancellationToken cancellationToken = default)
public virtual Response Register(Schema schema, CancellationToken cancellationToken = default)
```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript
// from user experience perspective

export type DemoServiceContext = Client & {
  path: {
    /** Resource for '/completions' has methods for the following verbs: post */
    (path: "/schemaRegister"): {
      post(
        options: {
          headers: {
            "content-type": "application/json";
          } & RawHttpHeaders;
          body: {
            schema: string | Uint8Array | ReadableStream<Uint8Array> | NodeJS.ReadableStream;
          };
        } & RequestParameters
      ): StreamableMethod<PostUserDefaultResponse>;
    };
  };
};

// Modular model
export interface Schema {
  schema: string | Uint8Array | ReadableStream<Uint8Array> | NodeJS.ReadableStream;
}

// Modular api layer
export async function register(
  body: Schema,
  options: GetBlobPropertiesOptionalParams
): Promise<void>;

// Modular classical client layer
export class DemoServiceClient {
  getBlobProperties(body: Schema, options: GetBlobPropertiesOptionalParams): Promise<void>;
}
```

</TabItem>
<TabItem value="java" label="Java" >

```java
// Model class
@Immutable
public final class Schema implements JsonSerializable<Schema> {
    public Schema(byte[] schema);
    public byte[] getSchema();
}

// Client API
public void register(Schema schema);
```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

### Using Azure.Core.ResourceOperations template

Resource create and update operations are not impacted by spread since they all have explicit defined body parameter.
Only resource action operations are impacted by spread.

If the action parameter is a model, then the model will be spread.

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
@resource("widgets")
model Widget {
  @key("widgetName")
  name: string;
}

model RepairInfo {
  problem: string;
  contact: string;
}

model RepairResult {
  reason: string;
  info: string;
}

alias Operations = Azure.Core.ResourceOperations<{}>;

op scheduleRepairs is Operations.ResourceAction<Widget, RepairInfo, RepairResult>;
```

</TabItem>

<TabItem value="python" label="Python">
For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
class RepairInfo:
  problem: str
  contact: str

class RepairResult:
  reason: str
  info: str

def scheduleRepairs(self, widget_name: str, problem: str, contact: str, *, content_type: str = "application/json") -> RepairResult:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp

```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript

```

</TabItem>
<TabItem value="java" label="Java" >

```java

```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>

If you want to keep the model, you could use a wrapper to explicit set the body to prevent spread.

<Tabs>
<TabItem value="typespec" label="TypeSpec" default>

```typespec
alias BodyParameter<
  T,
  TName extends valueof string = "body",
  TDoc extends valueof string = "Body parameter."
> = {
  @doc(TDoc)
  @friendlyName(TName)
  @bodyRoot
  body: T;
};

@resource("widgets")
model Widget {
  @key("widgetName")
  name: string;
}

model RepairInfo {
  problem: string;
  contact: string;
}

model RepairResult {
  reason: string;
  info: string;
}

alias Operations = Azure.Core.ResourceOperations<{}>;

op scheduleRepairs is Operations.ResourceAction<Widget, BodyParameter<RepairInfo>, RepairResult>;
```

</TabItem>

<TabItem value="python" label="Python">
For Python, we will also generate the overloads described in the Http Post section, but omitting for brevity

```python
class RepairInfo:
  problem: str
  contact: str

class RepairResult:
  reason: str
  info: str

def scheduleRepairs(self, body: [Schema, JSON, IO[bytes]], *, content_type: str = "application/json") -> RepairResult:
  ...
```

</TabItem>
<TabItem value="csharp" label="CSharp" >

```csharp

```

</TabItem>
<TabItem value="typescript" label="Typescript" >

```typescript

```

</TabItem>
<TabItem value="java" label="Java" >

```java

```

</TabItem>
<TabItem value="go" label="Go" >

```go

```

</TabItem>
</Tabs>
