---
title: Renaming Types
llmstxt: true
---

import { ClientTabs, ClientTabItem } from "@components/client-tabs";

This page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.

:::note
The TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.
However in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.
:::

## Default behaviors

By default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.

> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).

<ClientTabs>

```typespec title=main.tsp
namespace PetStoreNamespace;

/** This is the input I need */
@resource("input")
model InputModel {
  /** Id of this object */
  @key
  @visibility(Lifecycle.Read)
  name: string;
}

/** Read my resource */
op get is ResourceRead<InputModel>;
```

```python
class InputModel:
  name: str = rest_field(readonly=True)

response: InputModel = client.get(name="name")
```

```csharp
namespace PetStoreNamespace.Models
{
  public partial class InputModel
  {
    public string Name { get; }
  }
}

namespace PetStoreNamespace
{
  public partial class PetStoreNamespaceClient
  {
    // protocol method
    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}
    public virtual Response Get(string name, RequestContext context) {}
    // convenience method
    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}
    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}
  }
}
```

```typescript
export interface InputModel {
  readonly name: string;
}

export async function get(
  context: Client,
  name: string,
  options: GetOptionalParams = { requestOptions: {} }
): Promise<InputModel>；
```

```java
package petstorenamespace.models;
public final class InputModel {
    public String getName()
}

package petstorenamespace;
public final class PetStoreNamespaceClient {
    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)
    public InputModel get(String name)
}
```

```go
type InputModel struct {
	Name string
}

type PetStoreNamespaceClientGetResponse struct {
	InputModel
}

type PetStoreNamespaceClient struct {}

func NewPetStoreNamespaceClient() *PetStoreNamespaceClient {
  return &PetStoreNamespaceClient{}
}

func (client *PetStoreNamespaceClient) Get(ctx context.Context, name string, options *PetStoreNamespaceClientGetOptions) (PetStoreNamespaceClientGetResponse, error)
```

</ClientTabs>

## Customizations

### Renaming models and attributes

You can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):

- `client` means that all client will use that name
- `csharp`, `javascript`, `python`, `java` means you target this specific language

Language target takes priority over `client` target.

> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure
> if you should rename the model in the main TYPESPEC or customize it.

<ClientTabs>

```typespec title=client.tsp
import "./main.tsp";
import "@azure-tools/typespec-client-generator-core";

using Azure.ClientGenerator.Core;

@@clientName(InputModel, "InputOptions"); // Use InputOptions as a base name in clients
@@clientName(InputModel, "ParameterOptions", "csharp"); // Prefer a different name for C# only

@@clientName(InputModel.name, "input_name", "python"); // Python may need a different to be idiomatic
```

```python
class InputOptions:
  input_name: str = rest_field(rest_name="name", readonly=True)

response: InputOptions = client.get(input_name="name")
```

```csharp
namespace PetStoreNamespace.Models
{
  public partial class ParameterOptions
  {
    public string Name { get; }
  }
}

namespace PetStoreNamespace
{
  public partial class PetStoreNamespaceClient
  {
    // protocol method
    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}
    public virtual Response Get(string name, RequestContext context) {}
    // convenience method
    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}
    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}
  }
}
```

```typescript
// Typescript do not change behavior based on protocolAPI or convenientAPI
```

```java
package petstorenamespace.models;
public final class InputOptions {
    public String getName()
}

package petstorenamespace;
public final class PetStoreNamespaceClient {
    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)
    public InputOptions get(String name)
}
```

```go
type InputOptions struct {
	Name string
}

type PetStoreNamespaceClientGetResponse struct {
	InputOptions
}

type PetStoreNamespaceClient struct {}

func NewPetStoreNamespaceClient() *PetStoreNamespaceClient {
  return &PetStoreNamespaceClient{}
}

func (client *PetStoreNamespaceClient) Get(ctx context.Context, name string, options *PetStoreNamespaceClientGetOptions) (PetStoreNamespaceClientGetResponse, error)

```

</ClientTabs>

### Renaming operations and parameters

#### Renaming operations

You can rename operations using the `@clientName` decorator:

<ClientTabs>

```typespec title=client.tsp
import "./main.tsp";
import "@azure-tools/typespec-client-generator-core";

using Azure.ClientGenerator.Core;

@@clientName(Get, "Read"); // Use InputOptions as a base name in clients
@@clientName(Get, "GetComputed", "python"); // Note that Python will still snake_case it
```

```python
class InputModel:
  name: str = rest_field(readonly=True)
response: InputModel = client.get_computed(name="name")
```

```csharp
namespace PetStoreNamespace.Models
{
  public partial class InputModel
  {
    public string Name { get; }
  }
}

namespace PetStoreNamespace
{
  public partial class PetStoreNamespaceClient
  {
    // protocol method
    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}
    public virtual Response ReadModel(string name, RequestContext context) {}
    // convenience method
    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}
    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}
  }
}
```

```typescript
// Typescript do not change behavior based on protocolAPI or convenientAPI
```

```java
package petstorenamespace.models;
public final class InputModel {
    public String getName()
}

package petstorenamespace;
public final class PetStoreNamespaceClient {
    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)
    public InputModel readModel(String name)
}
```

```go
type InputModel struct {
	Name string
}

type PetStoreNamespaceClient struct {}

func NewPetStoreNamespaceClient() *PetStoreNamespaceClient {
  return &PetStoreNamespaceClient{}
}

type PetStoreNamespaceClientReadResponse struct {
	InputModel
}

func (client *PetStoreNamespaceClient) Read(ctx context.Context, name string, options *PetStoreNamespaceClientReadOptions) (PetStoreNamespaceClientReadResponse, error)

```

</ClientTabs>

#### Renaming operation parameters

Operation parameters can be renamed using the `@clientName` decorator. This is useful when you want different parameter names in the generated client SDK while keeping the wire name unchanged.

:::note
The name of an operation parameter is **not** part of the API definition for most parameter types. For query parameters, the wire name is controlled by the `@query` decorator (or the parameter name if `@query` has no arguments). Changing a parameter name is an **SDK breaking change** but not an API breaking change.
:::

There are two ways to rename operation parameters:

**Option 1: Apply `@clientName` directly on the parameter in the main TypeSpec file**

This is the recommended approach for most cases. Apply the decorator directly on the parameter:

<ClientTabs>

```typespec title=main.tsp
namespace PetStoreNamespace;

/** This is the input I need */
@resource("input")
model InputModel {
  /** Id of this object */
  @key
  @visibility(Lifecycle.Read)
  name: string;
}

/** Read my resource with a filter */
op get(
  @clientName("resourceName")
  name: string,
  
  @clientName("filterQuery")
  @query
  filter?: string
): InputModel;
```

```python
# The parameter 'name' becomes 'resource_name' in Python
# The query parameter 'filter' becomes 'filter_query'
response: InputModel = client.get(resource_name="name", filter_query="active")
```

```csharp
namespace PetStoreNamespace
{
  public partial class PetStoreNamespaceClient
  {
    // protocol method
    public virtual async Task<Response> GetAsync(string resourceName, string filterQuery, RequestContext context) {}
    public virtual Response Get(string resourceName, string filterQuery, RequestContext context) {}
    // convenience method
    public virtual async Task<Response<InputModel>> GetAsync(string resourceName, string filterQuery, CancellationToken cancellationToken = default) {}
    public virtual Response<InputModel> Get(string resourceName, string filterQuery, CancellationToken cancellationToken = default) {}
  }
}
```

```typescript
export async function get(
  context: Client,
  resourceName: string,
  options: GetOptionalParams = { requestOptions: {} }
): Promise<InputModel>；
```

```java
package petstorenamespace;
public final class PetStoreNamespaceClient {
    public Response<BinaryData> getWithResponse(String resourceName, String filterQuery, RequestOptions requestOptions)
    public InputModel get(String resourceName, String filterQuery)
}
```

```go
type PetStoreNamespaceClient struct {}

func NewPetStoreNamespaceClient() *PetStoreNamespaceClient {
  return &PetStoreNamespaceClient{}
}

func (client *PetStoreNamespaceClient) Get(ctx context.Context, resourceName string, options *PetStoreNamespaceClientGetOptions) (PetStoreNamespaceClientGetResponse, error)
```

</ClientTabs>

**Option 2: Apply `@clientName` from client.tsp using `@@` syntax**

You can also apply the decorator from a separate client.tsp file, useful for language-specific customizations:

<ClientTabs>

```typespec title=client.tsp
import "./main.tsp";
import "@azure-tools/typespec-client-generator-core";

using Azure.ClientGenerator.Core;

// Apply @clientName to the 'name' parameter of the 'get' operation
@@clientName(get::parameters.name, "resourceId");

// Apply language-specific names
@@clientName(get::parameters.filter, "search_filter", "python");
```

```python
# Python uses the language-specific name
response: InputModel = client.get(resource_id="name", search_filter="active")
```

```csharp
namespace PetStoreNamespace
{
  public partial class PetStoreNamespaceClient
  {
    // C# uses the base client name since no language-specific override
    public virtual async Task<Response<InputModel>> GetAsync(string resourceId, string filter, CancellationToken cancellationToken = default) {}
    public virtual Response<InputModel> Get(string resourceId, string filter, CancellationToken cancellationToken = default) {}
  }
}
```

```typescript
// TypeScript uses the base client name
export async function get(
  context: Client,
  resourceId: string,
  options: GetOptionalParams = { requestOptions: {} }
): Promise<InputModel>；
```

```java
package petstorenamespace;
public final class PetStoreNamespaceClient {
    // Java uses the base client name
    public InputModel get(String resourceId, String filter)
}
```

```go
type PetStoreNamespaceClient struct {}

func NewPetStoreNamespaceClient() *PetStoreNamespaceClient {
  return &PetStoreNamespaceClient{}
}

// Go uses the base client name
func (client *PetStoreNamespaceClient) Get(ctx context.Context, resourceId string, options *PetStoreNamespaceClientGetOptions) (PetStoreNamespaceClientGetResponse, error)
```

</ClientTabs>

#### Version-scoped parameter renaming

When renaming a parameter as part of a new API version, use the `@renamedFrom` decorator to scope the change. This ensures the rename only applies to the new version:

```typespec
import "@typespec/versioning";

using TypeSpec.Versioning;

enum Versions {
  v1: "2024-01-01",
  v2: "2024-06-01",
}

@versioned(Versions)
namespace PetStoreNamespace;

op get(
  // In v1, this was called 'id'. In v2, it's renamed to 'resourceId'
  @renamedFrom(Versions.v2, "id")
  @clientName("resourceId")
  name: string
): InputModel;
```

This ensures that:
- In API version `2024-01-01` (v1), the SDK uses parameter name based on original name
- In API version `2024-06-01` (v2), the SDK uses the new parameter name `resourceId`
- The wire protocol remains unchanged across both versions

## Implementation

### Order of Operations

For consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.

#### Over-the-Wire JSON Names

For determining the final name of a TypeSpec entity when sent over-the-wire in JSON:

1. If the `@encodedName` decorator exists, use this value
2. Use the original name in the spec

#### Client SDK Names

For determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):

1. Check if there's a scoped `@clientName` decorator for your emitter
2. Check if there's a `@clientName` decorator at all
3. Check the friendly name
4. Use the original name in the spec

**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**
