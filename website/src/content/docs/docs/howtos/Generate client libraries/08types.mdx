---
title: Generated Types
---

import { ClientTabs, ClientTabItem } from "@components/client-tabs";

This page documents what type definitions in TypeSpec are generated as in emitted libraries

## Namespace

The namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.

### Model in namespace

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
namespace Service;

model Foo {
  prop: string;
}
```

</ClientTabItem>

<ClientTabItem lang="python">

```python
from service.models import Foo

foo = Foo(prop="hello")
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// TODO
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// TODO
```

</ClientTabItem>
<ClientTabItem lang="java" >

As `flavor=azure`, Java emitter generates the model classes under `models` package.

```java
import service.models.Foo;

Foo foo = new Foo("hello");
```

</ClientTabItem>
<ClientTabItem lang="go" >

```go
package service

type Foo struct {
    Prop *string `json:"prop,omitempty"`
}
```

</ClientTabItem>
</ClientTabs>

### Model in sub namespace

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
namespace Service;

namespace Container {
  model Foo {
    prop: string;
  }
}
```

</ClientTabItem>

<ClientTabItem lang="python">

```python
from service.container.models import Foo

foo = Foo(prop="hello")
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// TODO
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// TODO
```

</ClientTabItem>
<ClientTabItem lang="java" >

As `flavor=azure`, Java emitter generates the model classes under `models` package.

```java
import service.container.models.Foo;

Foo foo = new Foo("hello");
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package container

type Foo struct {
    Prop *string `json:"prop,omitempty"`
}
```

</ClientTabItem>
</ClientTabs>

### Model in namespace with renaming

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
namespace Service;

@clientNamespace("Service.Container")
model Foo {
  prop: string;
}
```

</ClientTabItem>

<ClientTabItem lang="python">

```python
from service.container.models import Foo

foo = Foo(prop="hello")
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// TODO
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// TODO
```

</ClientTabItem>
<ClientTabItem lang="java" >

As `flavor=azure`, Java emitter generates the model classes under `models` package.

```java
import service.container.models.Foo;

Foo foo = new Foo("hello");
```

</ClientTabItem>
<ClientTabItem lang="go" >

```go
package container

type Foo struct {
    Prop *string `json:"prop,omitempty"`
}
```

</ClientTabItem>
</ClientTabs>

## Client Documentation

The `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
@doc("This internal model is the base class for shapes")
@clientDoc(
  "Base class for all shape objects that can be drawn on a canvas",
  DocumentationMode.replace
)
model Shape {
  @doc("The coordinates of the shape")
  @clientDoc(
    "The x,y coordinates where the shape will be positioned on the canvas",
    DocumentationMode.replace
  )
  position: Point;
}

@doc("A two-dimensional point")
@clientDoc("Represents a position in a 2D coordinate system", DocumentationMode.replace)
model Point {
  @doc("X coordinate")
  @clientDoc("The horizontal position (increases moving right)", DocumentationMode.replace)
  x: float32;

  @doc("Y coordinate")
  @clientDoc("The vertical position (increases moving down)", DocumentationMode.replace)
  y: float32;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
class Point(_model_base.Model):
    """Represents a position in a 2D coordinate system.

    :param x: The horizontal position (increases moving right)
    :type x: float
    :param y: The vertical position (increases moving down)
    :type y: float
    """

    x: float = rest_field()
    """The horizontal position (increases moving right)."""
    y: float = rest_field()
    """The vertical position (increases moving down)."""

class Shape(_model_base.Model):
    """Base class for all shape objects that can be drawn on a canvas.

    :param position: The x,y coordinates where the shape will be positioned on the canvas
    :type position: Point
    """

    position: Point = rest_field()
    """The x,y coordinates where the shape will be positioned on the canvas."""
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
/// <summary>
/// Base class for all shape objects that can be drawn on a canvas
/// </summary>
public partial class Shape
{
    /// <summary>
    /// The x,y coordinates where the shape will be positioned on the canvas
    /// </summary>
    public Point Position { get; set; }
}

/// <summary>
/// Represents a position in a 2D coordinate system
/// </summary>
public partial class Point
{
    /// <summary>
    /// The horizontal position (increases moving right)
    /// </summary>
    public float X { get; set; }

    /// <summary>
    /// The vertical position (increases moving down)
    /// </summary>
    public float Y { get; set; }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
/**
 * Base class for all shape objects that can be drawn on a canvas
 */
export interface Shape {
  /**
   * The x,y coordinates where the shape will be positioned on the canvas
   */
  position: Point;
}

/**
 * Represents a position in a 2D coordinate system
 */
export interface Point {
  /**
   * The horizontal position (increases moving right)
   */
  x: number;

  /**
   * The vertical position (increases moving down)
   */
  y: number;
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
/**
 * Base class for all shape objects that can be drawn on a canvas.
 */
@Fluent
public final class Shape {
    /**
     * The x,y coordinates where the shape will be positioned on the canvas.
     */
    private Point position;

    /**
     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.
     *
     * @return the position value.
     */
    public Point getPosition() {
        return this.position;
    }

    /**
     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.
     *
     * @param position the position value to set.
     * @return the Shape object itself.
     */
    public Shape setPosition(Point position) {
        this.position = position;
        return this;
    }
}

/**
 * Represents a position in a 2D coordinate system.
 */
@Fluent
public final class Point {
    /**
     * The horizontal position (increases moving right).
     */
    private float x;

    /**
     * The vertical position (increases moving down).
     */
    private float y;

    /**
     * Get the x property: The horizontal position (increases moving right).
     *
     * @return the x value.
     */
    public float getX() {
        return this.x;
    }

    /**
     * Set the x property: The horizontal position (increases moving right).
     *
     * @param x the x value to set.
     * @return the Point object itself.
     */
    public Point setX(float x) {
        this.x = x;
        return this;
    }

    /**
     * Get the y property: The vertical position (increases moving down).
     *
     * @return the y value.
     */
    public float getY() {
        return this.y;
    }

    /**
     * Set the y property: The vertical position (increases moving down).
     *
     * @param y the y value to set.
     * @return the Point object itself.
     */
    public Point setY(float y) {
        this.y = y;
        return this;
    }
}
```

</ClientTabItem>
<ClientTabItem lang="go">

```go
// Shape - Base class for all shape objects that can be drawn on a canvas
type Shape struct {
	// Position - The x,y coordinates where the shape will be positioned on the canvas
	Position *Point
}

// Point - Represents a position in a 2D coordinate system
type Point struct {
	// X - The horizontal position (increases moving right)
	X *float32

	// Y - The vertical position (increases moving down)
	Y *float32
}
```

</ClientTabItem>
</ClientTabs>

The `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.

When both `@doc` and `@clientDoc` are present, the generated code outputs the final documentation depending on the mode that you called `@clientDoc` with.
If called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.

## Models

### Flattening

:::caution
Flattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.
:::

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Properties {
  name: string;
}

model Foo {
  @flattenProperty
  prop: Properties;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.

```python
class Properties(_model_base.Model):
    name: str = rest_field()
    """Required."""

class Foo(_model_base.Model):
    properties: "_models.Properties" = rest_field()
    """Required."""

    __flattened_items = ["properties"]

print(f.properties.name)  # Non-flattened access is preferred experience
print(f.name)  # Flattened access is dynamically supported, but not documented

```

</ClientTabItem>
<ClientTabItem lang="csharp" >

CSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.

```csharp
public partial class Foo
{
    public Foo(string name)
    {
        Argument.AssertNotNull(name, nameof(name));

        Name = name;
    }

    public string Name { get; set; }
}

public partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>
{
    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
    {
        var format = options.Format == "W" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;
        if (format != "J")
        {
            throw new FormatException($"The model {nameof(Foo)} does not support writing '{format}' format.");
        }

        writer.WriteStartObject();
        writer.WritePropertyName("properties"u8);
        writer.WriteStartObject();
        writer.WritePropertyName("name"u8);
        writer.WriteStringValue(Name);
        writer.WriteEndObject();
        writer.WriteEndObject();
    }

    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)
    {
        options ??= ModelSerializationExtensions.WireOptions;

        if (element.ValueKind == JsonValueKind.Null)
        {
            return null;
        }
        string name = default;
        foreach (var property in element.EnumerateObject())
        {
            if (property.NameEquals("properties"u8))
            {
                if (property.Value.ValueKind == JsonValueKind.Null)
                {
                    property.ThrowNonNullablePropertyIsNull();
                    continue;
                }
                foreach (var property0 in property.Value.EnumerateObject())
                {
                    if (property0.NameEquals("name"u8))
                    {
                        name = property0.Value.GetString();
                    }
                }
            }
        }
        return new Foo(name);
    }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// Please note that this feature is not supported right now, and the model will be generated un-flattened.
// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164
```

</ClientTabItem>
<ClientTabItem lang="java" >

In Java, `@flattenProperty` have no effect on generated libraries.

```java
@Fluent
public final class Properties {
    public Properties();
    public String getName();
    public Properties setName(String name);
}
```
</ClientTabItem>
<ClientTabItem lang="go" >
```go
type Properties struct {
    Name *string `json:"name,omitempty"`
}

type Foo struct {
    // Flattened from Properties
    Name *string `json:"name,omitempty"`
}
```

</ClientTabItem>
</ClientTabs>

### Models with additional properties

#### Additional properties of any type

<ClientTabs>
<ClientTabItem lang="typespec" >

Recommend usage:

```typespec
model Animal {
  name: string;
  kind: string;
  ...Record<unknown>;
}
```

Other usages:

```typespec
model Animal extends Record<unknown> {
  name: string;
  kind: string;
}
```

```typespec
model Animal is Record<unknown> {
  name: string;
  kind: string;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python models are designed to support adding any additional properties.

```python
from .. import _model_base
from .._model_base import rest_field

class Animal(_model_base.Model):

    name: str = rest_field()
    kind: str = rest_field()

animal = Animal(name="Tom", kind="Cat")
animal["friend"] = "Jerry"
animal["age"] = 5
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public partial class Animal : IJsonModel<Animal> {
    public Animal(string name, string kind);

    public string Name { get; }
    public string Kind { get; }

    public IDictionary<string, BinaryData> AdditionalProperties { get; }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```ts
// RLC input
export interface Animal extends Record<string, unknown> {
  name: string;
  kind: string;
}

// RLC output
export interface AnimalOutput extends Record<string, any> {
  name: string;
  kind: string;
}

// Modular for both legacy and non legacy
export interface Animal extends Record<string, any> {
  name: string;
  kind: string;
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
@Fluent
public final class Animal implements JsonSerializable<Animal> {
    public Animal(String name, String kind);
    public String getName();
    public String getKind();
    public Map<String, Object> getAdditionalProperties();
    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);
}
```

</ClientTabItem>
<ClientTabItem lang="java" >
```go
// Input: Animal (with known fields + optional unknowns)
type Animal struct {
    Name *string `json:"name,omitempty"`
    Kind *string `json:"kind,omitempty"`

    // Additional properties from Record<string, unknown>
    AdditionalProperties map[string]interface{} `json:"-"`
}

// Output: AnimalOutput (same shape, but semantically for responses)
type AnimalOutput struct {
    Name *string `json:"name,omitempty"`
    Kind *string `json:"kind,omitempty"`

    // Additional properties from Record<string, any>
    AdditionalProperties map[string]interface{} `json:"-"`
}
```
</ClientTabItem>

</ClientTabs>

#### Additional properties of specific type

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model AnimalProperty {
  category: string;
  value: unknown;
}

model Animal {
  name: string;
  kind: string;
  ...Record<AnimalProperty>;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python models are designed to support adding any additional properties.

```python
from typing import Any
from .. import _model_base
from .._model_base import rest_field

class Animal(_model_base.Model):

    name: str = rest_field()
    kind: str = rest_field()

class AnimalProperty(_model_base.Model):

    category: str = rest_field()
    value: Any = rest_field()

animal = Animal(name="Tom", kind="Cat")
animal["friend"] = AnimalProperty(category="relationship", value="Jerry")
animal["age"] = AnimalProperty(category="attribute", value=5)
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

Due to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.

For typespec:

```typespec
model Animal {
  name: string;
  kind: string;
  ...Record<AnimalProperty>;
}
```

The `C#` generated code is the same as if the type is `unknown`:

```csharp
public partial class Animal : IJsonModel<Animal>
{
    public Animal(string name, string kind);

    public string Name { get; }
    public string Kind { get; }

    public IDictionary<string, BinaryData> AdditionalProperties { get; }
}
```

For typespec with additional properties of primitive types:

```typespec
model Animal {
  name: string;
  kind: string;
  ...Record<string>;
}
```

The `C#` generated code still has the specified type in `AdditionalProperties` property:

```csharp
public partial class Animal : IJsonModel<Animal>
{
    public Animal(string name, string kind);

    public string Name { get; }
    public string Kind { get; }

    public IDictionary<string, string> AdditionalProperties { get; }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```ts
// RLC input
export interface AnimalProperty {
  category: string;
  value: unknown;
}
export interface Animal extends Record<string, unknown> {
  name: string;
  kind: string;
}

// RLC output
export interface AnimalProperty {
  category: string;
  value: any;
}
export interface Animal extends Record<string, any> {
  name: string;
  kind: string;
}

// Modular for legacy clients
export interface AnimalProperty {
  category: string;
  value: any;
}
export interface Animal extends Record<string, any> {
  name: string;
  kind: string;
}

// Modular for non-legacy clients
export interface AnimalProperty {
  category: string;
  value: any;
}
export interface Animal {
  name: string;
  kind: string;
  additionalProperties: Record<string, AnimalProperty>;
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
@Fluent
public final class Animal implements JsonSerializable<Animal> {
    public Animal(String name, String kind);
    public String getName();
    public String getKind();
    public Map<String, AnimalProperty> getAdditionalProperties();
    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);
}

```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
type AnimalProperty struct {
    Category *string     `json:"category,omitempty"`
    Value    interface{} `json:"value,omitempty"`
}

type Animal struct {
    Name *string `json:"name,omitempty"`
    Kind *string `json:"kind,omitempty"`

    // Additional fields like "speed": {category: "...", value: ...}
    AdditionalProperties map[string]AnimalProperty `json:"-"`
}
```

</ClientTabs>
</ClientTabs>

#### Additional properties of union type

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Animal {
  name: string;
  kind: string;
  ...Record<string>;
  ...Record<int32>;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python models are designed to support adding any additional properties.

```python
from .. import _model_base
from .._model_base import rest_field

class Animal(_model_base.Model):

    name: str = rest_field()
    kind: str = rest_field()

animal = Animal(name="Tom", kind="Cat")
animal["friend"] = "Jerry"
animal["age"] = 5
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public partial class Animal : IJsonModel<Animal>
{
    public Animal(string name, string kind);

    public string Name { get; }
    public string Kind { get; }

    public IDictionary<string, BinaryData> AdditionalProperties { get; }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```ts
// RLC input and output
export interface Animal extends Record<string, string | number> {
  name: string;
  kind: string;
}

// Modular for legacy and non-legacy clients
export interface Animal extends Record<string, string | number> {
  name: string;
  kind: string;
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
@Fluent
public final class Animal implements JsonSerializable<Animal> {
    public Animal(String name, String kind);
    public String getName();
    public String getKind();
    public Map<String, BinaryData> getAdditionalProperties();
    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);
}
```

</ClientTabItem>
</ClientTabs>

#### Additional properties of nullable type

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Animal {
  name: string;
  kind: string;
  ...Record<string | null>;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python models are designed to support adding any additional properties.

```python
from .. import _model_base
from .._model_base import rest_field

class Animal(_model_base.Model):

    name: str = rest_field()
    kind: str = rest_field()

animal = Animal(name="Tom", kind="Cat")
animal["friend"] = "Jerry"
animal["alert"] = None
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public partial class Animal : IJsonModel<Animal>
{
    public Animal(string name, string kind);

    public string Name { get; }
    public string Kind { get; }

    public IDictionary<string, string> AdditionalProperties { get; }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```ts
// RLC input and output
export interface Animal extends Record<string, string | null> {
  name: string;
  kind: string;
}

// Modular for legacy and non-legacy clients
export interface Animal extends Record<string, string | null> {
  name: string;
  kind: string;
}
```

</ClientTabItem>

<ClientTabItem lang="java" >

```java
@Fluent
public final class Animal implements JsonSerializable<Animal> {
    public Animal(String name, String kind);
    public String getName();
    public String getKind();
    public Map<String, String> getAdditionalProperties();
    public Animal setAdditionalProperties(Map<String, String> additionalProperties);
}

```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type Animal struct {
    Name *string `json:"name,omitempty"`
    Kind *string `json:"kind,omitempty"`

    // AdditionalProperties can hold values of type string or int32
    AdditionalProperties map[string]interface{} `json:"-"`
}
```
</ClientTabs>
</ClientTabs>

### Discriminator

TypeSpec uses `@discriminator` decorator to add a discriminator to a model.

<ClientTabs>
<ClientTabItem lang="typespec" >

Client emitters now only support a single way to represent a discriminated set in TypeSpec.

1. Use model

```typespec
@discriminator("kind")
model Cat {
  kind: string;
}

model Siamese extends Cat {
  kind: "siamese";
}

model Ragdoll extends Cat {
  kind: "ragdoll";
}
```

The type of the discriminator property could be an enum (extensible or fixed):

```typespec
@discriminator("kind")
model Cat {
  kind: CatKind;
}

union CatKind {
  string,
  Siamese: "siamese",
  Ragdoll: "ragdoll",
}

model Siamese extends Cat {
  kind: CatKind.Siamese;
}

model Ragdoll extends Cat {
  kind: CatKind.Ragdoll;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
from .. import _model_base
from .._model_base import rest_discriminator, rest_field

class Cat(_model_base.Model):
    kind: str = rest_discriminator(name="kind")

class Siamese(Cat):
    kind: Literal["siamese"] = rest_discriminator(name="kind")

class Ragdoll(Cat):
    kind: Literal["ragdoll"] = rest_discriminator(name="kind")
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

In .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.

```csharp
public abstract partial class Cat
{
  protected Cat()
  {
  }

  internal string Kind { get; set; }
}

public partial class Siamese : Cat
{
  public Siamese() : base()
  {
    Kind = "siamese";
  }
}

public partial class Ragdoll : Cat
{
  public Ragdoll() : base()
  {
    Kind = "ragdoll";
  }
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```ts
// RLC input models
export interface Siamese extends CatParent {
  kind: "siamese";
}

export interface Ragdoll extends CatParent {
  kind: "ragdoll";
}

export type Cat = CatParent | Siamese | Ragdoll;

// RLC output models
export interface CatOutputParent {
  kind: string;
}

export interface SiameseOutput extends CatOutputParent {
  kind: "siamese";
}

export interface RagdollOutput extends CatOutputParent {
  kind: "ragdoll";
}

export type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;

// Modular models
/** model interface Cat */
export interface Cat {
  kind: string;
}

/** Alias for CatUnion */
export type CatUnion = Siamese | Ragdoll | Cat;

/** model interface Siamese */
export interface Siamese extends Cat {
  kind: "siamese";
}
/** model interface Ragdoll */
export interface Ragdoll extends Cat {
  kind: "ragdoll";
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public class Cat implements JsonSerializable<Cat> {
    public Cat();
    public String getKind();
}

public final class Ragdoll extends Cat {
    public Ragdoll();
    public String getKind();
}

public final class Siamese extends Cat {
    public Siamese();
    public String getKind();
}
```

</ClientTabItem>

<ClientTabItem lang="go">

```go
// CatClassification provides polymorphic access to related types.
// Call the interface's GetCat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Cat, *Ragdoll, *Siamese
type CatClassification interface {
	// GetCat returns the Cat content of the underlying type.
	GetCat() *Cat
}

type Cat struct {
	// REQUIRED
	Kind *string
}

// GetCat implements the CatClassification interface for type Cat.
func (c *Cat) GetCat() *Cat { return c }

type Ragdoll struct {
	// CONSTANT; undefinedField has constant value "ragdoll", any specified value is ignored.
	Kind *string
}

// GetCat implements the CatClassification interface for type Ragdoll.
func (e *Ragdoll) GetCat() *Cat {
	return &Cat{
		Kind:     e.Kind,
	}
}

type Siamese struct {
	// CONSTANT; undefinedField has constant value "siamese", any specified value is ignored.
	Kind *string
}

// GetCat implements the CatClassification interface for type Siamese.
func (e *Siamese) GetCat() *Cat {
	return &Cat{
		Kind:     e.Kind,
	}
}
```

</ClientTabItem>
</ClientTabs>

### Nullable

TypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information
about nullability by inspecting the type of a property.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Foo {
  basicNullableProperty: string | null;
  modelNullableProperty: Bar | null;
  enumNullableProperty: LR | null;
}

model Bar {
  prop: string;
}

enum LR {
  left,
  right,
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class Bar(_model_base.Model):
  prop: Optional[str] = rest_field()

class LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  LEFT = "left"
  RIGHT = "right"

class Foo(_model_base.Model):
  basicNullableProperty: Optional[str] = rest_field()
  modelNullableProperty: Optional["_models.Bar"] = rest_field()
  enumNullableProperty: Optional["LR"] = rest_field()

```

</ClientTabItem>
<ClientTabItem lang="csharp" >

TODO

</ClientTabItem>
<ClientTabItem lang="typescript" >

TODO

</ClientTabItem>
<ClientTabItem lang="java" >

TODO

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type Foo struct {
    BasicNullableProperty *string `json:"basicNullableProperty,omitempty"`
    ModelNullableProperty *Bar    `json:"modelNullableProperty,omitempty"`
    EnumNullableProperty  *LR     `json:"enumNullableProperty,omitempty"`
}

type Bar struct {
    Prop *string `json:"prop,omitempty"`
}

type LR string

const (
    LRLeft  LR = "left"
    LRRight LR = "right"
)
```
</ClientTabItem>
</ClientTabs>

## Unions

### Union of literals with same type

All emitters will generate their version of a closed enum.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
union LR {
  left: "left",
  right: "right",
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python never generates closed enum by design. We will always permit users to pass in additional values.

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  LEFT = "left"
  RIGHT = "right"
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public enum LR
{
  Left,
  Right
}
```

Serialization/deserialization will respect the value defined, in this case it is "left" for `LR.Left` and "right" for `LR.Right` respectively.

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export type LR = "left" | "right";
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum LR {
   LEFT("left"),
   RIGHT("right");
}
```

</ClientTabItem>
</ClientTabs>

### Inline union of literals with same type

This is union defined inline at point of usage.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Widget {
  horizontal: "left" | "right";
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python generates this as a union of literals, not as enum. We also don't generate a closed set of literals.

```python
from typing import Literal, Union

model Widget:
  horizontal: Union[Literal["left"] | Literal["right"] | str]
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public partial class Widget
{
  public WidgetHorizontal Horizontal;
}
public enum WidgetHorizontal
{
  Left,
  Right
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export interface Widget {
  horizontal: "left" | "right";
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum WidgetHorizontal {
   LEFT("left"),
   RIGHT("right");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >

```go
package service

type LR string

const (
    LRLeft  LR = "left"
    LRRight LR = "right"
)
```

</ClientTabItem>
</ClientTabs>

### Union of basic type and literals of that type

Each language will generate their version of an open enum.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
union Colors {
  string,
  red: "red",
  blue: "blue",
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python generates open enum again here.

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  RED = "red"
  BLUE = "blue"
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public readonly partial struct Colors : IEquatable<Colors>
{
  private const string RedValue = "red";
  private const string BlueValue = "blue";
  public static Colors Red { get; } = new Colors(RedValue);
  public static Colors Blue { get; } = new Colors(BlueValue);
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export type Colors = string | "red" | "blue";
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public final class Colors extends ExpandableStringEnum<Colors> {
    public static final Colors RED = fromString("red");
    public static final Colors BLUE = fromString("blue");
}
```

</ClientTabItem>
</ClientTabs>

### Inline union of basic type and literals of that type

This is union defined inline at point of usage which include the base type as an option.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Widget {
  color: "red" | "blue" | string;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python generates a union of literals again.

```python
from typing import Literal, Union

model Widget:
  color: Union[Literal["red"] | Literal["blue"] | str]
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public partial class Widget
{
  public WidgetColor Color;
}
public readonly partial struct WidgetColor : IEquatable<WidgetColor>
{
  private const string RedValue = "red";
  private const string BlueValue = "blue";
  public static WidgetColor Red { get; } = new WidgetColor(RedValue);
  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export interface Widget {
  color: "red" | "blue" | string;
}
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public final class WidgetColor extends ExpandableStringEnum<Colors> {
    public static final Color RED = fromString("red");
    public static final Color BLUE = fromString("blue");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type Colors string

const (
    ColorsRed  Colors = "red"
    ColorsBlue Colors = "blue"
)
```
</ClientTabItem>
</ClientTabs>

### Union of other union/enum, basic type and literals of that type

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
import "@azure-tools/typespec-azure-resource-manager";

union ProvisioningState {
  string,
  "InProgress",
  Azure.ResourceManager.ResourceProvisioningState,
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python generates a single open enum.

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  INPROGRESS = "InProgress"
  SUCCEEDED = "Succeeded"
  FAILED = "Failed"
  CANCELED = "Canceled"
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public readonly partial struct ProvisioningState : IEquatable<ProvisioningState>
{
  private const string SucceededValue = "Succeeded";
  private const string FailedValue = "Failed";
  private const string CanceledValue = "Canceled";
  private const string InProgressValue = "InProgress";

  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);
  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);
  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);
  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export type ResourceProvisioningState = "Succeeded" | "Failed" | "Canceled";
// NOTE: extensible enum design may change in JS
export type ProvisioningState = string | "InProgress" | ResourceProvisioningState;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {
    public static final ProvisioningState INPROGRESS = fromString("InProgress");
    public static final ProvisioningState SUCCEEDED = fromString("Succeeded");
    public static final ProvisioningState FAILED = fromString("Failed");
    public static final ProvisioningState CANCELED = fromString("Canceled");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type ProvisioningState string

const (
    ProvisioningStateInProgress ProvisioningState = "InProgress"

    // Constants from Azure.ResourceManager.ResourceProvisioningState
    ResourceProvisioningStateSucceeded ProvisioningState = "Succeeded"
    ResourceProvisioningStateFailed    ProvisioningState = "Failed"
    ResourceProvisioningStateCanceled  ProvisioningState = "Canceled"
    // ... other imported states
)
```
</ClientTabs>
</ClientTabs>

### Union of other unions of literals with same type

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
union LR {
  left: "left",
  right: "right",
}

union UD {
  up: "up",
  down: "down",
}

union Orientation {
  LR,
  UD,
}
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  LEFT = "left"
  RIGHT = "right"
  UP = "up"
  DOWN = "down"
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public enum Orientation
{
  Left,
  Right,
  Up,
  Down
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export type LR = "left" | "right";
export type UD = "up" | "down";
export type Orientation = LR | UD;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum Orientation {
   LEFT("left"),
   RIGHT("right"),
   UP("up"),
   DOWN("down");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type Orientation string

const (
    OrientationLeft  Orientation = "left"
    OrientationRight Orientation = "right"
    OrientationUp    Orientation = "up"
    OrientationDown  Orientation = "down"
)
```
</ClientTabs>
</ClientTabs>

### Inline union of other unions of literals with same type

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
union LR {
  left: "left",
  right: "right",
}

union UD {
  up: "up",
  down: "down",
}

model Widget {
  orientation: LR | UD;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Since this is inline, Python will generate this as a single union of all possible literal values.

```python
from typing import Literal

type WidgetOrientation = "left" | "right" | "up" | "down" | str

model Widget:
  orientation: WidgetOrientation
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public partial class Widget
{
  public WidgetOrientation Orientation;
}
public enum WidgetOrientation
{
  Left,
  Right,
  Up,
  Down
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export interface Widget {
  orientation: LR | UD;
}

export type LR = "left" | "right";
export type UD = "up" | "down";
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum WidgetOrientation {
   LEFT("left"),
   RIGHT("right"),
   UP("up"),
   DOWN("down");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type Orientation string

const (
    OrientationLeft  Orientation = "left"
    OrientationRight Orientation = "right"
    OrientationUp    Orientation = "up"
    OrientationDown  Orientation = "down"
)

type Widget struct {
    Orientation Orientation `json:"orientation"`
}
```
</ClientTabs>
</ClientTabs>

## Enums

### Standard

Standard enums will be generated as closed enums.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
enum LR {
  left,
  right,
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python never generates closed enums by design. We will always permit users to pass in additional values.

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  LEFT = "left"
  RIGHT = "right"
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public enum LR
{
  Left,
  Right
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export type LR = "left" | "right";
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum LR {
   LEFT("left"),
   RIGHT("right");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type LR string

const (
    LRLeft  LR = "left"
    LRRight LR = "right"
)
```
</ClientTabs>
</ClientTabs>

### Versioning Enums

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
@versioned(Versions)
@service
namespace Service;

enum Versions {
  v1,
  v2,
}
```

</ClientTabItem>
<ClientTabItem lang="python">

```
# Python does not generate the enum used for versioning
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// CSharp does not generate the enum used for versioning
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// JS does not generate the enum used for versioning
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum ServiceServiceVersion implements ServiceVersion {
    V1("v1"),
    V2("v2");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type Versions string

const (
    VersionsV1 Versions = "v1"
    VersionsV2 Versions = "v2"
)
```
</ClientTabs>
</ClientTabs>

### Spread

Spreading enums will return the resultant enum as a new single closed enum.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
enum LR {
  left,
  right,
}

enum UD {
  up,
  down,
}

enum Orientation {
  ...LR,
  ...UD,
}
```

</ClientTabItem>
<ClientTabItem lang="python">

Python generates one open enum, because Python never generates an enum as fully closed.

```python
from enum import Enum
from corehttp.utils import CaseInsensitiveEnumMeta

class Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):
  LEFT = "left"
  RIGHT = "right"
  UP = "up"
  DOWN = "down"
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
public enum Orientation
{
  Left,
  Right,
  Up,
  Down
}
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
export type Orientation = "left" | "right" | "up" | "down";
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
public enum Orientation {
   LEFT("left"),
   RIGHT("right"),
   UP("up"),
   DOWN("down");
}
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

type LR string

const (
    LRLeft  LR = "left"
    LRRight LR = "right"
)

type UD string

const (
    UDUp   UD = "up"
    UDDown UD = "down"
)

type Orientation string

const (
    OrientationLeft  Orientation = "left"
    OrientationRight Orientation = "right"
    OrientationUp    Orientation = "up"
    OrientationDown  Orientation = "down"
)
```
</ClientTabs>
</ClientTabs>

## Scalars

### Encoding

We will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Test {
  @encode(DateTimeKnownEncoding.rfc3339)
  prop: utcDateTime;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
serialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format="rfc3339")
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// Internal implementation
utf8JsonWriter.WriteStringValue(Prop.ToString());
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
TODO;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
// Internal implementation
jsonWriter.writeStringField("prop",
    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));
```

</ClientTabItem>
</ClientTabs>

When you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
model Test {
  @encode(string)
  prop: int64;
}
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
serialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format="string")
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
TODO
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
TODO;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
// Internal implementation
jsonWriter.writeStringField("prop", Objects.toString(this.value, null));
```

</ClientTabItem>
<ClientTabItem lang="go" >
```go
package service

import "time"

type Test struct {
    Prop *time.Time `json:"prop,omitempty"`
}
```
</ClientTabs>
</ClientTabs>
