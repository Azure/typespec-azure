---
title: Paging Operations
llmstxt: true
---

import { ClientTabs, ClientTabItem } from "@components/client-tabs";

This doc details what emitters will generate for paging operations.

## Using next link to indicate how to get the next page

Next link is an absolute url returned by the paging operation, which indicates how to get the next page.
If the response does not return a next link, it indicates the last page of results.
Next link should be annotated in the response model with `@nextLink`.

There are two ways to indicate a paging operation with `@nextLink`:

1. Use `@list`, `@nextLink` and `@items`

<ClientTabs>

```typespec
@list op listWithPage(): UserList;

model User {
  id: string;
  name: string;
}

model UserList {
  @pageItems
  value: User[];

  @nextLink
  nextLink?: url;
}
```

```python
class User(_model_base.Model):
    id: str = rest_field()
    name: str = rest_field()

def list_with_page(self, **kwargs: Any) -> ItemPaged["_models.User"]:
    ...
```

```csharp
public virtual Pageable<User> ListWithPage(CancellationToken cancellationToken = default);
```

```typescript
export interface ListWithPageOptionalParams extends OperationOptions {}
// JS CodeGen api layer
export function listWithPage(
  context: Client,
  options: ListWithPageOptionalParams = { requestOptions: {} },
): PagedAsyncIterableIterator<User>;

// JS CodeGen classical client layer
export class TestServiceClient {
  listWithPage(
    options: ListWithPageOptionalParams = { requestOptions: {} },
  ): PagedAsyncIterableIterator<User>;
}
```

```java
public PagedIterable<User> listWithPage();
```

```go
type User struct {
  ID   string `json:"id"`
  Name string `json:"name"`
}

type UserList struct {
  Value    []User
  NextLink *string
}

func (c *Client) ListWithPage(ctx context.Context) (UserList, error)

```

</ClientTabs>

2. Use the `@list` and `@pageItems` decorators from TypeSpec core.

<ClientTabs>

```typespec
@list
op listWithPage(): UserList;

model User {
  id: string;
  name: string;
}

model UserList {
  @pageItems
  value: User[];

  @nextLink
  nextLink?: url;
}
```

```python
class User(_model_base.Model):
    id: str = rest_field()
    name: str = rest_field()

def list_with_page(self, **kwargs: Any) -> ItemPaged["_models.User"]:
    ...
```

```csharp
public virtual Pageable<User> ListWithPage(CancellationToken cancellationToken = default);
```

```typescript
// JS CodeGen api layer
export function listWithPage(
  context: Client,
  options: ListWithPageOptionalParams = { requestOptions: {} },
): PagedAsyncIterableIterator<User>;

// JS CodeGen classical client layer
export class TestServiceClient {
  listWithPage(
    options: ListWithPageOptionalParams = { requestOptions: {} },
  ): PagedAsyncIterableIterator<User>;
}
```

```java
public PagedIterable<User> listWithPage();
```

```go
type User struct {
  ID   string
  Name string
}

type UserList struct {
  Value    []User
  NextLink *string
}

func (c *Client) ListWithPage(ctx context.Context) (UserList, error)

```

</ClientTabs>

## Using continuation token to indicate how to get the next page

A continuation token is a string returned by a paging operation, which is used as a parameter value for the paging operation to get the next page.
If the response does not return a continuation token, it indicates the last page of results.
The request parameter that corresponds to the continuation token value in the paging operation should be decorated with `@continuationToken`. Similarly, the response property that contains the continuation token value should also be decorated with `@continuationToken`.

1. Continuation token in query parameter and response body.

<ClientTabs>

```typespec
@list
op listWithPage(@query @continuationToken continuationToken?: string): UserList;

model User {
  id: string;
  name: string;
}

model UserList {
  @pageItems
  value: User[];

  @continuationToken
  continuationToken?: string;
}
```

```python
class User(_model_base.Model):
    id: str = rest_field()
    name: str = rest_field()

def list_with_page(self, **kwargs: Any) -> ItemPaged["_models.User"]:
    ...
```

```csharp
// TODO
```

```typescript
// JS CodeGen api layer
export function listWithPage(
  context: Client,
  options: ListWithPageOptionalParams = { requestOptions: {} },
): PagedAsyncIterableIterator<User>;

// JS CodeGen classical client layer
export class TestServiceClient {
  listWithPage(
    options: ListWithPageOptionalParams = { requestOptions: {} },
  ): PagedAsyncIterableIterator<User>;
}
```

```java
NOT_SUPPORTED
```

```go
// NOT_SUPPORTED
```

</ClientTabs>

2. Continuation token in header parameter and response body.

<ClientTabs>

```typespec
@list
op listWithPage(@header @continuationToken continuationToken?: string): UserList;

model User {
  id: string;
  name: string;
}

model UserList {
  @pageItems
  value: User[];

  @continuationToken
  continuationToken?: string;
}
```

```python
class User(_model_base.Model):
    id: str = rest_field()
    name: str = rest_field()

def list_with_page(self, **kwargs: Any) -> ItemPaged["_models.User"]:
    ...
```

```csharp
// TODO
```

```typescript
// JS CodeGen api layer
export function listWithPage(
  context: Client,
  options: ListWithPageOptionalParams = { requestOptions: {} },
): PagedAsyncIterableIterator<User>;

// JS CodeGen classical client layer
export class TestServiceClient {
  listWithPage(
    options: ListWithPageOptionalParams = { requestOptions: {} },
  ): PagedAsyncIterableIterator<User>;
}
```

```java
NOT_SUPPORTED
```

```go
// NOT_SUPPORTED
```

</ClientTabs>

3. Continuation token in query parameter and response header.

<ClientTabs>

```typespec
@list
op listWithPage(@query @continuationToken continuationToken?: string): {
  @header
  @continuationToken
  continuationToken?: string;

  @pageItems
  value: User[];
};

model User {
  id: string;
  name: string;
}
```

```python
class User(_model_base.Model):
    id: str = rest_field()
    name: str = rest_field()

def list_with_page(self, **kwargs: Any) -> ItemPaged["_models.User"]:
    ...
```

```csharp
// TODO
```

```typescript
// JS CodeGen api layer
export function listWithPage(
  context: Client,
  options: ListWithPageOptionalParams = { requestOptions: {} },
): PagedAsyncIterableIterator<User>;

// JS CodeGen classical client layer
export class TestServiceClient {
  listWithPage(
    options: ListWithPageOptionalParams = { requestOptions: {} },
  ): PagedAsyncIterableIterator<User>;
}
```

```java
NOT_SUPPORTED
```

```go
// NOT_SUPPORTED
```

</ClientTabs>

4. Continuation token in header parameter and response header.

<ClientTabs>

```typespec
@list
op listWithPage(@query @continuationToken continuationToken?: string): {
  @header
  @continuationToken
  continuationToken?: string;

  @pageItems
  value: User[];
};

model User {
  id: string;
  name: string;
}
```

```python
class User(_model_base.Model):
    id: str = rest_field()
    name: str = rest_field()

def list_with_page(self, **kwargs: Any) -> ItemPaged["_models.User"]:
    ...
```

```csharp
// TODO
```

```typescript
// JS CodeGen api layer
export function listWithPage(
  context: Client,
  options: ListWithPageOptionalParams = { requestOptions: {} },
): PagedAsyncIterableIterator<User>;

// JS CodeGen classical client layer
export class TestServiceClient {
  listWithPage(
    options: ListWithPageOptionalParams = { requestOptions: {} },
  ): PagedAsyncIterableIterator<User>;
}
```

```java
NOT_SUPPORTED
```

```go
// NOT_SUPPORTED
```

</ClientTabs>

## Advanced

### Parameterized next links (against guidelines)

:::danger
Parameterized next links are against guidelines. Please don't follow this unless explicitly told to do so
:::

In very rare cases, there are cases of next links that require parameterization. These cases exist outside of the Azure guidelines for paging, but must be supported for legacy reasons.

In cases like this, you may use the special scalar type `Azure.Core.Legacy.parameterizedNextLink`. You can specify which parameters must be reformatted into the next link. Your emitted SDK will handle the reformatting based on the tsp definition

```tsp
model ListCertificateOptions {
  includePending?: string;
}
model Certificate {
  name: string;
}
model Page {
  @pageItems items: Certificate[];
  @nextLink nextLink: Azure.Core.Legacy.parameterizedNextLink<[
    ListCertificateOptions.includePending
  ]>;
}
```

## Legacy Paging Decorators

:::caution
The following decorators are legacy functionality from `Azure.ClientGenerator.Core.Legacy` and should **only** be used for brownfield services. New services should use standard TypeSpec paging patterns instead.
:::

### Forcing an operation to be paging (`@markAsPageable`)

The `@markAsPageable` decorator forces an operation to be treated as a pageable operation by SDK generators, even when the operation does not follow standard paging patterns.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
import "@azure-tools/typespec-client-generator-core";
using Azure.ClientGenerator.Core.Legacy;

@markAsPageable
@route("/items")
@get
op listItems(): ItemListResult;
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
# When @markAsPageable is applied, the operation returns a paging type
def list_items(self, **kwargs: Any) -> ItemPaged["_models.Item"]:
    ...
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// When @markAsPageable is applied, the operation returns a pageable type
public virtual Pageable<Item> ListItems(CancellationToken cancellationToken = default);
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// When @markAsPageable is applied, the operation returns a paged async iterable
export function listItems(
  options?: ListItemsOptionalParams,
): PagedAsyncIterableIterator<Item>;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
// When @markAsPageable is applied, the operation returns a paged iterable
public PagedIterable<Item> listItems();
```

</ClientTabItem>
<ClientTabItem lang="go" >

```go
// When @markAsPageable is applied, the operation returns a pager
func (c *Client) NewListItemsPager(options *ListItemsOptions) *runtime.Pager[ListItemsResponse]
```

</ClientTabItem>
</ClientTabs>

When applied, TCGC will treat the operation as pageable and SDK generators should generate paging mechanisms (iterators/async iterators) and return appropriate pageable-specific return types.

### Preventing paging treatment (`@disablePageable`)

The `@disablePageable` decorator prevents an operation from being treated as pageable, even when it follows standard paging patterns (e.g., decorated with `@list`).

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
import "@azure-tools/typespec-client-generator-core";
using Azure.ClientGenerator.Core.Legacy;

@disablePageable
@list
@route("/items")
@get
op listItems(): ItemListResult;
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
# When @disablePageable is applied, the operation returns the raw response model
def list_items(self, **kwargs: Any) -> _models.ItemListResult:
    ...
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// When @disablePageable is applied, the operation returns the raw response model
public virtual Response<ItemListResult> ListItems(CancellationToken cancellationToken = default);
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// When @disablePageable is applied, the operation returns the raw response model
export function listItems(
  options?: ListItemsOptionalParams,
): Promise<ItemListResult>;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
// When @disablePageable is applied, the operation returns the raw response model
public ItemListResult listItems();
```

</ClientTabItem>
<ClientTabItem lang="go" >

```go
// When @disablePageable is applied, the operation returns the raw response model
func (c *Client) ListItems(ctx context.Context, options *ListItemsOptions) (ItemListResult, error)
```

</ClientTabItem>
</ClientTabs>

When applied, the response will be the paged model itself (not the list of items), and no paging mechanisms will be generated.

### Specifying next link HTTP verb (`@nextLinkVerb`)

The `@nextLinkVerb` decorator overrides the HTTP method used for fetching the next page. Only `"POST"` and `"GET"` are supported.

<ClientTabs>
<ClientTabItem lang="typespec" >

```typespec
import "@azure-tools/typespec-client-generator-core";
using Azure.ClientGenerator.Core.Legacy;

@nextLinkVerb("POST")
@post
op listItems(): PageResult;
```

</ClientTabItem>
<ClientTabItem lang="python">

```python
# The next page will be fetched using POST instead of GET
def list_items(self, **kwargs: Any) -> ItemPaged["_models.Item"]:
    ...
```

</ClientTabItem>
<ClientTabItem lang="csharp" >

```csharp
// The next page will be fetched using POST instead of GET
public virtual Pageable<Item> ListItems(CancellationToken cancellationToken = default);
```

</ClientTabItem>
<ClientTabItem lang="typescript" >

```typescript
// The next page will be fetched using POST instead of GET
export function listItems(
  options?: ListItemsOptionalParams,
): PagedAsyncIterableIterator<Item>;
```

</ClientTabItem>
<ClientTabItem lang="java" >

```java
// The next page will be fetched using POST instead of GET
public PagedIterable<Item> listItems();
```

</ClientTabItem>
<ClientTabItem lang="go" >

```go
// The next page will be fetched using POST instead of GET
func (c *Client) NewListItemsPager(options *ListItemsOptions) *runtime.Pager[ListItemsResponse]
```

</ClientTabItem>
</ClientTabs>
