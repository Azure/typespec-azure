[{"file_content": "---\nid: basics\ntitle: Creating a TypeSpec Library\n---\n\n# Creating a TypeSpec library\n\nTypeSpec libraries are packages that contain TypeSpec types, decorators, emitters, linters, and other bits of reusable code. TypeSpec libraries are [npm packages](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry) with some additional typespec-specific metadata and conventions. The following will show how to establish a new TypeSpec library, add some types to it, and distribute it on the public npm registry. Later sections will cover more details on how to write [decorators](create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\n\nThis document assumes you will be using [TypeScript](https://typescriptlang.org) to develop your library, but you should feel free to skip the TypeScript steps if you want to use plain JavaScript.\n\n## Prerequisites\n\nYou will need both node and npm installed. Additionally, if you intend to develop multiple libraries together, you will likely want to establish a monorepo as this will make developing the libraries in tandem much easier. TypeSpec itself uses [rush.js](https://rushjs.io/).\n\n## Canonical package structure\n\nThe following is a high level overview of the contents of a TypeSpec package. These files are explained in more detail in the subsequent sections.\n\n- **dist/index.js** - the main file for your node library\n- **lib/main.tsp** - the main file for your TypeSpec types (optional)\n- **src/index.ts** - the main file for your node library in TypeScript\n- **src/lib.ts** - the TypeSpec library definition file\n- **package.json** - metadata about your TypeSpec package\n\n## Initial setup\n\n### 1. Initialize your package directory &amp; package.json\n\nRun the following commands:\n\n```bash\n> mkdir myLibrary\n> cd myLibrary\n> npm init\n```\n\nAfter filling out the wizard, you will have a package.json file that defines your typespec library.\n\nUnlike node libraries which support CommonJS (cjs), TypeSpec libraries must be Ecmascript Modules. So open your `package.json` and add the following top-level configuration key:\n\n```json\n  \"type\": \"module\"\n```\n\n### 2. Install TypeSpec dependencies\n\nRun the following command:\n\n```bash\nnpm install --save-peer @typespec/compiler\n```\n\nYou may have need of other dependencies in the TypeSpec standard library depending on what you are doing. E.g. if you want to use the metadata found in `@typespec/openapi` you will need to install that as well.\n\nSee [dependency section](#defining-dependencies) for information on how to define your dependencies.\n\n### 2. Define your main files\n\nYour package.json needs to refer to two main files: your node module main file, and your TypeSpec main. The node module main file is the `\"main\"` key in your package.json file, and defines the entrypoint for your library when consumed as a node library, and must reference a js file. The TypeSpec main defines the entrypoint for your library when consumed from a TypeSpec program, and may reference either a js file (when your library doesn't contain any typespec types) or a TypeSpec file.\n\n```json\n  \"main\": \"dist/index.js\",\n  \"tspMain\": \"lib/main.tsp\"\n```\n\n### 3. Install and initialize TypeScript\n\nRun the following commands:\n\n```bash\nnpm install -D typescript\nnpx tsc --init --strict\n```\n\nThis will create `tsconfig.json`. But we need to make a couple changes to this. Open `tsconfig.json` and set the following settings:\n\n```json\n    \"module\": \"Node16\",           // This and next setting tells TypeScript to use the new ESM import system to resolve types.\n    \"moduleResolution\": \"Node16\",\n    \"target\": \"es2019\",\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\",\n```\n\n### 4. Create `lib.ts`\n\nOpen `./src/lib.ts` and create your library definition that registers your library with the TypeSpec compiler and defines any diagnostics your library will emit. Make sure to export the library definition as `$lib`.\n\n:::warning\nIf `$lib` is not accessible from your library package (`import {$lib} from \"my-library\";`) some functionality will be unavailable like validation of emitter options, linter rules, etc.\n:::\n\nThe following shows an example:\n\n```typescript\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\n\nexport const $lib = createTypeSpecLibrary({\n  name: \"myLibrary\",\n  diagnostics: {},\n} as const);\n\n// Optional but convenient, those are meant to be used locally in your library.\nexport const { reportDiagnostic, createDiagnostic, createStateSymbol } = myLibrary;\n```\n\nDiagnostics are used for linters and decorators which are covered in subsequent topics.\n\n### 5. Create `index.ts`\n\nOpen `./src/index.ts` and import your library definition:\n\n```typescript\n// Re-export $lib to the compiler can get access to it and register your library correctly.\nexport { $lib } from \"./lib.js\";\n```\n\n### 6. Build TypeScript\n\nTypeSpec can only import JavaScript files, so any time changes are made to TypeScript sources, they need to be compiled before they are visible to TypeSpec. To do so, run `npx tsc -p .` in your library's root directory. You can also run `npx tsc -p --watch` if you would like to re-run the TypeScript compiler whenever files are changed.\n\n### 7. Add your main TypeSpec file\n\nOpen `./lib/main.tsp` and import your JS entrypoint. This ensures that when typespec imports your library, the code to define the library is run. In later topics when we add decorators, this import will ensure those get exposed as well.\n\n```typespec\nimport \"../dist/index.js\";\n```\n\n## Adding TypeSpec types to your library\n\nOpen `./lib/main.tsp` and add any types you want to be available when users import this library. It is also strongly recommended you put these types in a namespace that corresponds with the library name. For example, your `./lib/main.tsp` file might look like:\n\n```typespec\nimport \"../dist/index.js\";\n\nnamespace MyLibrary;\nmodel Person {\n  name: string;\n  age: uint8;\n}\n```\n\n## Defining Dependencies\n\nDefining dependencies in a TypeSpec library should be following these rules:\n\n- use `peerDependencies` for all TypeSpec libraries(+ compiler) that you use in your own library/emitter\n- use `devDependencies` for the other typespec libraries used only in tests\n- use `dependencies`/`devDependencies` for any other packages depending if using in library code or in test/dev scripts\n\nTypeSpec libraries are defined using `peerDependencies` so we don't end-up with multiple versions of the compiler/library running at the same time.\n\n**Example**\n\n```jsonc\n{\n  \"dependencies\": {\n    \"yaml\": \"~2.3.1\" // This is a regular package this library/emitter will use\n  },\n  \"peerDependencies\": {\n    // Those are all TypeSpec libraries this library/emitter depend on\n    \"@typespec/compiler\": \"~0.43.0\",\n    \"@typespec/http\": \"~0.43.1\",\n    \"@typespec/openapi\": \"~0.43.0\"\n  },\n  \"devDependencies\": {\n    // This TypeSpec library is only used in the tests but is not required to use this library.\n    \"@typespec/versioning\": \"~0.43.0\",\n    // Typescript is only used during development\n    \"typescript\": \"~5.0.2\"\n  }\n}\n```\n\n## Publishing your TypeSpec library\n\nTo publish to the public npm registry, follow [their documentation](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages).\n\n## Importing your TypeSpec library\n\nOnce your TypeSpec library is published, your users can install and use it just like any of the TypeSpec standard libraries. First, they have to install it:\n\n```bash\nnpm install $packageName\n```\n\nNext, they import it into their TypeSpec program and use the namespace (if desired):\n\n```typespec\nimport \"MyLibrary\";\nusing MyLibrary;\n\nmodel Employee extends Person {\n  job: string;\n}\n```\n\n## Next steps\n\nTypeSpec libraries can contain more than just types. Read the subsequent topics for more details on how to write [decorators](./create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\n\n## Testing\n\nTypeSpec provides a testing framework to help testing libraries. Examples here are shown using `mocha` but any other JS test framework can be used.\n\n### Define the testing library\n\nFirst step is to define how your library can be loaded from the test framework. This will let your library to be reused by other library test.\n\n1. Create a new file `./src/testing/index.ts` with the following content\n\n```ts\nexport const MyTestLibrary = createTestLibrary({\n  name: \"<name-of-npm-pkg>\",\n  // Set this to the absolute path to the root of the package. (e.g. in this case this file would be compiled to ./dist/src/testing/index.js)\n  packageRoot: resolvePath(fileURLToPath(import.meta.url), \"../../../../\"),\n});\n```\n\n2. Add an `exports` for the `testing` endpoint to `package.json` (update with correct paths)\n\n```json\n{\n  // ...\n  \"main\": \"dist/src/index.js\",\n  \"exports\": {\n    \".\": {\n      \"default\": \"./dist/src/index.js\",\n      \"types\": \"./dist/src/index.d.ts\"\n    },\n    \"./testing\": {\n      \"default\": \"./dist/src/testing/index.js\",\n      \"types\": \"./dist/src/testing/index.d.ts\"\n    }\n  }\n}\n```\n\n### Define the test host and test runner for your library\n\nDefine some of the test framework base pieces that will be used in the tests. There is 2 functions:\n\n- `createTestHost`: This is a lower level api that provide a virtual file system.\n- `createTestRunner`: This is a wrapper on top of the test host that will automatically add a `main.tsp` file and automatically import libraries.\n\nCreate a new file `test/test-host.js` (change `test` to be your test folder)\n\n```ts\nimport { createTestHost, createTestWrapper } from \"@typespec/compiler/testing\";\nimport { RestTestLibrary } from \"@typespec/rest/testing\";\nimport { MyTestLibrary } from \"../src/testing/index.js\";\n\nexport async function createMyTestHost() {\n  return createTestHost({\n    libraries: [RestTestLibrary, MyTestLibrary], // Add other libraries you depend on in your tests\n  });\n}\nexport async function createMyTestRunner() {\n  const host = await createOpenAPITestHost();\n  return createTestWrapper(host, { autoUsings: [\"My\"] });\n}\n```\n\n### Write tests\n\nAfter setting up that infrastructure you can start writing tests.\n\n```ts\nimport { createMyTestRunner } from \"./test-host.js\";\n\ndescribe(\"my library\", () => {\n  let runner: BasicTestRunner;\n\n  beforeEach(async () => {\n    runner = await createMyTestRunner();\n  });\n\n  // Check everything works fine\n  it(\"does this\", () => {\n    const { Foo } = runner.compile(`\n      @test model Foo {}\n    `);\n    strictEqual(Foo.kind, \"Model\");\n  });\n\n  // Check diagnostics are emitted\n  it(\"errors\", () => {\n    const diagnostics = runner.diagnose(`\n       model Bar {}\n    `);\n    expectDiagnostics(diagnostics, { code: \"...\", message: \"...\" });\n  });\n});\n```\n\n#### `@test` decorator\n\nThe `@test` decorator is a decorator loaded in the test environment. It can be used to collect any decorable type.\nWhen using the `compile` method it will return a `Record<string, Type>` which is a map of all the types annoted with the `@test` decorator.\n\n```ts\nconst { Foo, CustomName } = runner.compile(`\n  @test model Foo {}\n\n  model Bar {\n    @test(\"CustomName\") name: string\n  }\n`);\n\nFoo; // type of: model Foo {}\nCustomName; // type of : Bar.name\n```\n", "file_path": "../../core/docs\\extending-typespec\\basics.md", "link_to_file": "file://../../core/docs\\extending-typespec\\basics.md"}, {"file_content": "---\nid: create-decorators\ntitle: Creating TypeSpec Decorators\n---\n\n# Creating TypeSpec decorators\n\nTypeSpec decorator are implemented as JavaScript function. Declarating a decorator can be done in 1 or 2 part:\n\n1. [(Optional) Declare the decorator signature in typespec](#declaring-a-decorator-signature)\n2. [Implement the decorator in Javascript](#implement-the-decorator-in-js)\n\n## Declaring a decorator signature\n\nThis part is optional but provides great value:\n\n- Type checking for the parameters\n- IDE IntelliSense\n\nA decorator signature can be declared using the `dec` keyword. As we are implementing the decorator in JS (only choice right now), we must apply the `extern` modifier as well.\n\n```typespec\nextern dec logType(target: unknown, name: string);\n```\n\n## Decorator target\n\nThe first parameter of the decorator represents the typespec type(s) that the decorator can be applied on.\n\nYou can specify multiple potential target type using an `union expression`\n\n```typespec\nusing TypeSpec.Reflection;\n\nextern dec track(target: Model | Enum);\n```\n\n### Optional parameters\n\nA decorator parameter can be marked optional using `?`\n\n```typespec\nextern dec track(target: Model | Enum, name?: valueof string);\n```\n\n### Rest parameters\n\nA decorator's last parameter can be prefixed with `...` to collect all the remaining arguments. The type of that parameter must be an `array expression`\n\n```typespec\nextern dec track(target: Model | Enum, ...names: valueof string[]);\n```\n\n## Ask for a value type\n\nIt is common that decorators parameter will expect a value(e.g. a string or a number). However just using `: string` as the type will also allow a user of the decorator to pass `string` itself or a custom scalar extending string as well as union of strings.\nInstead the decorator can use `valueof <T>` to specify that it is expecting a value of that kind.\n\n| Example           | Description      |\n| ----------------- | ---------------- |\n| `valueof string`  | Expect a string  |\n| `valueof float64` | Expect a float   |\n| `valueof int32`   | Expect a number  |\n| `valueof boolean` | Expect a boolean |\n\n```tsp\nextern dec tag(target: unknown, value: valueof string);\n\n// bad\n@tag(string)\n\n// good\n@tag(\"This is the tag name\")\n```\n\n## Implement the decorator in JS\n\nDecorators can be implemented in JavaScript by prefixing the function name with `$`. A decorator function must have the following parameters:\n\n- `1`: `context` of type `DecoratorContext`\n- `2`: `target` The TypeSpec type target. (`Namespace`, `Interface`, etc.)\n- `3+`: Any arguments of the decorators.\n\n```ts\n// model.ts\nimport type { DecoratorContext, Type } from \"@typespec/compiler\";\n\nexport function $logType(context: DecoratorContext, target: Type, name: valueof string) {\n  console.log(name + \": \" + targetType.kind);\n}\n```\n\nor in pure JS\n\n```ts\n// model.js\nexport function $logType(context, target, name) {\n  console.log(name + \": \" + targetType.kind);\n}\n```\n\nThe decorator can then be consumed this way\n\n```typespec\n// main.tsp\nimport \"./model.js\";\n\n@logType(\"Dog type\")\nmodel Dog {\n  @logType(\"Name type\")\n  name: string;\n}\n```\n\n### Decorator parameter marshalling\n\nFor certain TypeSpec types(Literal types) the decorator do not receive the actual type but a marshalled value if the decorator parmaeter type is a `valueof`. This is to simplify the most common cases.\n\n| TypeSpec Type     | Marshalled value in JS |\n| ----------------- | ---------------------- |\n| `valueof string`  | `string`               |\n| `valueof numeric` | `number`               |\n| `valueof boolean` | `boolean`              |\n\nfor all the other types they are not transformed.\n\n```ts\nexport function $tag(\n  context: DecoratorContext,\n  target: Type,\n  stringArg: string, // Here instead of receiving a `StringLiteral` the string value is being sent.\n  modelArg: Model // Model has no special handling so we receive the Model type\n) {}\n```\n\n### Adding metadata with decorators\n\nDecorators can be used to register some metadata. For this you can use the `context.program.stateMap` or `context.program.stateSet` to insert data that will be tied to the current execution.\n\n\u274c Do not save the data in a global variable.\n\n```ts\nimport type { DecoratorContext, Type } from \"@typespec/compiler\";\nimport type { createStateSymbol } from \"./lib.js\";\n\n// Create a unique key\nconst key = createStateSymbol(\"customName\");\nexport function $customName(context: DecoratorContext, target: Type, name: string) {\n  // Keep a mapping between the target and a value.\n  context.program.stateMap(key).set(target, name);\n\n  // Keep an index of a type.\n  context.program.stateSet(key).add(target);\n}\n```\n\n### Reporting diagnostic on decorator or arguments\n\nDecorator context provide the `decoratorTarget` and `getArgumentTarget` helpers\n\n```ts\nimport type { DecoratorContext, Type } from \"@typespec/compiler\";\nimport type { reportDiagnostic } from \"./lib.js\";\n\nexport function $customName(context: DecoratorContext, target: Type, name: string) {\n  reportDiagnostic({\n    code: \"custom-name-invalid\",\n    target: context.decoratorTarget, // Get location of @customName decorator in typespec document.\n  });\n  reportDiagnostic({\n    code: \"bad-name\",\n    target: context.getArgumentTarget(0), // Get location of {name} argument in typespec document.\n  });\n}\n```\n\n## Declaration - implementation link\n\nDecorator signatures are linked to the implementation of the same name in the same namespace\n\n```typespec\nimport \"./lib.js\";\nextern dec customName(target: Type, name: StringLiteral);\n\nnamespace MyLib {\n  extern dec tableName(target: Type, name: StringLiteral);\n}\n```\n\nis linked the the following in `lib.js`\n\n```ts\nexport function $customName(context: DecoratorContext, name: string) {}\n\nexport function $tableName(context: DecoratorContext, name: string) {}\nsetTypeSpecNamespace(\"MyLib\", $tableName);\n```\n\n## Troubleshooting\n\n### Extern declation must have an implementation in JS file\n\nPotential issues:\n\n- JS function is not prefixed with `$`. For a decorator called `@decorate` the JS function must be called `$decoratate`\n- JS function is not in the same namespace as the the `extern dec`\n- Error is only showing in the IDE? Restart the TypeSpec server or the IDE.\n\nYou can use `--trace bind.js.decorator` to log debug information about decorator loading in JS file that should help pinning down which of those is the issue.\n", "file_path": "../../core/docs\\extending-typespec\\create-decorators.md", "link_to_file": "file://../../core/docs\\extending-typespec\\create-decorators.md"}, {"file_content": "---\ntitle: Diagnostics\n---\n\nTypeSpec compiler report errors and warnings in the spec using the diagnostic API.\n\n## Best practices\n\n- \u274c Do not use `throw` to report errors. Any exception thrown like this will be presented as a bug in your library to the user.\n- \u2705 Use diagnostic API to report expected errors and warnings.\n  - \u2705 Use `reportDiagnostic` in a decorator, `$onValidate` or `$onEmit`\n  - \u274c Do not use `reportDiagnostic` in an accessor(A function meant to be consumed in another library or emitter). See [collect diagnostics section](#collect-diagnostics)\n\n## Diagnostic specification\n\n- Each diagnostic MUST have a `code`. The full code is the the library name followed by the declared code. (`<lib-name>/<local-code>`)\n- Each diagnostic MUST have a `severity`. It can be `error`, `warning`. Errors cannot be suppressed\n- Each diagnostics MUST have at least one message. Using `default` as the `messageId` will allow it to be the default selected.\n- Each diagnostics message MAY have parameters to interpolate information into the message\n\n## Usage\n\n### Declare the diagnostics you are reporting\n\n```ts\n// in lib.js\nexport const { reportDiagnostic, createDiagnostic, createStateSymbol } = createTypeSpecLibrary({\n  name: \"@typespec/my-lib\",\n  diagnostics: {\n    // Basic diagnostic with a fixed message\n    \"no-array\": {\n      severity: \"error\",\n      messages: {\n        default: `Array is not allowed in my-lib models.`,\n      },\n    },\n\n    // Parameterized message\n    \"duplicate-route\": {\n      severity: \"error\",\n      messages: {\n        default: paramMessage`Route '${\"path\"}' is being referenced in 2 different operations.`,\n      },\n    },\n\n    // Multiple messages\n    \"duplicate-name\": {\n      severity: \"warning\",\n      messages: {\n        default: paramMessage`Duplicate type name: '${\"value\"}'.`,\n        parameter: paramMessage`Duplicate parameter key: '${\"value\"}'.`,\n      },\n    },\n  },\n} as const);\n```\n\nThis will represent 3 different diagnostics with full name of\n\n- `@typespec/my-lib/no-array`\n- `@typespec/my-lib/duplicate-route`\n- `@typespec/my-lib/duplicate-name`\n\n### Report diagnostics\n\n```ts\nimport { reportDiagnostic } from \"./lib.js\";\n\n// Basic diagnostic with a fixed message\nreportDiagnostic(program, {\n  code: \"no-array\",\n  target: diagnosticTarget,\n});\n\n// Parameterized message\nreportDiagnostic(program, {\n  code: \"duplicate-route\",\n  format: {path: \"/foo\"}\n  target: diagnosticTarget,\n});\n\n// Multiple messages\nreportDiagnostic(program, {\n  code: \"duplicate-name\",\n  messageId: \"parmaeter\",\n  format: {value: \"$select\"},\n  target: diagnosticTarget,\n});\n```\n\n### Collect diagnostics\n\nWhen trying to report diagnostic in an accessor a good pattern is not to report the diagnostic to the program directly but return a tuple to let the user decide what to do.\nThis prevent duplicate diagnostics emitter if the accessor is called multiple times.\n\n```ts\nimport { createDiagnosticCollector, Diagnostic } from \"@typespec/compiler\";\n\nfunction getRoutes(): [Route, readonly Diagnostic] {\n  const diagnostics = createDiagnosticCollector();\n  diagnostics.add(\n    createDiagnostic(program, {\n      code: \"no-array\",\n      target: diagnosticTarget,\n    })\n  );\n  const result = diagnostic.pipe(getParameters()); // to pipe diagnostics returned by `getParameters`\n  return diagnostics.wrap(routes);\n}\n```\n\nor manually\n\n```ts\nimport { Diagnostic } from \"@typespec/compiler\";\n\nfunction getRoutes(): [Route, readonly Diagnostic] {\n  const diagnostics = [];\n  diagnostics.push(\n    createDiagnostic(program, {\n      code: \"no-array\",\n      target: diagnosticTarget,\n    })\n  );\n  return [routes, diagnostics];\n}\n```\n", "file_path": "../../core/docs\\extending-typespec\\diagnostics.md", "link_to_file": "file://../../core/docs\\extending-typespec\\diagnostics.md"}, {"file_content": "---\nid: emitter-framework\ntitle: Emitter framework\n---\n\nThe emitter framework makes writing emitters from TypeSpec to other assets a fair bit easier than manually consuming the type graph. The framework gives you an easy way to handle all the types TypeSpec might throw at you and know when you're \"feature complete\". It also handles a lot of hard problems for you, such as how to construct references between types, how to handle circular references, or how to propagate the context of the types you're emitting based on their containers or where they're referenced from. Lastly, it provides a class-based inheritance model that makes it fairly painless to extend and customize existing emitters.\n\n## Getting Started\n\nMake sure to read the getting started section under the [emitter basics](./emitters-basics.md) topic. To use the framework, you will need an emitter library and `$onEmit` function ready to go.\n\n## Implementing your emitter\n\nImplementing an emitter using the emitter framework will use a variety of types from the framework. To give you a high level overview, these are:\n\n- `AssetEmitter`: The asset emitter is the main type you will interact with in your `$onEmit` function. You can pass the asset emitter types to emit, and tell it to write types to disk or give you source files for you to process in other ways.\n- `TypeEmitter`: The type emitter is the base class for most of your emit logic. Every TypeSpec type has a corresponding method on TypeEmitter. It also is where you will manage your emit context, making it easy to answer such questions as \"is this type inside something I care about\" or \"was this type referenced from something\".\n- `CodeTypeEmitter`: A subclass of `TypeEmitter` that makes building source code easier.\n- `StringBuilder`, `ObjectBuilder`, `ArrayBuilder`: when implementing your `TypeEmitter` you will likely use these classes to help you build strings and object graphs. These classes take care of handling the placeholders that result from circular references.\n\nLet's walk through each of these types in turn.\n\n### `AssetEmitter<T>`\n\nThe asset emitter is responsible for driving the emit process. It has methods for taking TypeSpec types to emit, and maintains the state of your current emit process including the declarations you've accumulated, current emit context, and converting your emitted content into files on disk.\n\nTo create your asset emitter, call `createAssetEmitter` on your emit context in `$onEmit`. It takes the TypeEmitter which is covered in the next section. Once created, you can call `emitProgram()` to emit every type in the TypeSpec graph. Otherwise, you can call `emitType(someType)` to emit specific types instead.\n\n```typescript\nexport async function $onEmit(context: EmitContext) {\n  const assetEmitter = context.createAssetEmitter(MyTypeEmitter);\n\n  // emit my entire typespec program\n  assetEmitter.emitProgram();\n  // or, maybe emit types just in a specific namespace\n  const ns = context.program.resolveTypeReference(\"MyNamespace\")!;\n  assetEmitter.emitType(ns);\n\n  // lastly, write your emit output into the output directory\n  await assetEmitter.writeOutput();\n}\n```\n\n### `TypeEmitter<T>`\n\nThis is the base class for writing logic to convert TypeSpec types into assets in your target language. Every TypeSpec type has at least one method on this base class, and many have multiple methods. For example, models have both `ModelDeclaration` and `ModelLiteral` methods to handle `model Pet { }` declarations and `{ anonymous: boolean }` literals respectively.\n\nTo support emitting all TypeSpec types, you should expect to implement all of these methods. But if you don't want to support emitting all TypeSpec types, you can either throw or just not implement the method, in which case the type will not be emitted.\n\nThe generic type parameter `T` is the type of emit output you are building. For example, if you're emitting source code, `T` will be `string`. If you're building an object graph like JSON, `T` will be `object`. If your `T` is `string`, i.e. you are building source code, you will probably want to use the `CodeTypeEmitter` subclass which is a bit more convenient, but `TypeEmitter<string>` will also work fine.\n\nA simple emitter that doesn't do much yet might look like:\n\n```typescript\nclass MyCodeEmitter extends CodeTypeEmitter {\n  modelDeclaration(model: Model, name: string) {\n    console.log(\"Emitting a model named\", name);\n  }\n}\n```\n\nPassing this to `createAssetEmitter` and calling `assetEmitter.emitProgram()` will console.log all the models in the program.\n\n#### EmitterOutput\n\nMost methods of the `TypeEmitter` must either return `T` or an `EmitterOutput<T>`. There are four kinds of `EmitterOutput`:\n\n- `Declaration<T>`: A declaration, which has a name and is declared in a scope, and so can be referenced by other emitted types (more on References later). Declarations are created by calling `this.emitter.result.declaration(name, value)` in your emitter methods. Scopes come from your current context, which is covered later in this document.\n- `RawCode<T>`: Output that is in some way concatenated into the output but cannot be referenced (e.g. things like type literals). Raw code is created by calling `this.emitter.result.rawCode(value)` in your emitter methods.\n- `NoEmit`: The type does not contribute any output. This is created by calling `this.emitter.result.none()` in your emitter methods.\n- `CircularEmit`: Indicates that a circular reference was encountered, which is generally handled by the framework with Placeholders (see the next section). You do not need to create this result yourself, the framework will produce this when required.\n\nWhen an emitter returns `T` or a `Placeholder<T>`, it behaves as if it returned `RawCode<T>` with that value.\n\nTo create these results, you use the `result.*()` APIs on `AssetEmitter`, which can be accessed via `this.emitter.result` in your methods.\n\nWith this in mind, we can make `MyCodeEmitter` a bit more functional:\n\n```typescript\nclass MyCodeEmitter extends CodeTypeEmitter {\n  // context and scope are covered later in this document\n  programContext(program: Program): Context {\n    const sourceFile = this.emitter.createSourceFile(\"test.txt\");\n    return {\n      scope: sourceFile.globalScope,\n    };\n  }\n\n  modelDeclaration(model: Model, name: string) {\n    const props = this.emitter.emitModelProperties(model);\n    return this.emitter.result.declaration(name, `declaration of ${name}`);\n  }\n}\n```\n\nIf we have a typespec program that looks like:\n\n```typespec\nmodel Pet {}\n```\n\nand we call `assetEmitter.writeOutput()`, we'll find `test.txt` contains the contents `\"declaration of Pet\"`.\n\nIn order to emit properties of `Pet`, we'll need to concatenate the properties of pets with the declaration we made and leverage builders to make that easy. These topics are covered in the next two sections.\n\n#### Concatenating results\n\nIt is very rare that you only want to emit a declaration and nothing else. Probably your declaration will have various parts to it, and those parts will depend on the emit output of the parts of the type your emitting. For example, a declaration from a TypeSpec model will likely include members based on the members declared in the TypeSpec.\n\nThis is accomplished by calling `emit` or other `emit*` methods on the asset emitter from inside your `AssetEmitter` methods. For example, to emit the properties of a model declaration, we can call `this.emitter.emitModelProperties(model)`. This will invoke your the corresponding `AssetEmitter` method and return you the `EmitterOutput` result.\n\nIt is unlikely that you want to concatenate this result directly. For declarations and raw code, the `value` property is likely what you're interested in, but there are other complexities as well. So in order to concatenate results together, you probably want to use a builder.\n\n#### Builders\n\nBuilders are helpers that make it easy to concatenate output into your final emitted asset. They do two things of note: they handle extracting the value from `Declaration` and `rawCode` output, and they handle `Placeholder` values that crop up due to circular references. Three `builders` are provided:\n\n- Strings: Using the `code` template literal tag, you can concatenate `EmitterOutput`s together into a final string.\n- Object: Constructing an `ObjectBuilder` with an object will replace any `EmitterOutput` in the object with its value and handle placeholders as necessary.\n- Array: Constructing an `ArrayBuilder` will let you push `EmitterOutput` and pull out the value and placeholders as necessary.\n\nNow with these tools, we can make `MyCodeEmitter` even more functional:\n\n```typescript\nclass MyCodeEmitter extends CodeTypeEmitter {\n  // context is covered later in this document\n  programContext(program: Program): Context {\n    const sourceFile = this.emitter.createSourceFile(\"test.txt\");\n    return {\n      scope: sourceFile.globalScope,\n    };\n  }\n\n  modelDeclaration(model: Model, name: string) {\n    const props = this.emitter.emitModelProperties(model);\n    return this.emitter.result.declaration(name, code`declaration of ${name} with ${props}`);\n  }\n\n  modelPropertyLiteral(property: ModelProperty): EmitterOutput<string> {\n    return code`a property named ${property.name} and a type of ${this.emitter.emitType(\n      property.type\n    )}`;\n  }\n\n  modelLiteral(model: Model) {\n    return `an object literal`;\n  }\n}\n```\n\nNow given a typespec program like:\n\n```typespec\nmodel Pet {\n  position: {};\n}\n```\n\nwe will find `test.txt` contains the output\n\n> declaration of Pet with a property named position and a type of an object literal\n\n#### References between emitted types\n\nA common scenario when emitting to most targets is handling how to make references between types. This can get pretty complex, especially when the declarations are emitted into different scopes. The emitter framework does a lot of heavy lifting for you by calculating the scopes between your current context and the declaration you're trying to reference.\n\nHow declarations arrive in different scopes is covered in the Context section later in this document.\n\nLet's look at the `reference` signature on the TypeEmitter:\n\n```typescript\n  reference(\n    targetDeclaration: Declaration<string>,\n    pathUp: Scope<string>[],\n    pathDown: Scope<string>[],\n    commonScope: Scope<string> | null\n  ): string | EmitEntity<string> {}\n```\n\nThe `reference` function is called with:\n\n- `targetDeclaration`: The declaration we're making a reference to.\n- `pathUp`: The scopes between our current scope and the common scope.\n- `pathDown`: The scopes between the common scope and the declaration we're referencing.\n- `commonScope`: The nearest scope shared between our current scope and the target declaration.\n\nSo let's imagine we have declarations under the following scopes:\n\n```\nsource file\n  namespace A\n    namespace B\n      model M1\n  namespace C\n    model M2\n```\n\nIf M1 references M2, `reference` will be called with the following arguments:\n\n- `targetDeclaration`: M2\n- `pathUp`: [namespace B, namespace A]\n- `pathDown`: [namespace C]\n- `commonScope`: source file\n\nFor languages which walk up a scope chain in order to find a reference (e.g. TypeScript, C#, Java, etc.), you generally won't need `pathUp`, you can just join the scopes in the `pathDown` resulting in a reference like `C.M2`. Other times you may need to construct a more path-like reference, in which case you can emit for example a `../` for every item in `pathUp`, resulting in a reference like `../../C/M2`.\n\nWhen the declarations don't share any scope, `commonScope` will be null. This happens when the types are contained in different source files. In such cases, your emitter will likely need to import the target declaration's source file in addition to constructing a reference. The source file has an `imports` property that can hold a list of such imports.\n\nWe can update our example emitter to generate references by adding an appropriate `references` method:\n\n```typescript\nclass MyCodeEmitter extends CodeTypeEmitter {\n  // snip out the methods we implemented previously\n\n  // If the model is Person, put it into a special namespace.\n  // We will return to this in detail in the next section.\n  modelDeclarationContext(model: Model, name: string): Context {\n    if (model.name === \"Person\") {\n      const parentScope = this.emitter.getContext().scope;\n      const scope = this.emitter.createScope({}, \"Namespace\", parentScope);\n\n      return {\n        scope,\n      };\n    } else {\n      return {};\n    }\n  }\n\n  reference(\n    targetDeclaration: Declaration<string>,\n    pathUp: Scope<string>[],\n    pathDown: Scope<string>[],\n    commonScope: Scope<string> | null\n  ): string | EmitEntity<string> {\n    const segments = pathDown.map((s) => s.name);\n    segments.push(targetDeclaration.name);\n\n    return `a reference to ${segments.join(\".\")}`;\n  }\n}\n```\n\nNow if we emit the following TypeSpec program:\n\n```typespec\nmodel Pet {\n  person: Person;\n}\n\nmodel Person {\n  pet: Pet;\n}\n```\n\nWe will find that `test.txt` contains the following text:\n\n> declaration of Pet with a property named person and a type of a reference to Namespace.Person\n\n#### Placeholders\n\nConsider the following TypeSpec program:\n\n```typespec\nmodel Pet {\n  owner: Person;\n}\n\nmodel Person {\n  pet: Pet;\n}\n```\n\nIn order to emit `Pet`, we need to emit `Person`, so we go to emit that. But in order to emit `Person`, we need to emit `Pet`, which is what we're already trying to do! We're at an impasse. This is a circular reference.\n\nThe emitter framework handles circular references via `Placeholder`s. When a circular reference is encountered, the `value` of an `EmitterOutput` is set to a placeholder that is filled in when we've finished constructing the thing we referenced. So in the case above, when emitting `Person` and we come across the circular reference to `Pet`, we'll return a `Placeholder`. We'll then come back to `Pet`, finish it and return an `EmitterOutput` for it, and then set any `Placeholder`s waiting for `Pet` to that output.\n\nIf you're using the `Builder`s that come with the framework, you will not need to worry about dealing with `Placeholder` yourself.\n\n#### Context\n\nA common need when emitting TypeSpec is to know what context you are emitting the type in. There is one piece of required context: `scope`, which tells the emitter framework where you want to place your declarations. But you might also want to easily answer questions like: am I emitting a model inside a particular namespace? Or am I emitting a model that is referenced from the return type of an operation? The emitter framework makes managing this context fairly trivial.\n\nEvery method that results in an `EmitterOutput` has a corresponding method for setting lexical and reference context. We saw this above when we created `modelDeclarationContext` in order to put some models into a different namespace.\n\n##### Lexical Context\n\nLexical context is available when emitting types that are lexically contained within the emitted entity in the source TypeSpec. For example, if we set `modelDeclarationContext`, that context will be visible when emitting the model's properties and any nested model literals.\n\n##### Reference Context\n\nReference context is passed along when making references and otherwise propagates lexically. For example, if we set `modelDeclarationReferenceContext`, that context will be visible when emitting the model's properties and any nested model literals just like with lexical context. But unlike with lexical context, if the current model references another type, then the reference context will be visible when emitting the referenced model.\n\nNote that this means that we may emit the same model multiple times. Consider the following TypeSpec program:\n\n```typespec\nmodel Pet {}\nmodel Person {\n  pet: Pet;\n}\n```\n\nIf, when emitting Person, we set the reference context to `{ refByPerson: true }`, we will call `emitModel` for `Pet` twice, once with no context set, and once again with the context we set when emitting `Person`. This behavior is very handy when you want to emit the same model different ways depending on how it is used, e.g. when your emit differs whether a model is an input type or output type, or when a model's properties differ based on any `@visibility` decorators and the context the model appears in (e.g. for Resources, whether it's being read, updated, created, deleted, etc.).\n\n#### Scope\n\nThe scope that declarations are created in is set in using context. When emitting all of your TypeSpec program into the same file, and not emitting types into any kind of namespace, it suffices to set scope once in `programContext`. Call `this.emitter.createSourceFile(\"filePath.txt\")` to create a source file, which comes with a scope ready to use.\n\nTo emit into different source files, e.g. if we want to emit using a \"one class per file\" pattern, move the into a more granular context method. For example, if we instead create source files in `modelDeclarationContext`, then declarations for each model will be in their own file.\n\nIf we want to emit into namespaces under a source file, we can create scopes manually. Call `this.emitter.createScope(objectReference, name, parentScope)`. The `objectReference` is an object with metadata about the scope. You might use this to emit e.g. a namespace declaration in your target language, but often it can just be an empty object (`{}`). Name is the name of the scope, used when constructing references. And parent scope is the scope this is found under.\n\nLets return to our previous example:\n\n```typescript\n  modelDeclarationContext(model: Model, name: string): Context {\n    if (model.name === \"Person\") {\n      const parentScope = this.emitter.getContext().scope;\n      const scope = this.emitter.createScope({}, \"Namespace\", parentScope);\n\n      return {\n        scope,\n      };\n    } else {\n      return {};\n    }\n  }\n```\n\nWe can now see how this results in the `Person` model being located in a nested scope - because we set `scope` on the context to a new scope we created via `this.emitter.setScope`.\n\n### Extending `TypeEmitter`\n\nTypeEmitters are classes and explicitly support subclassing, so you can customize an existing emitter by extending it and overriding any methods you want to customize in your subclass. In fact, emitters you find out in the ecosystem are likely not to work without creating a subclass, because they only know how to emit types, but you need to provide the scope for any declarations it wants to create. For example, if we have a base `TypeScriptEmitter` that can convert TypeSpec into TypeScript, we might extend it to tell it to put all declarations in the same file:\n\n```typescript\nclass MyTsEmitter extends TypeScriptEmitter {\n  programContext(program: Program): Context {\n    const sourceFile = this.emitter.createSourceFile(\"test.txt\");\n    return {\n      scope: sourceFile.globalScope,\n    };\n  }\n}\n```\n\nOr, if we want one class or interface per file, we might instead do something like:\n\n```typescript\nclass MyTsEmitter extends TypeScriptEmitter {\n  modelDeclarationContext(program: Program): Context {\n    const sourceFile = this.emitter.createSourceFile(\"test.txt\");\n    return {\n      scope: sourceFile.globalScope,\n    };\n  }\n  // and similar for other declarations: Unions, Enums, Interfaces, and Operations.\n}\n```\n", "file_path": "../../core/docs\\extending-typespec\\emitter-framework.md", "link_to_file": "file://../../core/docs\\extending-typespec\\emitter-framework.md"}, {"file_content": "---\nid: emitter-metadata-handling\ntitle: Handling metadata and visibility in emitters for REST API\n---\n\n# Handling metadata and visibility in emitters for REST API\n\nIt's important that all emitters for REST API handle [automatic visibility](../standard-library/http/operations.md#automatic-visibility) and [metadata](../standard-library/http/operations.md#metadata) consistently. Make sure to read through the TypeSpec-author documentation of these features to understand how they work. This document will cover how to incorporate them correctly into your own emitter.\n\nThe standard `@typespec/rest` library provides JavaScript API for emitters to interpret API written using its decorators. We'll look at the API that are particularly relevant to these features.\n\nNote that when we say that emitters must handle things consistently, we mean that they must agree on how data is sent and received over the wire. After all, a TypeSpec _specification_ must be able to serve as a source-of-truth on these details. Nevertheless, emitters are still free to _abstract_ things above this level and to make different choices in doing so. For example, the OpenAPI emitter will sometimes split a single TypeSpec model into multiple suffixed schemas with names like `UserCreate` and `UserUpdate` while a client SDK emitter may choose to emit a single `User` class that that can be serialized to a request or deserialized from a response with different fields present in different cases. In fact, these features were designed specifically to allow a TypeSpec specification to be written in terms of logical entities that emitters could then preserve.\n\n## Getting started\n\nIf you haven't written an emitter before, start with [emitter basics](./emitters-basics.md).\n\nThen look at the [REST metadata emitter sample](https://github.com/microsoft/typespec/tree/main/packages/samples/rest-metadata-emitter). This emitter sample uses all of the API discussed below to write out a simple textual representation. It deliberately does not split types like the OpenAPI emitter in order to emphasize that this is not required. Instead, it adds contextual remarks to denote how data depends on context.\n\nHowever, if your emitter does want to split types as OpenAPI does, then it will still use the same API. Cross-referencing with where the official [OpenAPI emitter] calls these API can also be instructive.\n\n## Key API\n\nThese are the main API involved in handling these features. See the linked API reference documentation for more details.\n\n- [`getRequestVisibility(HttpVerb): Visibility`](../standard-library/http/reference/js-api/index.md#getrequestvisibility) - Use this to determine the visibility implied for data in the request parameters or body. Also note that [`Visibility.Read`](../standard-library/http/reference/js-api/enumerations/Visibility.md#item) is always applied for response data and therefore there is no corresponding API for the response.\n\n- [`MetadataInfo`](../standard-library/http/reference/js-api/interfaces/MetadataInfo.md) - Create this once for each program using [`createMetadataInfo(Program, MetadataInfoOptions)`](../standard-library/http/reference/js-api/index.md#createmetadatainfo) then use it to reason about metadata and visibility implications with the API below.\n\n- [`MetadataInfo.getEffectivePayloadType(Type, Visibility): Type`](../standard-library/http/reference/js-api/interfaces/MetadataInfo.md#geteffectivepayloadtype) - Use this recursively on every type that is referenced. When given an anonymous model sourced entirely from a single named model after metadata is moved elsewhere or invisible properties are removed, it will recover the named model. This handles the commonly discussed case of seeing that `op something(...Thing)` receives a `Thing` in its request body, but also many other cases..\n\n- [`MetadataInfo.isTransformed(Model, Visibility)`](../standard-library/http/reference/js-api/interfaces/MetadataInfo.md#istransformed) - Use this to check if a type undergoes any changes in shape due to visibility or metadata. If not, this can allow for simplifications in emit.\n\n- [`MetadataInfo.isPayloadProperty(ModelProperty, Visibility): boolean`](../standard-library/http/reference/js-api/interfaces/MetadataInfo.md#ispayloadproperty) - Use this to check if a property is transmitted as an object property in the payload and is not invisible or metadata sent elsewhere.\n\n- [`MetadataInfo.isOptional(ModelProperty, Visibility): boolean`](../standard-library/http/reference/js-api/interfaces/MetadataInfo.md#isoptional) - Use this to determine if a property is optional for the given visibility. This will differ from `ModelProperty.isOptional` when the Visibility is Update in which case the property is always considered optional.\n\n- [`Visibility.Item`](../standard-library/http/reference/js-api/enumerations/Visibility.md#item) - Add this flag when recursing into an array. This moves all metadata into the payload, which can be useful in scenarios like batching API calls.\n", "file_path": "../../core/docs\\extending-typespec\\emitter-metadata-handling.md", "link_to_file": "file://../../core/docs\\extending-typespec\\emitter-metadata-handling.md"}, {"file_content": "---\nid: emitters\ntitle: Emitters\n---\n\n# Writing emitters\n\nTypeSpec emitters are libraries that use various TypeSpec compiler APIs to reflect on the typespec compilation and produce generated artifacts. The typespec standard library includes an emitter for OpenAPI version 3.0, but odds are good you will want to emit TypeSpec to another output format. In fact, one of TypeSpec's main benefits is how easy it is to use TypeSpec as a source of truth for all data shapes, and the ease of writing an emitter is a big part of that story.\n\n## Getting started\n\nTypeSpec emitters are a special kind of TypeSpec library and so have the same getting started instructions. Follow [these steps](#todo) to initialize a typespec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entrypoint. It receives two arguments:\n\n- _context_: The current context including the current progfam being compiled\n- _options_: Custom configuration options selected for this emitter\n\nFor example, the following will write a text file to the output directory:\n\n```typescript\nimport { EmitContext } from \"@typespec/compiler\";\nimport Path from \"path\";\n\nexport async function $onEmit(context: EmitContext) {\n  const outputDir = Path.join(context.emitterOutputDir, \"hello.txt\");\n  await context.program.host.writeFile(outputDir, \"hello world!\");\n}\n```\n\nYou can now compile a TypeSpec program passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo pass your emitter custom options, the options must be registered with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to take. The compiler has a helper to make this easier:\n\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that helps you fill in the JSON schema for that type.\n\nThe following example extends the hello world emitter to be configured with a name:\n\n```typescript\nimport { JSONSchemaType, createTypeSpecLibrary } from \"@typespec/compiler\";\nimport Path from \"path\";\n\nexport interface EmitterOptions {\n  \"target-name\": string;\n}\n\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\n  type: \"object\",\n  additionalProperties: false,\n  properties: {\n    \"target-name\": { type: \"string\", nullable: true },\n  },\n  required: [],\n};\n\nexport const $lib = createTypeSpecLibrary({\n  name: \"MyEmitter\",\n  diagnostics: {},\n  emitter: {\n    options: EmitterOptionsSchema,\n  },\n});\n\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\n  const outputDir = Path.join(context.emitterOutputDir, \"hello.txt\");\n  const name = context.options.targetName;\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\n}\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\n- An option called `output-dir` can be created and should override the compiler `output-dir`\n\n#### Emitter options vs. decorators\n\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is finding types to emit. There are three main approaches:\n\n1. The [emitter framework](./emitter-framework.md), which makes it relatively easy to emit all your TypeSpec types (or a subset, if you wish).\n1. The Semantic Walker, which lets you easily run code for every type in the program\n1. Custom traversal, which gives you a lot more flexibility than either of the previous approaches at the cost of some complexity.\n\n### Emitter Framework\n\nThe emitter framework provides handles a lot of hard problems for you while providing an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page to learn more.\n\n### Semantic Walker\n\nThe Semantic Walker will visit every type in the TypeSpec program and call any callbacks you provide for that type. To use, import `navigateProgram` from `@typespec/compiler`. Starting a walk needs two parameters - the program to walk, and an object with callbacks for each type. For example, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\n\n```typescript\nnavigateProgram(program, {\n  model(m) {\n    // emit m\n  },\n});\n```\n\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e. as soon as it sees a type for the first time it will invoke your callback. You can invoke callback post-order instead by prefixing the type name with `exit`, for example `exitModel(m)`.\n\nNote that the semantic walker will visit all types in the program including built-in TypeSpec types and typespec types defined by any libraries you're using. Care must be taken to filter out any types you do not intend to emit. Sometimes this is quite difficult, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften times you will want to emit specific types, for example types that have a particular decorator or are in a particular namespace. In such cases it is often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its [various fields](#todo) to and emit those types as well if needed.\n\nFor example, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it is more efficient to implement `@emitThis` such that it keeps a list of all the types its attached to and iterate that list. We can then traverse into types it references if needed.\n\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\n\n[See creating decorator documentation for more details](./create-decorators.md)\n\n```typescript\nimport { DecoratorContext, Model, createStateSymbol } from \"@typespec/compiler\";\n\n// Decorator Setup Code\n\nconst emitThisKey = createStateSymbol(\"emitThis\");\n\n// @emitThis decorator\nexport function $emitThis(context: DecoratorContext, target: Model) {\n  context.program.stateSet(emitThisKey).add(target);\n}\n\nexport async function $onEmit(context: EmitContext) {\n  for (const model of program.stateSet(emitThisKey)) {\n    emitModel(model);\n  }\n}\n\nfunction emitModel(model: Model) {\n  // emit this model\n  for (const prop of model.properties.values()) {\n    // recursively emit models referenced by the parent model\n    emitModel(prop.type);\n  }\n}\n```\n\n### Resolving a typespec type\n\nSometimes you might want to get access to a known TypeSpec type in the type graph, for example a model that you have defined in your library.\n\nA helper is provided on the program to do that.\n\n```ts\nprogram.resolveTypeReference(reference: string): Type | undefined;\n```\n\nThe reference must be a valid typespec reference(Like you would have it in a typespec document)\n\n**Example**\n\n```ts\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve typespec string intrinsic type\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\n```\n\nError example\n\n```ts\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\n```\n\n## Emitting files to disk\n\nSince an emitter is a node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\n\nInstead, use the compiler [`host` interface](#todo) to access the file system. The API is equivalent to the node API but works in a wider range of scenarios.\n\nIn order to know where to emit files, the emitter context has a `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. This is set to `{cwd}/tsp-output/{emitter-name}` by default, but can be overridden by the user. Do not use the `compilerOptions.outputDir`\n\n## Handling scalars\n\nScalars are types in TypeSpec that most likely have a primitive or built-in datastructure representing those in the target language.\n\nRecommended logic for emitting scalar is to:\n\n1. If scalar is a known scalar(e.g. `int32`), emit the known mapping.\n2. Otherwise check scalar `baseScalar` and go back to `1.`\n   2.1 After resolving which scalar apply any decorators\n\n:::note\nIf the scalar is generic and doesn't have a mapping (e.g. integer), we recommend substituting it with the next closest mapping (e.g. integer->int64) and emitting a warning.\n:::\n\n### Examples\n\n```tsp\n@minValue(10)\nscalar myInt32 extends int32;\n\n@minValue(20)\nscalar specializedInt32 extends myInt32;\n```\n\n| Scalar             | Expected type | Description                                                                                                                                 |\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Handling Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\n\n```tsp\nmodel User {\n  isActive?: boolean = true;\n}\n```\n\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\n\n```ts\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\nconst defaultValue = modelProp.default; // value: true\n```\n\nIt is important that emitters handle default values in a consistent way. Default values SHOULD NOT be used as client-side default values. Instead, they should be used as a way to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the service-side default.\n", "file_path": "../../core/docs\\extending-typespec\\emitters-basics.md", "link_to_file": "file://../../core/docs\\extending-typespec\\emitters-basics.md"}, {"file_content": "---\nid: linters\ntitle: Linters\n---\n\n# Linters\n\n## Linter vs `onValidate`\n\nTypeSpec library can probide a `$onValidate` hook which can be used to validate the typespec program is valid in the eye of your library.\n\nA linter on the other hand might be a validation that is optional, the program is correct but there could be some improvements. For example requiring documentation on every type. This is not something that is needed to represent the typespec program but without it the end user experience might suffer.\nLinters need to be explicitly enabled. `$onValidate` will be run automatically if that library is imported.\n\n## Writing a linter\n\nSee examples in `packages/best-practices`.\n\n### 1. Define a rules\n\n```ts\nimport {  createLinterRule } from \"@typespec/compiler\";\nimport { reportDiagnostic } from \"../lib.js\";\n\nexport const requiredDocRule = createLinterRule({\n  name: \"no-model-doc\",\n  severity: \"warning\",\n  // Short description of what this linter rule does. To be used for generated summary of a linter.\n  description: \"Enforce documentation on models.\",\n  messages: {\n    default: `Must be documented.`,\n    // Different messages can be provided\n    models: `Models must be documented.`,\n\n    // Message can be parameterized\n    enums: paramMessage`Enum ${\"enumName\"} must be documented.`,\n  },\n  create(context) {\n    return {\n      operation: (op) => {\n        if (!getDoc(context.program, op)) {\n          context.reportDiagnostic({\n            target: model,\n          });\n        }\n      },\n      model: (model) => {\n        if (!getDoc(context.program, model)) {\n          context.reportDiagnostic({\n            messageId: \"models\",\n            target: model,\n          });\n        }\n      },\n      enums: (type) => {\n        if (!getDoc(context.program, type)) {\n          context.reportDiagnostic({\n            messageId: \"enums\",\n            format: {enumName: type.name}\n            target: model,\n          });\n        }\n      },\n    };\n  },\n});\n```\n\n#### Don'ts\n\n- \u274c Do not call `program.reportDiagnostic` or your library `reportDiagnostic` helper directly in a linter rule\n\n```ts\n// \u274c Bad\nprogram.reportDiagnostic({\n  code: \"other-code\",\n  target,\n});\n// \u274c Bad\nreportDiagnostic(program, {\n  code: \"other-code\",\n  target,\n});\n\n// \u2705 Good\ncontext.reportDiagnostic({\n  target,\n});\n```\n\n### Register the rules\n\n<!-- cspell:disable-next-line -->\n\nWhen defining your `$lib` with `createTypeSpecLibrary`([See](./basics.md#4-create-libts)) an additional entry for `linter` can be provided\n\n```ts\n// Import the rule defined previously\nimport { requiredDocRule } from \"./rules/required-doc.rule.js\";\n\nexport const $lib = createTypeSpecLibrary({\n  name: \"@typespec/my-linter\",\n  diagnostics: {},\n  linter: {\n    // Include all the rules your linter is defining here.\n    rules: [requiredDocRule],\n\n    // Optionally a linter can provide a set of rulesets\n    ruleSets: {\n      recommended: {\n        // (optional) A ruleset takes a map of rules to explicitly enable\n        enable: { [`@typespec/my-linter/${requiredDocRule.name}`]: true },\n\n        // (optional) A rule set can extend another rule set\n        extends: [\"@typespec/best-practices/recommended\"],\n\n        // (optional) A rule set can disable a rule enabled in a ruleset it extended.\n        disable: {\n          \"`@typespec/best-practices/no-a\": \"This doesn't apply in this ruleset.\",\n        },\n      },\n    },\n  },\n});\n```\n\nWhen referencing a rule or ruleset(in `enable`, `extends`, `disable`) the rule or rule set id must be used which in this format: `<libraryName>/<ruleName>`\n\n## Testing a linter\n\nTo test linter rule an rule tester is provided letting you test a specific rule without enabling the others.\n\nFirst you'll want to create an instance of the rule tester using `createLinterRuleTester` passing it the rule that is being tested.\nYou can then provide different test checking the rule pass or fails.\n\n```ts\nimport { RuleTester, createLinterRuleTester, createTestRunner } from \"@typespec/compiler/testing\";\nimport { requiredDocRule } from \"./rules/required-doc.rule.js\";\n\ndescribe(\"required-doc rule\", () => {\n  let ruleTester: RuleTester;\n\n  beforeEach(() => {\n    const runner = createTestRunner();\n    ruleTester = createLinterRuleTester(runner, requiredDocRule, \"@typespec/my-linter\");\n  });\n\n  it(\"emit diagnostics when using model named foo\", async () => {\n    await ruleTester.expect(`model Foo {}`).toEmitDiagnostics({\n      code: \"@typespec/my-linter/no-foo-model\",\n      message: \"Cannot name a model with 'Foo'\",\n    });\n  });\n\n  it(\"should be valid to use other names\", async () => {\n    await ruleTester.expect(`model Bar {}`).toBeValid();\n  });\n});\n```\n", "file_path": "../../core/docs\\extending-typespec\\linters.md", "link_to_file": "file://../../core/docs\\extending-typespec\\linters.md"}, {"file_content": "---\ntitle: Scaffolding templates\n---\n\n# Writting a scaffolding template\n\ntypespec provides scaffolding functionality via the `tsp init` command.\n\n```bash\ntsp init <templateUrl>\n```\n\n## Basic\n\nA scaffolding template is a `json` document that can be hosted locally or online.\nThe root of the document is a dictionary allowing multiple templates to be hosted at the same location.\n\nEach template needs at the minimum:\n\n- key: Key of the template\n- title: Human readable name of the template\n- description: Extended description of the template.\n\nExample:\n\n```json\n{\n  \"templateKey1\": {\n    \"title\": \"Template #1\",\n    \"description\": \"Create a project representing #1\"\n  },\n  \"templateKey2\": {\n    \"title\": \"Template #2\",\n    \"description\": \"Create a project representing #2\"\n  }\n}\n```\n\n## Adding libraries\n\nYou can add a list of typespec libraries to include. This will automatically add those libraries to the `package.json` and imported in `main.tsp`.\n\n```json\n{\n  \"rest\": {\n    \"title\": \"Rest API\",\n    \"description\": \"Create a new project representing a REST API\",\n    \"libraries\": [\"@typespec/rest\", \"@typespec/openapi3\"]\n  }\n}\n```\n\n## Adding new files\n\nAdditional files.typespec or other types) can be generated by the initializer. The template takes a list of the files to copy and interpolate values.\nEach file need the following properties:\n\n- `path`: Absolute or relative path(to the template file) to the file\n- `destination`: Relative path of the file relative to the project root.\n\n```json\n{\n  \"rest\": {\n    \"title\": \"Rest API\",\n    \"description\": \"Create a new project representing a REST API\",\n    \"files\": [{ \"path\": \"./models.tsp\", \"destination\": \"./models.tsp\" }]\n  }\n}\n```\n\nIn models.tsp\n\n```typespec\nmodel {{parameters.ModelName}} {\n\n}\n```\n\n### Interpolating values\n\nThe template can interpolate values in the files. The values available are anything available in the template configuration referenced as it is.\nExamples:\n\n- Reference a parameter `{{parameters.ModelName}}`\n- Reference a the template title `{{title}}`\n\nAdditionally the following values and functions are available:\n\n| Name                                  | Description                                                     |\n| ------------------------------------- | --------------------------------------------------------------- |\n| `directory`                           | Directory full path where the project should be initialized.    |\n| `folderName`                          | Folder name where the project should be initialized.            |\n| `name`                                | Name of the project.                                            |\n| `libraries`                           | List of libraries to include                                    |\n| `templateUri`                         | Path where this template was loaded from.                       |\n| Functions                             |                                                                 |\n| `toLowerCase(value: string)`          | Convert string to lower case                                    |\n| `normalizePackageName(value: string)` | Normalize package name. It replaces `.` with`-` and toLowerCase |\n\n## Demanding additional input from the user\n\nWhen generating files there might be a need for additional inputs to be retrieved from the user. For example the model name.\nThe template takes in a map of inputs that will get prompted to the user during initialization.\n\n```json\n{\n  \"rest\": {\n    \"title\": \"Rest API\",\n    \"description\": \"Create a new project representing a REST API\",\n    \"inputs\": {\n      \"modelName\": {\n        \"type\": \"text\",\n        \"description\": \"Name of the first model\"\n      }\n    }\n  }\n}\n```\n\nTypes of input supported:\n\n- `text`: Ask for a raw text value.\n", "file_path": "../../core/docs\\extending-typespec\\writing-scaffolding-template.md", "link_to_file": "file://../../core/docs\\extending-typespec\\writing-scaffolding-template.md"}, {"file_content": "---\ntitle: Getting Started with TypeSpec For Http\n---\n\nLet's create a REST API definition with TypeSpec. TypeSpec has an official HTTP API \"binding\" called `@typespec/http`. It's a set of TypeSpec declarations and decorators that describe HTTP APIs and can be used by code generators to generate OpenAPI descriptions, implementation code, and the like.\nBuilt on top of the http library there is the rest library `@typespec/rest` which provide some REST concept like resources.\n\nTypeSpec also has an official OpenAPI emitter called `@typespec/openapi3` that consumes the HTTP API bindings and emits standard [OpenAPI 3.0](https://spec.openapis.org/oas/v3.0.3) descriptions. This can then be fed in to any OpenAPI code generation pipeline.\n\nReferences:\n\n- [Http library](../standard-library/http/reference)\n- [Rest library](../standard-library/rest/reference)\n- [OpenAPI 3 emitter](../standard-library/openapi3/reference)\n\n## Setup\n\n:::note\nMake sure to have installed the [editor extension](../introduction/installation.md#install-the-vs-and-vscode-extensions) to get syntax highlighting and intellisense.\n:::\n\n1. Make a new folder somewhere\n2. Run `npx --package=@typespec/compiler tsp init` and select the `Generic Rest API` template\n3. Run `npm install` to install dependencies\n4. Run `npx tsp compile .` to compile the initial file\n   You can either run `npx tsp compile . --watch` to automatically compile change on save or keep running the command manually after that.\n\nResulting file structure:\n\n```\nmain.tsp\ntspconfig.yaml\npackage.json\nnode_modules/\ntsp-output/\n  @typespec/\n    openapi3/\n      openapi.yaml\n```\n\n## Service definition and metadata\n\nA definition for a service is the namespace that contains all the operations for the service and carries top-level metadata like service name and version. TypeSpec offers the following decorators for providing this metadata, and all are optional.\n\n- `@service` - Mark a namespace as a service namespace. Takes in the following options:\n  - `title`: Name of the service\n  - `version`: Version of the service\n- `@server` - (In `TypeSpec.Http`) the host of the service. Can accept parameters.\n\nHere's an example that uses these to define a Pet Store service:\n\n```typespec\nusing TypeSpec.Http;\nusing TypeSpec.Rest;\n\n/**\n * This is a sample server Petstore server.\n */\n@service({\n  title: \"Pet Store Service\",\n  version: \"2021-03-25\",\n})\n@server(\"https://example.com\", \"Single server endpoint\")\nnamespace PetStore;\n```\n\nThe `server` keyword can take a third parameter with parameters as necessary:\n\n```typespec\n@server(\"https://{region}.foo.com\", \"Regional endpoint\", {\n  /** Region name */\n  region?: string = \"westus\",\n})\n```\n\n## Resources & routes\n\nResource is a general term for anything that can be identified by a URL and manipulated by HTTP methods.\nIn TypeSpec, the operations for a resource are typically grouped in a namespace. You declare such a namespace by adding the `@route` decorator to provide the path to that resource:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n\n}\n```\n\nLets add a pet model in the namespace\n\n```tsp\nmodel Pet {\n  @minLength(100)\n  name: string;\n\n  @minValue(0)\n  @maxValue(100)\n  age: int32;\n\n  kind: \"dog\" | \"cat\" | \"fish\";\n}\n```\n\nTo define an operation on this resource, you need to provide the HTTP verb for the route using the `@get`, `@head` `@post`, `@put`, `@patch`, or `@delete` decorators. If an HTTP method decorator is not specified then the default is post if there is a body and get otherwise. Lets add an operation to our `Pets` resource:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(): Pet[];\n\n  // or you could also use\n  @get op listPets(): Pet[];\n}\n```\n\n### Automatic route generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate routes from operation parameters by applying the `@autoRoute` decorator to an operation or interface containing operations.\n\nFor this to work, an operation's path parameters (those marked with `@path`) must also be marked with\nthe `@segment` decorator to define the preceding path segment.\n\nThis is especially useful when reusing common parameter sets defined as model types.\n\nFor example:\n\n```typespec\nmodel CommonParameters {\n  @path\n  @segment(\"tenants\")\n  tenantId: string;\n\n  @path\n  @segment(\"users\")\n  userName: string;\n}\n\nmodel User {\n  name: string;\n}\n@error\nmodel Error {\n  message: string;\n}\n\n@autoRoute\ninterface UserOperations {\n  @get\n  getUser(...CommonParameters): User | Error;\n\n  @put\n  updateUser(...CommonParameters, user: User): User | Error;\n}\n```\n\nThis will result in the following route for both operations\n\n```text\n/tenants/{tenantId}/users/{userName}\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` decorators respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip?: int32, @query top?: int32): Pet[];\n  op read(@path petId: int32): Pet;\n}\n```\n\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\n\n```typespec\n@route(\"/pets/{petId}/toys\")\nnamespace PetToys {\n  model Toy {\n    name: string;\n  }\n  op list(@path petId: int32): Toy[];\n}\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): Pet[];\n  op read(@path petId: int32, @header ifMatch?: string): {\n    @header eTag: string;\n    @body pet: Pet;\n  };\n  @post\n  op create(@body pet: Pet): {};\n}\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): {\n    @body pets: Pet[];\n  };\n  op read(@path petId: int32): {\n    @body pet: Pet;\n  };\n  @post\n  op create(@body pet: Pet): {};\n}\n```\n\nNote that in the absence of explicit `@body`:\n\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\n2. The set of properties of the return model that are not marked @header, @query, or @path form the response body.\n3. If the return type is not a model, then it defines the response body.\n\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  @post\n  op create(...Pet): {};\n}\n```\n\n## Status codes\n\nUse the `@statusCode` decorator on a property to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): {\n    @statusCode statusCode: 200;\n    @body pets: Pet[];\n  };\n  op read(@path petId: int32, @header ifMatch?: string): {\n    @statusCode statusCode: 200;\n    @header eTag: string;\n    @body pet: Pet;\n  } | {\n    @statusCode statusCode: 404;\n  };\n  op create(@body pet: Pet): {\n    @statusCode statusCode: 204;\n  };\n}\n```\n", "file_path": "../../core/docs\\getting-started\\getting-started-http.md", "link_to_file": "file://../../core/docs\\getting-started\\getting-started-http.md"}, {"file_content": "---\nid: getting-started\ntitle: Getting Started\n---\n\n# Getting Started with TypeSpec\n\n- [Get started with HTTP in TypeSpec](./getting-started-http.md)\n", "file_path": "../../core/docs\\getting-started\\getting-started.md", "link_to_file": "file://../../core/docs\\getting-started\\getting-started.md"}, {"file_content": "---\ntitle: TypeSpec For OpenAPI Developer\n---\n\n# TypeSpec for the OpenAPI developer\n\nThis guide is an introduction to TypeSpec using concepts that will be familiar to developers\nthat either build or use API definitions in OpenAPI v2 or v3.\n\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\nTypeSpec designs into OpenAPI.\n\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\n\nThe TypeSpec equivalent of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://microsoft.github.io/typespec/docs/language-basics/built-in-types).\n\n### type and format\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\n\n| OpenAPI `type`/`format`           | TypeSpec type    | Notes                                                                     |\n| --------------------------------- | ---------------- | ------------------------------------------------------------------------- |\n| `type: integer, format: int32`    | `int32`          |                                                                           |\n| `type: integer, format: int64`    | `int64`          |                                                                           |\n| `type: number, format: float`     | `float32`        |                                                                           |\n| `type: number, format: double`    | `float64`        |                                                                           |\n| `type: string`                    | `string`         |                                                                           |\n| `type: string, format: byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\n| `type: string, format: binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\n| `type: boolean`                   | `boolean`        |                                                                           |\n| `type: string, format: date`      | `plainDate`      |                                                                           |\n| `type: string, format: date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\n| `type: string, format: date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\n| `type: string, format: password`  | `@secret string` |                                                                           |\n\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\n\n```typespec\n  @doc(\"This property has no `type` defined.\")\n  noType?: unknown;\n```\n\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\nTypeSpec supports some of these directly.\n\n[Format Registry]: https://spec.openapis.org/registry/format\n\n| OpenAPI `type`/`format`         | TypeSpec type | Notes |\n| ------------------------------- | ------------- | ----- |\n| `type: number, format: decimal` | `decimal`     |       |\n| `type: integer, format: int8`   | `int8`        |       |\n| `type: integer, format: int16`  | `int16`       |       |\n| `type: integer, format: uint8`  | `uint8`       |       |\n| `type: string, format: uri`     | `url`         |       |\n\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\nthe format explicitly.\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used further restrict the values allowed for a data type.\nThese are actually borrowed into OpenAPI from JSON Schema.\n\nFor `type: integer` and `type: number` data types:\n\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\n| --------------------------- | ---------------------------- | ----- |\n| `minimum: value`            | `@minValue(value)` decorator |       |\n| `maximum: value`            | `@maxValue(value)` decorator |       |\n\nFor `type: string` data types:\n\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\n| --------------------------- | ----------------------------- | ----- |\n| `minLength: value`          | `@minLength(value)` decorator |       |\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\n\nFor `type: array` data types:\n\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\n| --------------------------- | ---------------------------- | ----- |\n| `minItems: value`           | `@minItems(value)` decorator |       |\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type. One is with the [TypeSpec `enum` statement](https://microsoft.github.io/typespec/docs/language-basics/enums), e.g.:\n\n<!-- To retain the quotes from the enum values -->\n<!-- prettier-ignore-start -->\n```typespec\nenum Color {\n  \"red\",\n  \"blue\",\n  \"green\",\n}\n```\n<!-- prettier-ignore-end -->\n\nAnother is to use the union operation to define the enum values inline, e.g.:\n\n```typespec\nsize?: \"small\" | \"medium\" | \"large\" | \"x-large\";\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\n\n```typespec\n  answer?: int32 = 42;\n  color?: string = \"purple\";\n```\n\nproduces\n\n```yaml\nanswer:\n  type: integer\n  format: int32\n  default: 42\ncolor:\n  type: string\n  default: purple\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\n\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\n\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\n\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\non the namespace(From `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized with the \"path\" for the operation.\n\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\n\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\n\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\n}\n```\n\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\nobtained by concatenating the routes.\n\n```typespec\n@route(\"/widgets\")\nnamespace Widgets {\n  // widgets operations\n\n  @route(\"/{id}/parts\")\n  namespace Parts {\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\n  }\n}\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\n\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\n\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\n\n```typespec\n@tag(\"Gadgets\")\n@route(\"/gadgets\")\nnamespace Gadgets {\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\n}\n```\n\nOther path item fields:\n\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\n| ------------------------ | ------------------ | ------------------------ |\n| `summary`                |                    | Not currently supported. |\n| `description`            |                    | Not currently supported. |\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\n\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\n\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\n\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                |\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------- |\n| `tags`                    | `@tag` decorator                           |                                                      |\n| `summary`                 | `@summary` decorator                       |                                                      |\n| `description`             | `@doc` decorator or doc comment            |                                                      |\n| `externalDocs`            | `@externalDocs` decorator                  |                                                      |\n| `operationId`             | operation name or `@operationId` decorator |                                                      |\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)            |\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3) |\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)            |\n| `callbacks`               |                                            | Not currently supported.                             |\n| `deprecated`              | `@deprecated` decorator                    |                                                      |\n| `security`                |                                            | Not currently supported.                             |\n| `servers`                 |                                            | Not currently supported.                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify the description for an operation. The value of the `@doc` decorator can be a multi-line string\nand can contain markdown formatting.\n\n```typespec\n@doc(\"\"\"\nGet status info for the service.\nThe status includes the current version of the service.\nThe status value may be one of:\n- `ok`: the service is operating normally\n- `degraded`: the service is operating in a degraded state\n- `down`: the service is not operating\n\"\"\")\n@tag(\"Status\")\n@route(\"/status\")\n@get\nop status(): string;\n```\n\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\nDoc comments may be spread across multiple lines and may contain markdown formatting.\n\n```typespec\n/**\n * Get health info for the service.\n * The health includes the current version of the service.\n * The health value may be one of:\n * - `ok`: the service is operating normally\n * - `degraded`: the service is operating in a degraded state\n * - `down`: the service is not operating\n */\n@tag(\"Health\")\n@route(\"/health\")\n@get\nop health(): string;\n```\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\nIf the operation is defined within a inner namespace or interface, then the operationId is\nprefixed with the name of the innermost namespace or interface name.\n\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\n\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\n\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\n\n<!-- prettier-ignore-start -->\n| OpenAPI `parameter` field | TypeSpec construct   | Notes                                 |\n| ------------------------- | -------------------- | ------------------------------------- |\n| `name`                    | parameter name       |                                       |\n| `in`                      | decorator            | `@query`, `@path`, `@header`, `@body` |\n| `description`             | `@doc` decorator     |                                       |\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\n| `allowEmptyValue`         |                      | Not currently supported.              |\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\n\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\n| `collectionFormat`           | `format` parameter on `@query` or `@header` |                               |\n\n#### Collection Formats\n\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\nYou can use the `format` field of the `@query` or `@header` decorator to specify the collection format.\n\n```typespec\n  @get read(\n    @path id: string,\n    @query({format: \"csv\"}) csv?: string[], // has collectionFormat: \"csv\"\n    @query({format: \"multi\"}) multi?: string[], // has collectionFormat: \"multi\"\n  ): Widget | Error;\n```\n\n### OpenAPI v3\n\nThe following fields of a parameter object are specific to OpenAPI v3:\n\n| OpenAPI v3 `parameter` field | TypeSpec construct                          | Notes                               |\n| ---------------------------- | ------------------------------------------- | ----------------------------------- |\n| `style`                      | `format` parameter on `@query` or `@header` |                                     |\n| `explode`                    | `format` parameter on `@query` or `@header` |                                     |\n| `schema`                     | parameter schema                            | see [Schema Object](#schema-object) |\n| `deprecated`                 |                                             | Not currently supported.            |\n| `example`                    |                                             | Not currently supported.            |\n| `examples`                   |                                             | Not currently supported.            |\n| `content`                    |                                             | Not currently supported.            |\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\n\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\n\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\n\n<!-- prettier-ignore-start -->\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\n| --------------------------- | ----------------------- | ------------ |\n| `description`               | `@doc` decorator        |              |\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\n| `content`                   | `@body` parameter type  |              |\n<!-- prettier-ignore-end -->\n\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\nthen `content` will have one entry for each value.\n\n```typespec\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\n@post op analyze(\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\n  @body image: bytes,\n): string | Error;\n```\n\nTo get multiple `content` entries with different schemas (say one structured and one binary),\nyou need to define two separate operations that share the same path and method.\nYou do with with the `@sharedRoute` decorator.\n\n```typespec\n@route(\":process\")\nnamespace Process {\n  @sharedRoute\n  @post\n  op process(...Widget): Widget | Error;\n\n  model CsvBody {\n    @header contentType: \"text/csv\";\n    @body _: string;\n  }\n  @sharedRoute\n  @post\n  op process2(...CsvBody): Widget | Error;\n}\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\nThe responses object maps a HTTP response code to the expected response.\n\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\n\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\n\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\n\nTo get the `default` response, specify the `@error` decorator on the return type model.\n\n```typespec\n@get op read(@path id: string): Widget; // has \"200\" response\n@delete op delete(@path id: string): void; // has \"204\" response\n// has \"200\" and \"201\" response\n@put op create(@body widget: Widget): {\n  @statusCode _: \"200\" | \"201\";\n  @body body: Widget;\n};\n// has \"200\" and \"default\" response\n@post op update(@body widget: Widget): Widget | Error;\n```\n\nThe TypeSpec.Http package also defines several standard response types.\n\n| HTTP Status Code | TypeSpec construct     |\n| ---------------- | ---------------------- |\n| `200`            | `OkResponse`           |\n| `201`            | `CreatedResponse`      |\n| `202`            | `AcceptedResponse`     |\n| `204`            | `NoContentResponse`    |\n| `301`            | `MovedResponse`        |\n| `304`            | `NotModifiedResponse`  |\n| `401`            | `UnauthorizedResponse` |\n| `404`            | `NotFoundResponse`     |\n| `409`            | `ConflictResponse`     |\n\nYou can intersect these standard response types with your own response types.\n\n```typespec\n// has \"200\", '409', and \"default\" responses\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\n```\n\n### Response Object\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\nelements common to both.\n\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\n\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\n\n| OpenAPI `response` field | TypeSpec construct                                 | Notes                                              |\n| ------------------------ | -------------------------------------------------- | -------------------------------------------------- |\n| `description`            | `@doc` decorator                                   |                                                    |\n| `headers`                | fields in the return type with `@header` decorator | required or optional based on optionality of field |\n| `schema` (OAS2)          | return type or type of `@body`` property           |                                                    |\n| `content` (OAS3)         | return type or type of `@body`` property           |                                                    |\n| `examples` (OAS3)        |                                                    | Not currently supported.                           |\n| `links` (OAS3)           |                                                    | Not currently supported.                           |\n\n```typespec\n@get op read(@path id: string): {\n  @doc(\"the widget\")\n  @body\n  widget: Widget;\n\n  @header xRateLimitRemaining: number;\n  @header xRateLimitReset: number;\n};\n```\n\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\nthen `content` will have one entry for each value.\n\nTo get multiple `content` entries with different schemas, use a union type.\n\n```typespec\n@tag(\"Response Content\")\n@route(\"/response-content\")\nnamespace ResponseContent {\n  @get op read(@path id: string): Widget | {\n    @header contentType: \"text/html\";\n    @body _: string;\n  } | {\n    @header contentType: \"image/jpeg\";\n    @body _: bytes;\n  };\n}\n```\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://microsoft.github.io/typespec/docs/language-basics/models/).\nModels have any number of members and can extend and be composed with other models.\n\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\n\nTypeSpec supports the [\"spread\" operator](https://microsoft.github.io/typespec/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\n\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\n\n```typespec\nmodel Legs {\n  @doc(\"number of legs\") legs: int32;\n}\n\nmodel Dog {\n  name: string;\n  ...Legs;\n}\n\nmodel Cat {\n  name: string;\n  ...Legs;\n}\n\nmodel Snake {\n  name: string;\n  // snakes have no legs\n}\n```\n\n### additionalProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\n\n```typespec\n  bar: Record<unknown>;\n```\n\nis produced as\n\n```yaml\nbar:\n  type: object\n  additionalProperties: {}\n```\n\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\n\n```typespec\nmodel Bar extends Record<unknown> {\n  bar?: string;\n}\n```\n\nproduces\n\n```yaml\nBar:\n  type: object\n  properties:\n    bar:\n      type: string\n  additionalProperties: {}\n```\n\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\n\n```typespec\n  bar: Record<string>;\n```\n\nresults in\n\n```yaml\nbar:\n  type: object\n  additionalProperties:\n    type: string\n```\n\n### allOf and polymorphism using allOf\n\nTypeSpec also supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\n\n```typespec\nmodel Pet {\n  name: string;\n}\n\nmodel Cat extends Pet {\n  meow: int32;\n}\n\nmodel Dog extends Pet {\n  bark: string;\n}\n```\n\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\n\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\n\nFor example:\n\n```typespec\n@discriminator(\"kind\")\nmodel Pet {\n  name: string;\n  weight?: float32;\n}\nmodel Cat extends Pet {\n  kind: \"cat\";\n  meow?: int32;\n}\nmodel Dog extends Pet {\n  kind: \"dog\";\n  bark?: string;\n}\n```\n\ngenerates:\n\n```typespec\n    Cat:\n      type: object\n      properties:\n        kind:\n          type: string\n          enum:\n            - cat\n        meow:\n          type: integer\n          format: int32\n      required:\n        - kind\n      allOf:\n        - $ref: '#/components/schemas/Pet'\n    Dog:\n      type: object\n      properties:\n        kind:\n          type: string\n          enum:\n            - dog\n        bark:\n          type: string\n      required:\n        - kind\n      allOf:\n        - $ref: '#/components/schemas/Pet'\n    Pet:\n      type: object\n      properties:\n        kind:\n          type: string\n          description: Discriminator property for Pet.\n        name:\n          type: string\n        weight:\n          type: number\n          format: float\n      discriminator:\n        propertyName: kind\n        mapping:\n          cat: '#/components/schemas/Cat'\n          dog: '#/components/schemas/Dog'\n      required:\n        - name\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\nThese can be represented in TypeSpec with a union type.\n\n```typespec\nunion Pet {\n  cat: Cat,\n  dog: Dog,\n}\n\nmodel Cat {\n  meow?: int32;\n}\n\nmodel Dog {\n  bark?: string;\n}\n```\n\ngenerates a Pet schema with `anyOf`.\n\n```yml\nPet:\n  anyOf:\n    - $ref: \"#/components/schemas/Cat\"\n    - $ref: \"#/components/schemas/Dog\"\n```\n\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\n\n```typespec\nimport \"@typespec/openapi3\";\nusing OpenAPI;\n\n@oneOf\nunion Pet {\n  cat: Cat,\n  dog: Dog,\n}\n```\n\nproduces:\n\n```yml\nPet:\n  oneOf:\n    - $ref: \"#/components/schemas/Cat\"\n    - $ref: \"#/components/schemas/Dog\"\n```\n\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\nwith a string literal value to each of the child schemas.\n\n```typespec\n@discriminator(\"kind\")\n@oneOf\nunion Pet {\n  cat: Cat,\n  dog: Dog,\n}\nmodel Cat {\n  kind: \"cat\";\n  meow?: int32;\n}\nmodel Dog {\n  kind: \"dog\";\n  bark?: string;\n}\n```\n\nresults in the following schema for Pet:\n\n```yml\nPet:\n  oneOf:\n    - $ref: \"#/components/schemas/Cat\"\n    - $ref: \"#/components/schemas/Dog\"\n  discriminator:\n    propertyName: kind\n    mapping:\n      cat: \"#/components/schemas/Cat\"\n      dog: \"#/components/schemas/Dog\"\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\n\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\n\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\n\n```typespec\nmodel PetId {\n  @path petId: int32;\n}\n\nnamespace Pets {\n  op read(...PetId): Pet | Error;\n}\n```\n\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\n\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\n\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\n\n| OpenAPI `info` field | TypeSpec decorator     | Notes                       |\n| -------------------- | ---------------------- | --------------------------- |\n| `title`              | `@service({title: }`   | TypeSpec built-in decorator |\n| `version`            | `@service({version: }` | TypeSpec built-in decorator |\n| `description`        | `@doc`                 | TypeSpec built-in decorator |\n| `license`            | `@info`                |                             |\n| `contact`            | `@info`                |                             |\n\n[typespec-service-metadata]: https://microsoft.github.io/typespec/docs/standard-library/http/#service-definition-and-metadata\n\n```typespec\n@doc(\"The Contoso Widget Service provides access to the Contoso Widget API.\")\n@service({\n  title: \"Widget Service\",\n  version: \"1.0.0\",\n})\n@info({\n  contact: {\n    name: \"API Support\",\n    email: \"contact@contoso.com\",\n  },\n  license: {\n    name: \"Apache 2.0\",\n    url: \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n  },\n})\nnamespace DemoService;\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\nwhen not overridden by a `consumes` or `produces` on an individual operation.\n\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse `@useAuth` decorator from the `@typespec/rest\" library\n\n```typespec\nusing TypeSpec.Http;\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\nnamespace MyService;\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\nFor example:\n\n```typespec\nnamespace Pets {\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\n}\n```\n", "file_path": "../../core/docs\\getting-started\\typespec-for-openapi-dev.md", "link_to_file": "file://../../core/docs\\getting-started\\typespec-for-openapi-dev.md"}, {"file_content": "---\nid: faq\ntitle: FAQ\n---\n\n# Frequently Asked Questions\n\n## `Cannot find package 'x' imported from 'y'` but not using this package\n\nThis is most likely due to package y having a `peerDependency` on package `x` and package x wasn't installed.\nVerify the version of npm you are using. Before version 7 peerDependencies would not get installed automatically and you would have to manually install them.\n\n### Solutions\n\n- Update npm `npm install -g npm`\n- If you cannot update npm, then adding the dependencies to your project dependency should resolve the issue `npm install x`\n", "file_path": "../../core/docs\\introduction\\faq.md", "link_to_file": "file://../../core/docs\\introduction\\faq.md"}, {"file_content": "---\nid: formatter\ntitle: Formatter\n---\n\n# Formatter\n\nTypeSpec comes with a built-in formatter. The formatter can be used in different ways:\n\n- [Via the cli](#via-the-cli)\n- Via the vscode/vs extension\n- As a prettier plugin\n\n## Via the cli\n\nFormat all typespec files:\n\n```bash\ntsp format \"**/*.tsp\"\n```\n\nValidate that the files are formatted but don't format them. Useful for enforcing in CI.\n\n```bash\ntsp format --check \"**/*.tsp\"\n```\n\n## Via the VSCode or VS extension\n\nWhen using the VS Code or Visual Studio extensions, the tsp formatter is automatically available.\n\nUsing the keyboard shortcut for formatting the document (`alt+shift+F` by default) when inside a TypeSpec file will format the document.\n\n## Via prettier\n\nUnderneath the tsp formatter is a prettier plugin. If you already have a prettier configuration for formatting other languages it can be convenient to just have typespec plug in into this existing pipeline.\n\nIn your prettier config file, add:\n\n```yaml\nplugins:\n  - \"./node_modules/@typespec/prettier-plugin-typespec\"\noverrides: [{ \"files\": \"*.tsp\", \"options\": { \"parser\": \"typespec\" } }]\n```\n", "file_path": "../../core/docs\\introduction\\formatter.md", "link_to_file": "file://../../core/docs\\introduction\\formatter.md"}, {"file_content": "---\nid: installation\ntitle: Installation\n---\n\n# Installation\n\n## Requirements\n\nInstall [Node.js 16 LTS](https://nodejs.org/en/download/) and ensure you are able to run the `npm` command in a command prompt:\n\n```bash\nnpm --version\n```\n\nIt is recommended to have npm 7+. To update npm run `npm install -g npm`\n\n## Install tsp compiler\n\nFirst step is to install the tsp compiler/cli\n\n```bash\nnpm install -g @typespec/compiler\n```\n\n## Install the VS and VSCode extensions\n\nTypeSpec provides extension for the following editors:\n\n- [Visual Studio Code](./editor/vscode.md)\n- [Visual Studio](./editor/vscode.md)\n\n## Create first TypeSpec Project\n\nTo get your first TypeSpec project started run in a fresh directory\n\n```bash\ntsp init\n```\n\nThis will prompt you with a few question, pick the `Generic Rest API` template, your project name, and select the `@typespec/openapi3` library.\n\nNext, you can install the dependencies\n\n```bash\ntsp install\n```\n\nYou should now have a basic TypeSpec project setup with a structure looking like\n\n```bash\npackage.json      # Package manifest defining your typespec project as a node package.\ntspconfig.yaml # TypeSpec project configuration letting you configure emitters, emitter options, compiler options, etc.\nmain.tsp         # TypeSpec entrypoint\n```\n\n## Compile project\n\n```bash\ntsp compile .\n```\n", "file_path": "../../core/docs\\introduction\\installation.md", "link_to_file": "file://../../core/docs\\introduction\\installation.md"}, {"file_content": "---\nid: introduction\ntitle: Introduction\nslug: /\n---\n\n# Introduction to TypeSpec\n\nTypeSpec is a language for describing cloud service APIs and generating other API description languages, client and service code, documentation, and other assets. TypeSpec provides highly extensible core language primitives that can describe API shapes common among REST, GraphQL, gRPC, and other protocols.\n\n## Try TypeSpec\n\nYou can try TypeSpec on the web without installing anything.\n\n- [TypeSpec playground](https://cadlplayground.z22.web.core.windows.net)\n- [TypeSpec playground for Azure services](https://azure.github.io/typespec-azure/playground)\n", "file_path": "../../core/docs\\introduction\\introduction.md", "link_to_file": "file://../../core/docs\\introduction\\introduction.md"}, {"file_content": "---\nid: releases\ntitle: Releases\n---\n\n# Releases\n\n## Package versioning strategy\n\nTypeSpec is not stable yet, all packages are released with `0.` major version. Each minor version might have some breaking changes to the typespec language, library API or both. Those are documented [here](../release-notes).\n\nEvery change to the `main` branch is automatically published under the npm `@next` tag.\n\n## Current packages\n\n| Name                                               | Changelog                        | Latest                                                                                                                                   | Next                                                                      |\n| -------------------------------------------------- | -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |\n| Core functionality                                 |                                  |                                                                                                                                          |                                                                           |\n| [@typespec/compiler][compiler_src]                 | [Changelog][compiler_chg]        | [![](https://img.shields.io/npm/v/@typespec/compiler)](https://www.npmjs.com/package/@typespec/compiler)                                 | ![](https://img.shields.io/npm/v/@typespec/compiler/next)                 |\n| TypeSpec Libraries                                 |                                  |                                                                                                                                          |                                                                           |\n| [@typespec/rest][rest_src]                         | [Changelog][rest_chg]            | [![](https://img.shields.io/npm/v/@typespec/rest)](https://www.npmjs.com/package/@typespec/rest)                                         | ![](https://img.shields.io/npm/v/@typespec/rest/next)                     |\n| [@typespec/openapi][openapi_src]                   | [Changelog][openapi_chg]         | [![](https://img.shields.io/npm/v/@typespec/openapi)](https://www.npmjs.com/package/@typespec/openapi)                                   | ![](https://img.shields.io/npm/v/@typespec/openapi/next)                  |\n| [@typespec/openapi3][openapi3_src]                 | [Changelog][openapi3_chg]        | [![](https://img.shields.io/npm/v/@typespec/openapi3)](https://www.npmjs.com/package/@typespec/openapi3)                                 | ![](https://img.shields.io/npm/v/@typespec/openapi3/next)                 |\n| [@typespec/versioning][versioning_src]             | [Changelog][versioning_chg]      | [![](https://img.shields.io/npm/v/@typespec/versioning)](https://www.npmjs.com/package/@typespec/versioning)                             | ![](https://img.shields.io/npm/v/@typespec/versioning/next)               |\n| TypeSpec Tools                                     |                                  |                                                                                                                                          |                                                                           |\n| [@typespec/prettier-plugin-typespec][prettier_src] | [Changelog][prettier_chg]        | [![](https://img.shields.io/npm/v/@typespec/prettier-plugin-typespec)](https://www.npmjs.com/package/@typespec/prettier-plugin-typespec) | ![](https://img.shields.io/npm/v/@typespec/prettier-plugin-typespec/next) |\n| [typespec-vs][typespec-vs_src]                     | [Changelog][typespec-vs_chg]     | [![](https://img.shields.io/npm/v/typespec-vs)](https://www.npmjs.com/package/typespec-vs)                                               | ![](https://img.shields.io/npm/v/typespec-vs/next)                        |\n| [typespec-vscode][typespec-vscode_src]             | [Changelog][typespec-vscode_chg] | [![](https://img.shields.io/npm/v/typespec-vscode)](https://www.npmjs.com/package/typespec-vscode)                                       | ![](https://img.shields.io/npm/v/typespec-vscode/next)                    |\n| [tmlanguage-generator][tmlanguage_src]             | [Changelog][tmlanguage_chg]      | [![](https://img.shields.io/npm/v/tmlanguage-generator)](https://www.npmjs.com/package/tmlanguage-generator)                             | ![](https://img.shields.io/npm/v/tmlanguage-generator/next)               |\n\n[compiler_src]: https://github.com/microsoft/typespec/blob/main/packages/compiler\n[compiler_chg]: https://github.com/microsoft/typespec/blob/main/packages/compiler/CHANGELOG.md\n[rest_src]: https://github.com/microsoft/typespec/blob/main/packages/rest\n[rest_chg]: https://github.com/microsoft/typespec/blob/main/packages/rest/CHANGELOG.md\n[openapi_src]: https://github.com/microsoft/typespec/blob/main/packages/openapi\n[openapi_chg]: https://github.com/microsoft/typespec/blob/main/packages/openapi/CHANGELOG.md\n[openapi3_src]: https://github.com/microsoft/typespec/blob/main/packages/openapi3\n[openapi3_chg]: https://github.com/microsoft/typespec/blob/main/packages/openapi3/CHANGELOG.md\n[versioning_src]: https://github.com/microsoft/typespec/blob/main/packages/versioning\n[versioning_chg]: https://github.com/microsoft/typespec/blob/main/packages/versioning/CHANGELOG.md\n[prettier_src]: https://github.com/microsoft/typespec/blob/main/packages/prettier-plugin-typespec\n[prettier_chg]: https://github.com/microsoft/typespec/blob/main/packages/prettier-plugin-typespec/CHANGELOG.md\n[typespec-vs_src]: https://github.com/microsoft/typespec/blob/main/packages/typespec-vs\n[typespec-vs_chg]: https://github.com/microsoft/typespec/blob/main/packages/typespec-vs/CHANGELOG.md\n[typespec-vscode_src]: https://github.com/microsoft/typespec/blob/main/packages/typespec-vscode\n[typespec-vscode_chg]: https://github.com/microsoft/typespec/blob/main/packages/typespec-vscode/CHANGELOG.md\n[tmlanguage_src]: https://github.com/microsoft/typespec/blob/main/packages/tmlanguage-generator\n[tmlanguage_chg]: https://github.com/microsoft/typespec/blob/main/packages/tmlanguage-generator/CHANGELOG.md\n\n## Release cadence\n\nWe release changes from all packages the first week of every month.\n\nYou can look at the millestones https://github.com/microsoft/typespec/milestones to see upcoming changes. Millestones are named after the target release month (i.e `[2022] October` is the sprint running in september targeting a release in the first week of October.)\n\n## Breaking changes migration guides\n\nRelease notes describing the breaking changes and how to migrate can be found in this folder:\n\n[https://github.com/microsoft/typespec/tree/main/docs/release-notes](https://github.com/microsoft/typespec/tree/main/docs/release-notes)\n", "file_path": "../../core/docs\\introduction\\releases.md", "link_to_file": "file://../../core/docs\\introduction\\releases.md"}, {"file_content": "---\ntitle: Reproducibility\n---\n\nA key point to service definition is the ability to reliably reproduce the exact same output over time. In cases like:\n\n1. A dependency or dependency of dependency was updated with an unintended breaking change\n2. Changes to a new version of a service shouldn't affect the older versions\n3. A change to the TypeSpec spec\n\nThis can be mitigated with a few steps:\n\n## 1. Defend against dependency changes\n\n_Note: This section applies if using `tsp install` or `npm install` to install dependencies. However other package managers (`yarn`, `pnpm`, etc.) have their own similar lock mechanisms._\n\nWhen using `tsp install` or `npm install` a `package-lock.json` will be installed. This file SHOULD be committed to source control. It will ensure that later calls to `tsp install` or `npm install` will use the exact versions resolved in the lock files unless the `package.json` was updated or a command like `npm update` was run.\n\nThe command `npm ci` can also be used in the CI to ensure that the `package.json` and `package-lock.json` are in sync.\n\n## 2. Work with multiple versions of a service\n\nTypeSpec provides a library `@typespec/versioning` that can be used to describe changes to a service or library over time. Using this will ensure that a service can evolve while keeping track of the changes and allowing emitters to see the service representation at different versions.\n\n[See versioning docs](../standard-library/versioning/reference/index.mdx)\n\n## 3. Change to the TypeSpec spec\n\nIf you don't directly control the spec, you might still want to make sure you remember which exact definition was used.\nUsing version control and pinning to a specific commit SHA will ensure that the spec will remain exactly as it was.\n\n## Summary\n\n1. Use `package-lock.json`\n2. Use [versioning library](../standard-library/versioning/reference/index.mdx)\n3. Keep track of commit IDs\n", "file_path": "../../core/docs\\introduction\\reproducibility.md", "link_to_file": "file://../../core/docs\\introduction\\reproducibility.md"}, {"file_content": "---\ntitle: Style guide\n---\n\n# TypeSpec Language Style Guide\n\nThis is a guide providing a recommended set of naming convention to use when writing a TypeSpec spec.\n\n:::info\nThe guidelines in this article are used in TypeSpec Core libraries. You can use them, or adapt them to your needs. The primary objectives are consistency and readability within your project, team, organization, or company source code.\n:::\n\n## Naming convention\n\n| Type             | Naming                                       | Example                                          |\n| ---------------- | -------------------------------------------- | ------------------------------------------------ |\n| scalar           | camelCase                                    | `scalar uuid extends string;`                    |\n| model            | PascalCase                                   | `model Pet {}`                                   |\n| model property   | camelCase                                    | `model Pet {furColor: string}`                   |\n| enum             | PascalCase                                   | `enum Direction {}`                              |\n| enum member      | camelCase                                    | `enum Direction {up, down}`                      |\n| namespace        | PascalCase                                   | `namespace Org.PetStore`                         |\n| interface        | PascalCase                                   | `interface Stores {}`                            |\n| operation        | camelCase                                    | `op listPets(): Pet[];`                          |\n| operation params | camelCase                                    | `op getPet(petId: string): Pet;`                 |\n| unions           | PascalCase                                   | `union Pet {cat: Cat, dog: Dog}`                 |\n| unions variants  | camelCase                                    | `union Pet {cat: Cat, dog: Dog}`                 |\n| alias            | camelCase or PascalCase depending on context | `alias myString = string` or `alias MyPet = Pet` |\n| decorators       | camelCase                                    | `@format`, `@resourceCollection`                 |\n| functions        | camelCase                                    | `addedAfter`                                     |\n| file name        | kebab-case                                   | `my-lib.tsp`                                     |\n\n## Layout convention\n\nTypeSpec has a built-in formatter. See [formatter section](./formatter.md) for more information on how to use it.\n\n- Use 2 space indenting\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nmodel Pet {\n    name: string;\n}\n\n// good\nmodel Pet {\n  name: string;\n}\n```\n\n- Place a space before an opening curly brace\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nmodel Pet{\n  name: string;\n}\n\n// good\nmodel Pet {\n  name: string;\n}\n```\n\n- Block opening curly brace `{` should be on the same line\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nmodel Pet \n{\n  name: string;\n}\n\n// good\nmodel Pet {\n  name: string;\n}\n```\n\n- Add a newline after blocks\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nmodel Pet {\n  name: string;\n}\nmodel Cat extends Pet {}\n\n// good\nmodel Pet {\n  name: string;\n}\n\nmodel Cat extends Pet {}\n```\n\n- Place no space between an operation/decorator/function name and the parameter list\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nop list (filter: string): Pet[];\n\n// bad\n@doc (\"This is a pet\")\n\n// good\nop list(filter: string): Pet[];\n\n// good\n@doc(\"This is a pet\")\n```\n\n- Do not add spaces inside parentheses\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nop list( filter: string ): Pet[];\n\n// good\nop list(filter: string): Pet[];\n\n```\n\n- Add spaces inside curly braces.\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nalias foo = {type: \"cat\"};\n\n// good\nalias foo = { type: \"cat\" };\n```\n\n- Do not add space inside square brackets\n\n<!-- prettier-ignore -->\n```typespec\n// bad\nalias foo = [ 1, 2, 3 ];\n\n// good\nalias foo = [1, 2, 3];\n```\n\n- Start all comments with a space\n\n<!-- prettier-ignore -->\n```typespec\n//bad\n\n// good\n```\n\n- Avoid trailing spaces at the end of lines.\n\n### Model layout\n\n- Properties should hug each other unless it has decorators or comments\n\n<!-- prettier-ignore -->\n```tsp\n// bad\nmodel Foo {\n  one: string;\n\n  two: string;\n\n  three: string;\n}\n\n// good\nmodel Foo {\n  one: string;\n  two: string;\n  three: string;\n}\n```\n\n- Wrap properties in new lines if it has leading comments or decorators\n\n<!-- prettier-ignore -->\n```tsp\n// bad\nmodel Foo {\n  one: string;\n  @doc(\"Foo\")\n  two: string;\n  // line comment\n  three: string;\n  /**\n   *  Block comment\n   */\n  four: string;\n  five: string;\n}\n\n// good\nmodel Foo {\n  one: string;\n\n  @doc(\"Foo\")\n  two: string;\n\n  // line comment\n  three: string;\n\n  /**\n   *  Block comment\n   */\n  four: string;\n  \n  five: string;\n}\n```\n", "file_path": "../../core/docs\\introduction\\style-guide.md", "link_to_file": "file://../../core/docs\\introduction\\style-guide.md"}, {"file_content": "---\nid: usage\ntitle: Usage\n---\n\n# Usage\n\nSee full usage documentation by typing `tsp --help`:\n\n```bash\n>tsp --help\nTypeSpec compiler v0.36.1\n\ntsp <command>\n\nCommands:\n  tsp compile <path>       Compile TypeSpec source.\n  tsp code                 Manage VS Code Extension.\n  tsp vs                   Manage Visual Studio Extension.\n  tsp format <include...>  Format given list of TypeSpec files.\n  tsp init [templatesUrl]  Create a new TypeSpec project.\n  tsp install              Install typespec dependencies\n  tsp info                 Show information about current TypeSpec compiler.\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --debug    Output debug log messages.               [boolean] [default: false]\n  --pretty   Enable color and formatting in TypeSpec's output to make compiler error\n             s easier to read.                         [boolean] [default: true]\n  --version  Show version number                                       [boolean]\n```\n", "file_path": "../../core/docs\\introduction\\usage.md", "link_to_file": "file://../../core/docs\\introduction\\usage.md"}, {"file_content": "---\ntitle: Configuration\n---\n\n# Compiler and Libraries configurations\n\nTypeSpec compiler and libraries can be configured either via a [configuration file](#configuration-file) or [command line flags](#command-line-flags).\n\n## Configuration file\n\nTypeSpec configuration can be provided via the `tspconfig.yaml` configuration file.\n\n### Discovery\n\nTypeSpec compiler will look for the closest `tspconfig.yaml` file located in the same directory or closest parent directory from the typespec entrypoint.\n\nFor example if running `tsp compile /dev/foo/bar/main.tsp`, the compiler will lookup the file at the folllowing paths(In this order):\n\n- `/dev/foo/bar/tspconfig.yaml`\n- `/dev/foo/tspconfig.yaml`\n- `/dev/tspconfig.yaml`\n- `/tspconfig.yaml`\n\n### Schema\n\nThe file is a `yaml` document with the following structure. See the [next section](#typespec-configuration-options) for details on each option.\n\n```typespec\nmodel TypeSpecProjectSchema {\n  extends?: string;\n  parameters?: Record<{default: string}>\n  \"environment-variables\"?: Record<{default: string}>\n  \"warn-as-error\"?: boolean;\n  \"output-dir\"?: boolean;\n  \"trace\"?: string | string[];\n  imports?: string;\n  emit?: string[];\n  options?: Record<unknown>;\n  linter?: LinterConfig;\n}\n\nmodel LinterConfig {\n  extends?: RuleRef[];\n  enable?: Record<RuleRef, boolean>;\n  disable?: Record<RuleRef, string>;\n}\n```\n\n### Extending project files\n\nThere is cases where you might want to build different folders with different options(for example different emitters) but want to share some configuration for both as well.\n\nFor that you can use the `extends` property of the configuration file\n\nin `<my-pkg>/tspconfig.yaml`\n\n```yaml\noptions:\n  emitter1:\n    some-option: my-name\n  emitter2:\n    some-other-option: This is a title\n```\n\nin `<my-pkg>/proj2/tspconfig.yaml`, enable `emitter1` using the options specified in the parent `tspconfig.yaml`\n\n```yaml\nextends: ../tspconfig.yaml\nemit:\n  - emitter1\n```\n\n### Variable interpolation\n\nThe typespec project file provide variable interpolation using:\n\n- built-in variables\n- environment variables\n- config file parameters\n- emitter options can reference each other\n\nVariable interpolation is done using an variable expression surrounded by `{` and `}`. (`{<expression>}`)\n\nExamples:\n\n- `{output-dir}/my-path`\n- `{env.SHARED_PATH}/my-path`\n\n### Emitter path config interpolation\n\nSome config of emitters can be interpolated using a special rule that will collapse a path.\n\nIf a variable is followed by a `/` or `.` and the emitter interpolating the config doesn't provide that variable it will then omit the path segment.\n\nFor example given the following config value: `{service-name}/output.{version}.json`\nThe following would get produced\n\n| Service name value | Version value | Result                    |\n| ------------------ | ------------- | ------------------------- |\n| `\"PetStore\"`       | `\"v1\"`        | `PetStore/output.v1.json` |\n| `\"PetStore\"`       | `undefined`   | `PetStore/output.json`    |\n| `undefined`        | `\"v1\"`        | `output.v1.json`          |\n| `undefined`        | `undefined`   | `output.json`             |\n\n#### Built-in variables\n\n| Variable name  | Scope           | Description                                                                          |\n| -------------- | --------------- | ------------------------------------------------------------------------------------ |\n| `cwd`          | \\*              | Points to the current working directory                                              |\n| `project-root` | \\*              | Points to the the tspconfig.yaml file containing folder.                             |\n| `output-dir`   | emitter options | Common `output-dir` See [output-dir](#output-dir---configure-the-default-output-dir) |\n| `emitter-name` | emitter options | Name of the emitter                                                                  |\n\n#### Project parameters\n\nA typespec project file can specify some parameters that can then be specified via the CLI.\n\n`{cwd}` and `{project-root}` variables can be used in the default value of those parmeters.\n\nThe parameters can then be referenced by their name in a variable interpolation expression.\n\nParameters must have a default value.\n**Example:**\n\n```yaml\nparameters:\n  base-dir:\n    default: \"{cwd}\"\n\noutput-dir: {base-dir}/output\n```\n\nThe parameter can then be specified with `--arg` in this format `--arg \"<parameter-name>=<value>\"`\n\n```bash\ntsp compile . --arg \"base-dir=/path/to/base\"\n```\n\n#### Environment variables\n\nA typespec project file can define which environment variables it can interpolate.\n\n`{cwd}` and `{project-root}` variables can be used in the default value of the environment variables.\n\nThe environment variables can then be referenced by their name in a variable interpolation expression with the `env.` prefix.\n\nEnvironment variables must have a default value.\n\n**Example:**\n\n```yaml\nenvironment-variables:\n  BASE_DIR:\n    default: \"{cwd}\"\n\noutput-dir: {env.BASE_DIR}/output\n```\n\n#### Emitter options\n\nEmitter options can reference each other using the other option name as the variable expresion.\n\nCan only interpolate emitter options from the same emitter.\n\n```yaml\noptions:\n  @typespec/openapi3:\n    emitter-output-dir: {output-dir}/{emitter-sub-folder}\n    emitter-sub-folder: bar\n\n```\n\n## TypeSpec Configuration Options\n\n| Config          | Cli                       | Description                                              |\n| --------------- | ------------------------- | -------------------------------------------------------- |\n| `output-dir`    | `--output-dir`            | Default output directory                                 |\n| `config`        | `--config`                | Path to config file or folder to search for config file. |\n| `trace`         | `--trace`                 | Specify tracing area to enable                           |\n| `warn-as-error` | `--warn-as-error`         | Treat warning as error                                   |\n| `imports`       | `--import`                | Additional imports to include                            |\n| `emit`          | `--emit`                  | Emitter configuration                                    |\n| `options`       | `--option` or `--options` | Emitter configuration                                    |\n| `linter`        |                           | Linter configuration                                     |\n\n### `output-dir` - Configure the default output dir\n\nSpecify the common output-dir for all emitters. See [this](#output-directory-configuration) to configure per emitter.\n\n```yaml\noutput-dir: {cwd}/typespec-build\n```\n\nOutput dir can be provided using the `--output-dir` cli flag\n\n```bash\ntsp compile . --output-dir \"./typespec-build\"\n```\n\nOutput dir must be an absolute path in the config. Use `{cwd}` or `{project-root}` to explicitly specify what it should be relative to.\n\nSee [output directory configuration for mode details](#output-directory-configuration)\n\n### `trace` - Configure what to trace\n\nConfigure what area to trace. See [tracing docs](./tracing.md)\n\n```yaml\n# Trace all.\ntrace: *\n\n# or specific areas\ntrace:\n  - import-resolution\n  - projection\n```\n\nTrace can be provided using the `--trace` cli flag\n\n```bash\ntsp compile . --trace import-resolution --trace projection\n```\n\n### `warn-as-error` - Treat warning as error\n\nAll warnings will be emitted as error. Result in a non zero exit code in case of warning.\n\n**This is recommended to use in CI to prevent warning from being unadressed.**\n\n```yaml\nwarn-as-error: true\n```\n\nor via the cli\n\n```bash\ntsp compile . --warn-as-error\n```\n\n### `--ignore-deprecated`\n\nSuppress all `deprecated` diagnostics that are raised when declarations are marked with the `#deprecated` directive.\n\n```yaml\ntsp compile . --ignore-deprecated\n```\n\n### `imports` - Configure additional imports\n\n```yaml\nimports:\n  - sidecar.tsp\n```\n\nSpecify additional typespec files to import\n\n```bash\ntsp compile . --import \"sidecar.tsp\"\n```\n\n### `emit` - Specifying which emitters to run\n\nSpecify which emitters to use and their options if applicable.\n\nThe value can be the name of an emitter or a path to the emitter package/entrypoint.\n\n```yaml\nemit:\n  - emitter1 # Package name\n  - /path/to/emitter2 # Give a path to an emitter\n```\n\nor via the cli\n\n```bash\ntsp compile . --emit emitter1 --emit /path/to/emitter2\n```\n\n### `options` - Configuring emitters\n\nEmitters can define a set of options, those can be set as the value of the map.\n\n```yaml\noptions:\n  # Enable and configure emitter1\n  emitter1:\n    option1: \"option1-value\"\n    option2: \"option1-value\"\n  # Only enable emitter2\n  emitter2: true\n```\n\nEmitters options can also be provided using the `--option` in this format `--option=<emitterName>.<optionName>=<value>`\n\n```bash\n\ntsp compile . --option \"emitter1.option1=option1-value\"\n```\n\nOptions specified via the CLI take precedence over the ones specified in `tspconfig.yaml`.\n\n#### Emitters built-in options\n\n##### `emitter-output-dir`\n\nRepresent the path where the emitter should be outputing the generated files.\n\nDefault: `{output-dir}/{emitter-name}`\n\nSee [output directory configuration for mode details](#output-directory-configuration)\n\n### `linter` - Configuring linters\n\nConfigure which linter rules should be enabled in this repository. Referencing to a rule or ruleset must be using their id which is in this format `<libraryName>:<ruleName>`\n\n```yaml\nlinter:\n  extends: # Extend `recommended` ruleset from @typespec/best-practices library\n    - \"@typespec/best-practices/recommended\"\n\n  enable: # Explicitly enable some rules\n    \"@typespec/best-practices/no-x\": true\n\n  disable: # Disable some rules defined in one of the ruleset extended.\n    \"@typespec/best-practices/no-y\": \"This rule cannot be applied in this project because X\"\n```\n\n## Emitter control cli flags\n\n### `--no-emit`\n\nDisable emitting. If emitters are still specified it will still run the emitter but emitters shouldn't be writing anything to disk.\n\nCan also be used to hide the \"There is no emitters warning\".\n\n```yaml\ntsp compile . --no-emit\n```\n\n## Other Command line flags\n\n### `--config`\n\nSpecify a different config file\n\n```bash\ntsp compile . --config ./tspconfig.alt.yaml\n```\n\n### `--watch`\n\nStart the tsp compiler in watch mode: watch for file changes and compile on save.\n\n```bash\ntsp compile . --watch\n```\n\n:::caution\nKnown issue: the watch mode does not pickup changes in JS files that are indirectly included(Only imported via another JS file.)\n:::\n\n### `--nostdlib`\n\nDon't load the TypeSpec standard library.\n\n```bash\ntsp compile . --nostdlib\n```\n\n### `--version`\n\nLog the version of the tsp compiler.\n\n```bash\ntsp compile . --version\n```\n\n### `--pretty`\n\n**Default: `true`**\n\nEnable/Disable pretty logging(Colors, diagnostic preview, etc.).\n\n```bash\ntsp compile . --pretty=false\n```\n\n## Output directory configuration\n\nTypespec compiler will provide a unique output directory for each emitter that is being run to reduce conflicts.\nBy default the output-dir of an emitter is set to this value:\n\n```\n{output-dir}/{emitter-name}\n```\n\nwhere\n\n- `output-dir` is the compiler common `output-dir` that can be configured via `--output-dir`\n- `emitter-name` is the name of the emitter package(for example `@typespec/openapi3`)\n\nExample:\nGiven the following emitters: `@typespec/openapi3` and `@typespec/jsonschema`, the default output folder structure would be\n\n```\n{project-root}/tsp-output:\n  @typespec:\n    openapi3\n      ... openapi3 files ...\n    jsonschema\n      ... json schema files ...\n```\n\nChanging the compiler `output-dir` with `--output-dir` or setting that value in the tspconfig.yaml would result in the following structure\n\n```\n--output-dir={cwd}/my-custom-output-dir\n\n{cwd}/my-custom-output-dir:\n  @typespec:\n    openapi3\n      ... openapi3 files ...\n    jsonschema\n      ... json schema files ...\n\n```\n\nChanging a specific emitter output-dir can be done by setting that emitter `emitter-output-dir` option\n\n```\n--option \"@typespec/openapi3.output-dir={projectroot}/openapispec\"\n\n{project-root}\n  openapispec:\n    ... openapi3 files ...\n  tsp-output:\n    @typespec:\n      jsonschema\n        ... json schema files ...\n```\n", "file_path": "../../core/docs\\introduction\\configuration\\configuration.md", "link_to_file": "file://../../core/docs\\introduction\\configuration\\configuration.md"}, {"file_content": "---\ntitle: Tracing\n---\n\n# Tracing\n\nBy default the TypeSpec Compiler will build without any debug information. The standard output will be minimal and limited to any `warning` or `error` diagnostics emitted during compilation.\n\nSome additional information is however being collected and can be revealed using the `--trace` cli flag.\n\n```bash\ntsp compile . --trace import-resolution\n```\n\nYou can use the `--trace` option multiple times if there is multiple areas that should be logged from.\n\n```bash\ntsp compile . --trace import-resolution  --trace projection\n```\n\nUsing `--trace *` will log everything. This might be a bit overwhelming but you can [pick and choose which trace area to include](#trace-selection)\n\nIt can also be provided via the `tspconfig.yaml` file:\n\n```yaml\ntrace: *\n\ntrace:\n  - import-resolution\n  - projection\n```\n\n## Trace selection\n\nThe tracing system in the tsp compiler works by having each trace under an area. The area name is a dot `.` separated string of area segments.\n\nWhen filtering which area to select you can use this area path to select which area is going to be revealed.\nThe filter follow the same naming style, except the last segment could be a wildcard `*`. This is however the same result as omitting the last segment all together. In other words, those filter have the exact same behavior:\n\n- `foo` and `foo.*`\n- `one.two` and `one.two.*`\n\nFor example, assuming we'd have those 3 areas\n\n- `one.two.three`\n- `one.foo`\n- `bar.info`\n\nUsing:\n\n- `*` will log everything\n- `one` will log everything under `one`(`one.two.three`, `one.foo`)\n- `bar` will log everything under `bar`(`bar.info`)\n- `one.foo` will log everything under `one.foo`(`one.foo`)\n- `other` will log everything under `other` which is nothing here.\n\n## Compiler Trace Areas\n\nThis is a list of the trace area used in the compiler\n\n| Area                           | Description                                                          |\n| ------------------------------ | -------------------------------------------------------------------- |\n| `compiler.options`             | Log the resolved compiler options                                    |\n| `import-resolution.library`    | Information related to the resolution of import libraries            |\n| `projection.log`               | Debug information logged by the `log()` function used in projections |\n| `bind.js`                      | Information when binding JS files                                    |\n| `linter.register-library`      | Information that a library rules will be loaded                      |\n| `linter.register-library.rule` | Information about a rule that is being registered                    |\n| `linter.extend-rule-set.start` | Information about a ruleset it is about to extend                    |\n| `linter.extend-rule-set.end`   | Information about rules enabled after extending a ruleset            |\n| `linter.lint`                  | Start the lint process and show information of all the rules enabled |\n\n## Tracing in TypeSpec library\n\nTypeSpec libraries can emit their own tracing that can be collected using the same mechanism. It is recommended that a library scope their tracing area under the library name to prevent collision. This can be achieved by calling the `sub(subArea: string)` method on the tracer.\n\n```ts\nconst tracer = program.tracer.sub(\"my-library\");\n```\n\nthe tracer is then available for trace collection\n\n```ts\ntracer.trace(\"emitting-ts\", \"Emitting ts interface\");\n```\n", "file_path": "../../core/docs\\introduction\\configuration\\tracing.md", "link_to_file": "file://../../core/docs\\introduction\\configuration\\tracing.md"}, {"file_content": "---\ntitle: TypeSpec Visual Studio Extension\n---\n\n## Installation\n\n:::note\nExtension is not available yet in the marketplace and must be installed via the command line.\n:::\n\n```bash\ntsp vs install\n```\n\n## Configure\n\n1. Create a file `.vs/VSWorkspaceSettings.json` at the root of the project.\n2. Add configuration as key value pair in this file. Example:\n\n```json\n{\n  \"typespec.tsp-server.path\": \"${workspaceFolder}/my-nested-project/node_modules/@typespec/compiler\"\n}\n```\n\nTypeSpec wil interpolate a few variables using this pattern `${<name>}`. For example `${workspaceFolder}`.\n\nAvailable variables:\n\n- `workspaceFolder`: Correspond to the root of your Visual Studio workspace.\n\n## Uninstall\n\nUninstalling can be done via the Visual Studio extension manager or via the command line:\n\n```bash\ntsp vs uninstall\n```\n", "file_path": "../../core/docs\\introduction\\editor\\vs.md", "link_to_file": "file://../../core/docs\\introduction\\editor\\vs.md"}, {"file_content": "---\ntitle: TypeSpec VSCode extension\n---\n\n## Installation\n\n:::note\nExtension is not available yet in the marketplace and must be installed via the command line.\n:::\n\n```bash\ntsp code install\n\n# For VSCode insiders\ntsp code install --insiders\n```\n\n## Configure\n\nTypeSpec wil interpolate a few variables using this pattern `${<name>}`. For example `${workspaceFolder}`.\n\nAvailable variables:\n\n- `workspaceFolder`: Corespond to the root of your Visual Studio workspace.\n\n### `typespec.tsp-server.path`: Configure the server path\n\nThere are cases where the TypeSpec project is located in a subfolder. In such cases, the TypeSpec extension is not able to find the tsp compiler automatically and needs a little guidance.\nThis setting provides the ability to configure where the tsp compiler is located.\n\n```json\n{\n  \"typespec.tsp-server.path\": \"${workspaceFolder}/my-nested-project/node_modules/@typespec/compiler\"\n}\n```\n\n## Uninstall\n\nUninstalling can be done via the Visual Studio Code extension manager or via the command line:\n\n```bash\ntsp code uninstall\n\n# For VSCode insiders\ntsp code uninstall --insiders\n```\n", "file_path": "../../core/docs\\introduction\\editor\\vscode.md", "link_to_file": "file://../../core/docs\\introduction\\editor\\vscode.md"}, {"file_content": "---\nid: aliases\ntitle: Aliases\n---\n\n# Alias\n\nAliases can be defined for types. This can be helpful to reuse a complex expression.\n\nAlias is only a syntax helper, and it has no representation in the type graph. This means that aliases cannot be decorated. Use [`model is`](./models.md) to provide an alternate name for a model.\n\nAlias can be defined using the `alias` keyword\n\n```typespec\nalias Options = \"one\" | \"two\";\n```\n", "file_path": "../../core/docs\\language-basics\\alias.md", "link_to_file": "file://../../core/docs\\language-basics\\alias.md"}, {"file_content": "---\nid: built-in-types\ntitle: Built-in types\n---\n\n# Built-in Types\n\nTypeSpec Standard Library provide some built-in types that can be used to build more complex types.\n\nBuilt in types are related to each other according to the rules described in [type relations](../language-basics/type-relations.md).\n\n## Numeric types\n\n| Type         | Range                                                                                                        | Description                               |\n| ------------ | ------------------------------------------------------------------------------------------------------------ | ----------------------------------------- |\n| `numeric`    |                                                                                                              | Parent type for all numeric types         |\n| `integer`    |                                                                                                              | A whole-number                            |\n| `float`      |                                                                                                              | A binary number                           |\n| `int64`      | `-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`                                                  | A 64-bit integer                          |\n| `int32`      | `-2,147,483,648` to `2,147,483,647`                                                                          | A 32-bit integer                          |\n| `int16`      | `-32,768` to `32,767`                                                                                        | A 16-bit integer                          |\n| `int8`       | `-128` to `127`                                                                                              | A 8-bit integer                           |\n| `safeint`    | <code>\u22129007199254740991 (\u2212(2<sup>53</sup> \u2212 1))</code> to <code>9007199254740991 (2<sup>53</sup> \u2212 1)</code> | An integer that can be serialized to JSON |\n| `uint64`     | `0` to `18,446,744,073,709,551,615`                                                                          | Unsigned 64-bit integer                   |\n| `uint32`     | `0` to `4,294,967,295`                                                                                       | Unsigned 32-bit integer                   |\n| `uint16`     | `0` to `65,535`                                                                                              | Unsigned 16-bit integer                   |\n| `uint8`      | `0` to `255 `                                                                                                | Unsigned 8-bit integer                    |\n| `float32`    | <code> \u00b11.5 x 10<sup>45</sup></code> to <code>\u00b13.4 x 10<sup>38</sup></code>                                  | A 32 bit floating point number            |\n| `float64`    | <code>\u00b15.0 \u00d7 10<sup>\u2212324</sup></code> to <code>\u00b11.7 \u00d7 10<sup>308</sup></code>                                | A 64 bit floating point number            |\n| `decimal`    |                                                                                                              | A decimal number                          |\n| `decimal128` | 34 decimal digits with an exponent range from `-6143` to `6144`                                              | A 128 bit decimal number                  |\n\n## Date and time types\n\n| Type             | Description                                                                         |\n| ---------------- | ----------------------------------------------------------------------------------- |\n| `plainDate`      | A date on a calendar without a time zone, e.g. \"April 10th\"                         |\n| `plainTime`      | A time on a clock without a time zone, e.g. \"3:00 am\"                               |\n| `utcDateTime`    | A date and time in coordinated universal time (UTC), e.g. \"1985-04-12T23:20:50.52Z\" |\n| `offsetDateTime` | A date and time in a particular time zone, e.g. \"April 10th at 3:00am in PST\"       |\n| `duration`       | A duration/time period. e.g 5s, 10h                                                 |\n\n## Other core types\n\n| Type        | Description                                                                                                                                            |\n| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `bytes`     | A sequence of bytes                                                                                                                                    |\n| `string`    | A sequence of textual characters                                                                                                                       |\n| `boolean`   | Boolean with `true` and `false` values                                                                                                                 |\n| `null`      | Null value                                                                                                                                             |\n| `Array<T>`  | Array model type, equivalent to `T[]`                                                                                                                  |\n| `Record<T>` | Model with string keys where all the values have type `T` (similar to `Map<string, T>` in TypeScript or `Dictionary<string, T>` in .Net)               |\n| `unknown`   | A top type in TypeSpec that all types can be assigned to. Values that can have any type should be assigned this value (similar to `any` in JavaScript) |\n| `void`      | A function/operation return type indicating the function/operation doesn't return a value.                                                             |\n| `never`     | The never type indicates the values that will never occur.                                                                                             |\n\n## String types\n\nBuilt-in types that are known string formats\n\n| Type  | Description  |\n| ----- | ------------ |\n| `url` | A url String |\n", "file_path": "../../core/docs\\language-basics\\built-in-types.md", "link_to_file": "file://../../core/docs\\language-basics\\built-in-types.md"}, {"file_content": "---\nid: decorators\ntitle: Decorators\n---\n\n# Decorators\n\nDecorators enable a developer to attach metadata to types in a TypeSpec program. They can also be used to calculate types based on their inputs. Decorators are the backbone of TypeSpec's extensibility and give it the flexibility to describe many different kinds of APIs and associated metadata like documentation, constraints, samples, and the like.\n\nMany TypeSpec constructs can be decorated, including [namespaces](./namespaces.md), [operations](./operations.md) and their parameters, and [models](./models.md) and their members.\n\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When you import a JavaScript file, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators inside the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, it will invoke the decorator function, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Using decorators\n\nDecorators are referenced using the `@` prefix and must be specified before the entity they are decorating. Arguments can be provided by using parentheses in a manner similar to many programming languages, e.g. `@myDec1, \"hi\", { a: string })`.\n\nThe following shows an example of declaring and then using a decorator:\n\n```typespec\n@tag(\"Sample\")\nmodel Dog {\n  @validate(false)\n  name: string;\n}\n```\n\nThe parentheses can be omitted when no arguments are provided.\n\n```typespec\n@mark\nmodel Dog {}\n```\n\n## Augment decorators\n\nDecorators can also be used from a different location by referring to the type being decorated. For this you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\n\n```typespec\nmodel Dog {}\n\n@@tag(Dog, \"Sample\");\n```\n\nWhich is equivalent to\n\n```typespec\n@tag(\"Sample\")\nmodel Dog {}\n```\n\nExample: Decorate a model property\n\n```typespec\nmodel Dog {\n  name: string;\n}\n\n@@readOnly(Dog.name);\n```\n\n## Writing decorator\n\n[See creating decorator documentation](../extending-typespec/create-decorators.md)\n", "file_path": "../../core/docs\\language-basics\\decorators.md", "link_to_file": "file://../../core/docs\\language-basics\\decorators.md"}, {"file_content": "---\nid: documentation\ntitle: Documentation\n---\n\n# Documentation\n\nDocumentation is crucial to any API. TypeSpec provides a number of ways to document your API using TSDoc doc comments and decorators.\n\n# Documenting APIs\n\n## `@doc` Decorator\n\nThe `@doc` decorator can be used to attach documentation to most TypeSpec declarations. It most-commonly accepts a string argument that will be used as the documentation for the declaration.\n\n```typespec\n@doc(\"This is a sample model\")\nmodel Dog {\n  @doc(\"This is a sample property\")\n  name: string;\n}\n```\n\nThe `@doc` decorator can also accept a source object which can be used, for example, to provide templated documentation for a generic type.\n\n```typespec\n@doc(\"Templated {name}\", T)\nmodel Template<T extends {}>  {\n}\n\n// doc will read \"Templated A\"\nmodel A is Template<A>\n```\n\n## TSDoc Doc Comments\n\nTSDoc doc comments are a standard way to document TypeScript code. They are supported by many IDEs and can be used to generate external documentation using tools like [TypeDoc](https://typedoc.org/).\n\nYou can annotate objects in your TypeSpec spec with TSDoc doc comments. These comments will be considered the same as if they were attached using the `@doc` decorator and can be used to generate external documentation.\n\n```typespec\n/**\n * Get a widget.\n * @param widgetId The ID of the widget to retrieve.\n * /\nop @get create(@path widgetId: string): Widget | Error;\n```\n\nThis is functionally equivalent to:\n\n```typespec\n@doc(\"Get a widget.\")\nop @get create(\n  @doc(\"The ID of the widget to retrieve.\")\n  @path\n  widgetId: string): Widget | Error;\n```\n\nThe benefit to using TSDoc doc comment syntax is that it keeps all of the documentation for a declaration in one place, making it easier to read and maintain. Additionally, it allows the generation of documentation using tools like TypeDoc without having to write a custom emitter to examine the `@doc` metadata.\n\n# Comments\n\nTypeSpec supports both single-line and multi-line comments. Single-line comments start with `//` and continue until the end of the line. Multi-line comments start with `/*` and continue until the closing `*/` is encountered.\n\n```typespec\n// This is a single-line comment\nmodel Dog {\n  /* This is a multi-line comment\n  that spans multiple lines */\n  name: string;\n}\n```\n\nComments are ignored by the compiler and are not included in the generated output. They are intended to be used to document your spec internally and are not suitable for generating external documentation.\n", "file_path": "../../core/docs\\language-basics\\documentation.md", "link_to_file": "file://../../core/docs\\language-basics\\documentation.md"}, {"file_content": "---\nid: enums\ntitle: Enums\n---\n\n# Enums\n\nEnums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. Enums can either be numeric or string-based. For other types, look into [union](./unions.md)\n\n## Basics\n\nEnums are declared using the `enum` keyword.\nThe enums members are comma `,` separated and can be typespec `identifier`s or `string literal`s.\n\n```typespec\nenum Direction {\n  North,\n  East,\n  South,\n  West,\n}\n```\n\nIn this case, we haven't specified how the constants will be represented. Different scenarios might handle the enums differently.\n\n## Values\n\nEnums members can have a custom value that can be assigned using the `:` operator.\n\n```typespec\nenum Direction {\n  North: \"north\",\n  East: \"east\",\n  South: \"south\",\n  West: \"west\",\n}\n```\n\nValues can also be integers.\n\n```typespec\nenum Foo {\n  One: 1,\n  Ten: 10,\n  Hundred: 100,\n  Thousand: 1000,\n}\n```\n\nor float\n\n```typespec\nenum Hour {\n  Zero: 0,\n  Quarter: 0.25,\n  Half: 0.5,\n  ThreeQuarter: 0.75,\n}\n```\n\n## Composing enums\n\nEnums can be reused using the spread `...` pattern. All the members of the source enums will be copied in the target enum but it doesn't create any reference between the source and target enums.\n\n```typespec\nenum DirectionExt {\n  ...Direction,\n  `North East`,\n  `North West`,\n  `South East`,\n  `South West`,\n}\n```\n\n## Referencing enum members\n\nEnum members can be referenced using the `.` operator for identifiers.\n\n```typespec\nalias North = Direction.North;\n```\n", "file_path": "../../core/docs\\language-basics\\enums.md", "link_to_file": "file://../../core/docs\\language-basics\\enums.md"}, {"file_content": "---\nid: imports\ntitle: Imports\n---\n\n# Import\n\nImports add files or libraries to your TypeSpec program. When you compile a TypeSpec file, you provide a path to your root TypeSpec file, by convention called \"main.tsp\". From there, any files you import are added to your program. If you import a directory, TypeSpec will look for a `main.tsp` file inside that directory.\n\nThe path you import must either begin with `\"./\"` or `\"../\"` or otherwise be an absolute path. The path must either refer to a directory, or else have an extension of either \".tsp\" or \".js\". The following demonstrates how to use imports to assemble a TypeSpec program from multiple files:\n\n## Import TypeSpec file\n\n```typespec\nimport \"./models/foo.tsp\";\n```\n\n## Import Js file\n\n```typespec\nimport \"./decorators.js\";\n```\n\n## Import a library\n\nThe import value can be name one of the package dependencies. In that case typespec will lookup for the `package.json` file and check the `tspMain` entry (or default to `main` if absent) to decide what is the library entrypoint to load.\n\n```typespec\nimport \"@typespec/rest\";\n```\n\n```json\n// ./node_modules/@typespec/rest/package.json\n{\n  \"tspMain\": \"./lib/main.tsp\"\n}\n```\n\nwhich result in `./node_modules/@typespec/rest/lib/main.tsp` to be imported\n\n## Import a directory\n\nIf the import value is a directory it will lookup if that directory is a node package and follow the npm package [lookup logic](#import-a-library) or if the directory contains a `main.tsp`.\n\n```typespec\nimport \"./models\"; // same as `import \"./models/main.tsp\";\n```\n\n```typespec\nimport \"./path/to/local/module\"; // Assuming this path is a typespec package, it will load it using the tspMain file.\n```\n", "file_path": "../../core/docs\\language-basics\\imports.md", "link_to_file": "file://../../core/docs\\language-basics\\imports.md"}, {"file_content": "---\nid: interfaces\ntitle: Interfaces\n---\n\n# Interfaces\n\nInterfaces can be used to group and reuse [operations](./operations.md).\n\nInterfaces are declared using the `interface` keyword.\n\n```typespec\ninterface SampleInterface {\n  foo(): int32;\n  bar(): string;\n}\n```\n\n## Composing interfaces\n\nThe keyword `extends` can be used to compose operations from other interfaces into a new interface.\n\nGiven the following interfaces\n\n```typespec\ninterface A {\n  a(): string;\n}\n\ninterface B {\n  b(): string;\n}\n```\n\na new interface `C` can be created including all operations from `A` and `B`\n\n```typespec\ninterface C extends A, B {\n  c(): string;\n}\n```\n\nwhich is equivalent to\n\n```typespec\ninterface C {\n  a(): string;\n  b(): string;\n  c(): string;\n}\n```\n\n## Interface template\n\nInterfaces can be templated, [see templates](./templates.md) for details on templates.\n\n```typespec\ninterface ReadWrite<T> {\n  read(): T;\n  write(t: T): void;\n}\n```\n\n## Interface operation templates\n\nOperations defined inside of an interface can also be templated. ([see templates](./templates.md) for details on templates.)\n\n```typespec\ninterface ReadWrite<T> {\n  read(): T;\n  write<R>(t: T): R;\n}\n\nalias MyReadWrite = ReadWrite<string>;\n\nop myWrite is MyReadWrite.write<int32>;\n```\n\n:::caution\nAny uninstantiated, templated operation defined in an interface will be excluded from the list of service operations.\n\nThis also applies when using `extends` on an interface that contains templated operations with unfilled template arguments.\n\n```typespec\ninterface ReadWrite<T> {\n  read(): T;\n  write<R>(t: T): R;\n}\n\ninterface MyReadWrite extends ReadWrite<string> {} // Here the `read()` operation is fully instantiated and will be included in a service definition. `write()` however isn't.\n```\n\nWhen working with building block interface like this use alias to create your interface building block instead of `interface extends`. This way the instantiated interface and its member will not be resolved in the service definition.\n\n```typespec\nalias MyReadWrite = ReadWrite<string>;\n\nop myRead is MyReadWrite.read;\nop myWrite is MyReadWrite.write<int32>;\n```\n\n:::\n", "file_path": "../../core/docs\\language-basics\\interfaces.md", "link_to_file": "file://../../core/docs\\language-basics\\interfaces.md"}, {"file_content": "---\nid: intersections\ntitle: Intersections\n---\n\n# Intersections\n\nIntersections describe a type that must include all the intersection's constituents. Declare an intersection with the `&` operator.\n\n```typespec\nalias Dog = Animal & Pet;\n```\n\nAn intersection is equivalent to [spreading](./models.md#spread) both types.\n\n```typespec\nalias Dog = {\n  ...Animal;\n  ...Pet;\n};\n```\n", "file_path": "../../core/docs\\language-basics\\intersections.md", "link_to_file": "file://../../core/docs\\language-basics\\intersections.md"}, {"file_content": "---\nid: models\ntitle: Models\n---\n\n# Models\n\nTypeSpec models are used to describe data shapes or schemas.\n\n## Model kinds\n\nModels can be used to represent 2 types:\n\n- [Record](#record)\n- [Array](#array)\n\n### Record\n\nRecord models are structure with named fields called properties.\n\n- name can be an `identifier` or `string literal`.\n- type can be any type reference\n- properties are ordered. See [ordering of properties](#ordering-of-properties)\n\n```typespec\nmodel Dog {\n  name: string;\n  age: number;\n}\n```\n\n#### Optional properties\n\nProperties can be marked as optional using the `?` punctuation.\n\n```typespec\nmodel Dog {\n  address?: string;\n}\n```\n\n#### Default values\n\n[Optional properties](#optional-properties) can be provided with a default value using `=` operator.\n\n```typespec\nmodel Dog {\n  address?: string = \"wild\";\n}\n```\n\n#### Ordering of properties\n\nProperties are ordered in the order that they appear in source. Properties obtained via `model is` appear before properties defined in the model body. Properties obtained via `...` are inserted where the spread appears in source.\n\nExample:\n\n```tsp\nmodel Pet {\n  name: string;\n  age: int32;\n}\n\nmodel HasHome {\n  address: string;\n}\n\nmodel Cat is Pet {\n  meow: boolean;\n  ...HasHome;\n  furColor: string;\n}\n\n// Resulting property order for cat:\n// name, age, meow, address, furColor\n```\n\n### Special property types\n\n#### `never`\n\nA model property can be declared as having the type never. This can be interpreted as the model not having that property.\n\nThis can be useful in a model template to omit a property.\n\n```typespec\nmodel Address<TState> {\n  state: TState;\n  city: string;\n  street: string;\n}\n\nmodel UKAddress is Address<never>;\n```\n\n:::note\nIt is up to the emitter to remove `never` properties. The TypeSpec compiler will not automatically omit them.\n:::\n\n### Array\n\nArray are models created using the `[]` syntax which is just a syntactic sugar for using the `Array<T>` model type.\n\n## Model composition\n\n### Spread\n\nThe spread operator takes the members of a source model and copies them into a target model. Spread doesn't create any nominal relationship between source and target, and so it's useful when you want to reuse common properties without reasoning about or generating complex inheritance relationships.\n\n```typespec\nmodel Animal {\n  species: string;\n}\n\nmodel Pet {\n  name: string;\n}\n\nmodel Dog {\n  ...Animal;\n  ...Pet;\n}\n\n// Dog is equivalent to the following declaration:\nmodel Dog {\n  species: string;\n  name: string;\n}\n```\n\n### Extends\n\nSometimes you want to create an explicit relationship between two models, for example when you want to emit class definitions in languages which support inheritance. The `extends` keyword can be used to establish such a relationship.\n\n```typespec\nmodel Animal {\n  species: string;\n}\n\nmodel Dog extends Animal {}\n```\n\n### Is\n\nSometimes you want to create a new type that is an exact copy of an existing type but with some additional properties or metadata without creating a nominal inheritance relationship. The `is` keyword can be used for this purpose. It copies all the properties(like spread), but copies [decorators](./decorators.md) as well. One common use case is to give a better name to a [template](#Templates) instantiation:\n\n```typespec\n@decorator\nmodel Thing<T> {\n  property: T;\n}\n\nmodel StringThing is Thing<string>;\n\n// StringThing declaration is equivalent to the following declaration:\n@decorator\nmodel StringThing {\n  property: string;\n}\n```\n\n## Model templates\n\n[See templates](./templates.md) for details on templates\n\n```typespec\nmodel Page<T> {\n  size: number;\n  item: T[];\n}\n\nmodel DogPage {\n  ...Page<Dog>;\n}\n```\n\n## Meta type references\n\nSome model property meta types can be referenced using `::`\n\n| Name | Example          | Description                              |\n| ---- | ---------------- | ---------------------------------------- |\n| type | `Pet.name::type` | Reference the type of the model property |\n", "file_path": "../../core/docs\\language-basics\\models.md", "link_to_file": "file://../../core/docs\\language-basics\\models.md"}, {"file_content": "---\nid: namespaces\ntitle: Namespaces\n---\n\n# Namespaces\n\nNamespaces let you group related types together into namespaces. This helps organize your types, making them easier to find and prevents name conflicts. Namespaces are merged across files, so you can reference any type anywhere in your TypeSpec program via its namespace.\n\n## Basics\n\nCreate a namespace with the `namespace` keyword.\n\n```typespec\nnamespace SampleNamespace {\n  model SampleModel {}\n}\n```\n\n_The name of a namespace must be a valid TypeSpec identifier._\n\nThe `SampleNamespace` can then be used from other places:\n\n```typespec\nmodel Foo {\n  sample: SampleNamespace.SampleModel;\n}\n```\n\n## Nested namespace\n\nNamespaces can contain sub namespaces providing additional granularity\n\n```typespec\nnamespace Foo {\n  namespace Bar {\n    namespace Baz {\n      model SampleModel {}\n    }\n  }\n}\n```\n\nor this can be simplified using `.` notation\n\n```typespec\nnamespace Foo.Bar.Baz {\n  model SampleModel {}\n}\n```\n\nThe sub-namespace can then be used from other places using the fully qualified name.\n\n```typespec\nmodel A {\n  sample: Foo.Bar.Baz.SampleModel;\n}\n```\n\n## File namespace\n\nA namespace for all declarations contained in a file can be provided at the top (After the `import` statements) using a blockless namespace statement\n\n```typespec\nnamespace SampleNamespace;\n\nmodel SampleModel {}\n```\n\nA file can only have a single blockless namespace.\n\n## Using a namespace\n\nThe content of a namespace can be exposed to the current scope using the `using` keyword.\n\n```typespec\nusing SampleNamespace;\n\nmodel Foo {\n  sample: SampleModel;\n}\n```\n\nThe bindings introduced by a `using` statement are local to the namespace they are declared in. They do not become part of the namespace themselves.\n\n```typespec\nnamespace One {\n  model A {}\n}\n\nnamespace Two {\n  using One;\n  alias B = A; // ok\n}\n\nalias C = One.A; // not ok\nalias C = Two.B; // ok\n```\n", "file_path": "../../core/docs\\language-basics\\namespaces.md", "link_to_file": "file://../../core/docs\\language-basics\\namespaces.md"}, {"file_content": "---\nid: operations\ntitle: Operations\n---\n\n# Operations\n\nOperations describe service endpoints and consist of an operation name, parameters, and return type.\n\nOperations are declared using the `op` keyword:\n\n```typespec\nop ping(): void;\n```\n\n## Parameters\n\nThe operation's parameters describe a model, so anything you can do in a model you can do in a parameter list as well, including using the spread operator:\n\n```typespec\nop feedDog(...CommonParams, name: string): void;\n```\n\n## Return type\n\nOften an endpoint returns one of any number of models. For example, there might be a return type for when an item is found, and a return type for when an item isn't found. Unions are used to describe this pattern:\n\n```typespec\nmodel DogNotFound {\n  error: \"Not Found\";\n}\n\nop getDog(name: string): Dog | DogNotFound;\n```\n\n## Reuse operations\n\nOperation signatures can be reused using the `is` keyword. Given an operation\n\n```typespec\nop Delete(id: string): void;\n```\n\nits signature can be reused like this:\n\n```typespec\nop deletePet is Delete;\n```\n\nThis means that `deletePet` will have the same parameters, return type and decorators as the `Delete` operation.\n\nThis pattern is most commonly used in combination with [operation templates](#operations-templates)\n\n## Operations templates\n\n[See templates](./templates.md) for details on templates.\n\n```typespec\nop ReadResource<T>(id: string): T;\n```\n\nThe operation template can then be referenced via `is`:\n\n```typespec\nop readPet is ReadResource<Pet>;\n```\n\n## Referencing model properties\n\nModel properties can be referenced using the `.` operator for identifiers.\n\n```tsp\nalias PetName = Pet.name;\n```\n\n## Meta type references\n\nSome operation meta types can be referenced using `::`\n\n| Name       | Example               | Description                               |\n| ---------- | --------------------- | ----------------------------------------- |\n| parameters | `readPet::parameters` | Reference the parameters model expression |\n| returnType | `readPet::returnType` | Reference the operation return type       |\n", "file_path": "../../core/docs\\language-basics\\operations.md", "link_to_file": "file://../../core/docs\\language-basics\\operations.md"}, {"file_content": "---\nid: overview\ntitle: Overview\n---\n\n# Language Overview\n\nThis is an overview of the language concept in TypeSpec. It doesn't go in detail but can be used as a cheat sheet.\n\n## Declarations\n\n- Declaration names must be unique across types within the same scope. For example this is not allowed\n  <!-- prettier-ignore -->\n    ```typespec\n  model Dog {}\n  namespace Dog {}\n  ```\n\n## Imports\n\n_Details: [Imports](./imports.md)_\n\n| Feature              | Example                   |\n| -------------------- | ------------------------- |\n| Import typespec file | `import \"./models.tsp\"`   |\n| Import JS file       | `import \"./models.js\"`    |\n| Import Library       | `import \"@typespec/rest\"` |\n\n## Namespaces\n\n_Details: [Namespaces](./namespaces.md)_\n\n| Feature           | Example                      |\n| ----------------- | ---------------------------- |\n| Declare namespace | `namespace PetStore {}`      |\n| File namespace    | `namespace PetStore;`        |\n| Nested namespace  | `namespace PetStore.Models;` |\n| Using namespace   | `using PetStore.Models;`     |\n\n## Decorators\n\n_Details: [Decorators](./decorators.md)_\n\n| Feature                      | Example                                                                             |\n| ---------------------------- | ----------------------------------------------------------------------------------- |\n| Use decorator                | `@mark`                                                                             |\n| Use decorator with arguments | `@tag(\"abc\")`                                                                       |\n| Declare a decorator in JS    | `export function $tag(context: DecoratorContext, target: Type, name: string) {...}` |\n| Save state in decorator      | `context.program.stateMap(key).set(target, <value>)`                                |\n| Augment decorator            | `@@tag(MyType, \"abc\");`                                                             |\n\n## Scalars\n\n_Details: [Scalars](./scalars.md)_\n\n| Feature            | Example                                     |\n| ------------------ | ------------------------------------------- |\n| Scalar declaration | `scalar ternary`                            |\n| Extend scalar      | `scalar Password extends string`            |\n| Template scalar    | `@doc(T) scalar Password<T extends string>` |\n\n## Models\n\n_Details: [Models](./models.md)_\n\n| Feature                        | Example                               |\n| ------------------------------ | ------------------------------------- |\n| Model declaration              | `model Pet {}`                        |\n| Model inheritance              | `model Dog extends Pet {}`            |\n| scalar is                      | `model uuid extends string;`          |\n| Model spread                   | `model Dog {...Animal}`               |\n| Property                       | `model Dog { name: string }`          |\n| Optional property              | `model Dog { owner?: string }`        |\n| Optional property with default | `model Dog { name?: string = \"Rex\" }` |\n| Model template                 | `model Pet<T> { t: T }`               |\n\n## Operations\n\n_Details: [Operations](./operations.md)_\n\n| Feature                       | Example                                          |\n| ----------------------------- | ------------------------------------------------ |\n| Operation declaration         | `op ping(): void`                                |\n| Operation with parameters     | `op upload(filename: string, data: bytes): void` |\n| Operation with return type    | `op health(): HealthStatus`                      |\n| Operation with multiple types | `op health(): HealthStatus \\| ErrorResponse`     |\n| Operation template            | `op getter<T>(id: string): T`                    |\n| Operation is                  | `op getPet is getter<Pet>;`                      |\n\n## Interfaces\n\n_Details: [Interfaces](./interfaces.md)_\n\n| Feature               | Example                                |\n| --------------------- | -------------------------------------- |\n| Interface declaration | `interface PetStore { list(): Pet[] }` |\n| Interface composition | `interface PetStore extends Store { }` |\n| Interface template    | `interface Restful<T> { list(): T[] }` |\n\n## Templates\n\n_Details: [Templates](./templates.md)_\n\n| Feature                           | Example                                             |\n| --------------------------------- | --------------------------------------------------- |\n| Simple template                   | `model Response<T> {value: T}`                      |\n| Template with multiple parameters | `model Response<K, V> {key: K, value: T}`           |\n| Template default                  | `model Response<T = string> {value: T}`             |\n| Template constraints              | `model Response<T extends {id: string}> {value: T}` |\n| Template constraints and defaults | `model Response<T extends string = \"\"> {value: T}`  |\n\n## Enums\n\n_Details: [Enums](./enums.md)_\n\n| Feature            | Example                                        |\n| ------------------ | ---------------------------------------------- |\n| Enum declaration   | `enum Direction {Up, Down}`                    |\n| Enum string values | `enum Direction {Up: \"up\", Down: \"down\"}`      |\n| Enum int values    | `enum Size {Small: 1000, Large: 2000}`         |\n| Enum float values  | `enum Part {Quarter: 0.25, Half: 0.5}`         |\n| Enum composing     | `enum Direction2D {...Direction, Left, Right}` |\n\n## Unions\n\n_Details: [Unions](./unions.md)_\n\n| Feature                 | Example                          |\n| ----------------------- | -------------------------------- |\n| Union declaration       | `\"cat\" \\| \"dog\"`                 |\n| Named union declaration | `union Pet {cat: Cat, dog: Dog}` |\n\n## Intersections\n\n_Details: [Intersections](./intersections.md)_\n\n| Feature                  | Example        |\n| ------------------------ | -------------- |\n| Intersection declaration | `Pet & Animal` |\n\n## Type literals\n\n_Details: [Type literals](./type-literals.md)_\n\n| Feature           | Example                                                  |\n| ----------------- | -------------------------------------------------------- |\n| String            | `\"Hello world!\"`                                         |\n| Multi line String | `\"\"\"\\nHello world!\\n\"\"\"` (\\n) represent actual new lines |\n| Int               | `10`                                                     |\n| Float             | `10.0`                                                   |\n| Boolean           | `false`                                                  |\n\n## Aliases\n\n_Details: [Aliases](./alias.md)_\n\n| Feature           | Example                           |\n| ----------------- | --------------------------------- |\n| Alias declaration | `alias Options = \"one\" \\| \"two\";` |\n", "file_path": "../../core/docs\\language-basics\\overview.md", "link_to_file": "file://../../core/docs\\language-basics\\overview.md"}, {"file_content": "---\ntitle: Scalars\n---\n\n# Scalars\n\nThese are types without any fields(For example `string`, `int32`, `boolean`, etc.)\n\nScalar can be declared using the `scalar` keyword\n\n```typespec\nscalar ternary;\n```\n\n## Extend another scalar\n\nScalar can be extended using the `extends` keyword.\n\n```typespec\nscalar Password extends string;\n```\n\n## Template scalar\n\nScalar support template parameters. Note: the only use for those template are decorators.\n\n```typespec\n@doc(T)\nscalar Unreal<T extends string>;\n```\n", "file_path": "../../core/docs\\language-basics\\scalars.md", "link_to_file": "file://../../core/docs\\language-basics\\scalars.md"}, {"file_content": "---\nid: templates\ntitle: Templates\n---\n\n# Templates\n\nIt is often useful to let the users of a model fill in certain details. Templates enable this pattern. Similar to generics found in other languages, model templates declare template parameters that users provide when referencing the type.\n\nTemplates can be used on:\n\n- [alias](./alias.md)\n- [models](./models.md)\n- [operations](./operations.md)\n- [interfaces](./interfaces.md)\n\n```typespec\nmodel Page<T> {\n  size: number;\n  item: T[];\n}\n\nmodel DogPage {\n  ...Page<Dog>;\n}\n```\n\n## Default values\n\nA template parameter can be given a default value with `= <value>`.\n\n```typespec\nmodel Page<T = string> {\n  size: number;\n  item: T[];\n}\n```\n\n## Parameter constraints\n\nTemplate parameter can provide a constraint using the `extends` keyword. See [type relations](./type-relations.md) documentation for details on how validation works.\n\n```typespec\nalias Foo<T extends string> = T;\n```\n\nnow instantiating Foo with the wrong type will result in an error\n\n```typespec\nalias Bar = Foo<123>;\n                ^ Type '123' is not assignable to type 'TypeSpec.string'\n```\n\nTemplate constraints can be a model expression\n\n```typespec\n// Expect T to be a model with property name: string\nalias Foo<T extends {name: string}> = T;\n```\n\nTemplate parameter default also need to respect the constraint\n\n```typespec\nalias Foo<T extends string = \"Abc\">  = T\n// Invalid\nalias Bar<T extends string = 123>  = T\n                             ^ Type '123' is not assignable to type 'TypeSpec.string'\n```\n", "file_path": "../../core/docs\\language-basics\\templates.md", "link_to_file": "file://../../core/docs\\language-basics\\templates.md"}, {"file_content": "---\nid: type-literals\ntitle: Type literals\n---\n\n# Type literals\n\nAPI authors often need to describe API shapes in terms of specific literal values. For example, this operation returns this specific integer status code, or this model member can be one of a few specific string values. It is also often useful to pass specific literal values to decorators. TypeSpec supports string, number, and boolean literal values to support these cases.\n\n## String literals\n\nString literals can be represented using double quotes `\"`\n\n```typespec\nalias Str = \"Hello World!\";\n```\n\n## Multi line string literals\n\nA multi string literal is represented using a set of 3 double quotes `\"\"\"`.\n\n```typespec\nalias Str = \"\"\"\nThis is a multi line string\n - opt 1\n - opt 2\n\"\"\";\n```\n\n- Opening `\"\"\"` must be followed by a new line.\n- Closing `\"\"\"` must be preceded by a new line.\n\n### Multi line string indentation trimming\n\nMulti lines automatically remove leading whitespaces of each line aligned with the closing `\"\"\"`. This is particularly useful to keep multi line string indented with the code and not have to worry about unwanted indentation.\n\nAll those options will produce the exact same string value `\"one\\ntwo\"`\n\n```typespec\nmodel MultiLineContainer {\n  prop1: \"\"\"\none\ntwo\n\"\"\")\n\n  // Lines are indented at the same level as closing \"\"\"\"\n  prop2: \"\"\"\n  one\n  two\n  \"\"\"\n\n  prop3: \"\"\"\n      one\n      two\n      \"\"\"\n\n  // lines are less indented as the closing \"\"\"\"\n  prop4: \"\"\"\n    one\n    two\n      \"\"\"\n}\n```\n\n## Numeric literal\n\nNumeric literals can be declared by using the raw number\n\n```typespec\nalias Kilo = 1000;\nalias PI = 3.14;\n```\n\n## Boolean literal\n\nBoolean literals can be declare by using `true` or `false` keywords\n\n```typespec\nalias InTypeSpec = true;\nalias Cheater = false;\n```\n", "file_path": "../../core/docs\\language-basics\\type-literals.md", "link_to_file": "file://../../core/docs\\language-basics\\type-literals.md"}, {"file_content": "---\nid: type-relations\ntitle: Type relations\n---\n\n# Types Relations\n\n## Type hierarchy\n\n```mermaid\ngraph RL\n    record[\"Record<T>\"] --> unknown\n    customModel[\"Custom model with properties\"] --> record[\"Record<T>\"]\n    array[\"Array<T>\"] --> unknown\n    tuple[\"Tuple\"] --> array\n    numeric --> unknown\n    subgraph numerics[For numeric types, a narrower type can be assigned to a wider one]\n      integer --> numeric\n        int8 --> integer\n        int16 --> integer\n        int32 --> integer\n        safeint --> integer\n        int64 --> integer\n        uint8 --> integer\n        uint16 --> integer\n        uint32 --> integer\n        uint64 --> integer\n      float --> numeric\n        float32 --> float\n        float64 -->  float\n      decimal --> numeric\n        decimal128 --> decimal\n    end\n    string --> unknown\n    boolean --> unknown\n    null --> unknown\n    bytes --> unknown\n    plainDate --> unknown\n    plainTime --> unknown\n    zoneDateTime --> unknown\n    duration --> unknown\n```\n\n## Model with properties\n\nWhen checking if type `S` can be assigned to type `T`, if `T` is a model with properties, it will look for all those properties to be present inside of `S` and their type be assignable to the type of the property is T.\n\nFor example\n\n```typespec\nmodel T {\n  foo: string;\n  bar: int32;\n}\n\n// Valid\n\nmodel S { // When properties types are the exact same\n  foo: string;\n  bar: int32;\n}\nmodel S { // When the properties types are literal assignable to the target type\n  foo: \"abc\";\n  bar: 123;\n}\nmodel S {\n  foo: string;\n  bar: int8; // int8 is assignable to int16\n}\nmodel S {\n  foo: string;\n  bar: int32;\n  otherProp: boolean; // Additional properties are valid.\n}\n\n// Invalid\nmodel S { // Missing property bar\n  foo: string;\n}\nmodel S {\n  foo: string;\n  bar: int64; // int64 is NOT assignable to int32\n}\n```\n\n## `Record<T>`\n\nA record is a model indexed with a string with value of T. This means that it represents a model where all properties(string key) are assignable to the type T. You can assign a model expression where all the properties are of type T or another model that `is` also a `Record<T>`\n\n```typespec\n// Represent an object where all the values are int32.\nalias T = Record<int32>;\n\n// Valid\nalias S = {\n  foo: 123;\n  bar: 345;\n};\nalias S = {\n  foo: int8;\n  bar: int32;\n};\nmodel S is Record<int32>;\nmodel S is Record<int32> {\n  foo: 123;\n}\n\n// Invalid\nalias S = {\n  foo: \"abc\";\n  bar: 456;\n};\nalias S = {\n  foo: int64;\n  bar: int32;\n};\nmodel S {\n  foo: 123;\n  bar: 456;\n}\n```\n\n#### Why is the last case not assignable to `Record<int32>`?\n\nIn this scenario\n\n```typespec\nalias T = Record<int32>;\nmodel S {\n  foo: 123;\n  bar: 456;\n}\n```\n\nThe reason is `model S` here is not assignable but the model expression `{ foo: 123; bar: 456; }` is, is that model S could be extended with additional properties that could then not be compatible.\n\nIf you for example now add a new model\n\n```typespec\nmodel Foo is S {\n  otherProp: string;\n}\n```\n\nNow here `Foo` is assignable to `S` following the [model with property logic](#model-with-properties) and if `S` was assignable to `Record<int32>`, `Foo` would be able to be passed through as well but this is now invalid as `otherProp` is not an `int32` property.\n", "file_path": "../../core/docs\\language-basics\\type-relations.md", "link_to_file": "file://../../core/docs\\language-basics\\type-relations.md"}, {"file_content": "---\nid: unions\ntitle: Unions\n---\n\n# Unions\n\nUnions describe a type that must be exactly one of the union's constituents. There is 2 types of unions:\n\n- union expressions\n- named unions\n\n## Union expressions\n\nUnnamed unions can be declared by joining the variants using the `|` operator\n\n```typespec\nalias Breed = Beagle | GermanShepherd | GoldenRetriever;\n```\n\nHere it says that `Breed` can accept either a `Beagle`, a `GermanShepherd` or a `GoldenRetriever`.\n\n## Named unions\n\nNamed unions provide a way to specify a name for the union as well as explicit variant reference. Named unions are in a way similar to [enums](./enums.md) but instead of having `string` or `numeric` values it is a [record models](./models.md)\n\n```typespec\nunion Breed {\n  beagle: Beagle,\n  shepherd: GermanShepherd,\n  retriever: GoldenRetriever,\n}\n```\n\nThe above example is equivalent to the `Breed` alias above, except that emitters can actually see `Breed` as a named entity and also see the `beagle`, `shepherd`, and `retriever` names for the options. It also becomes possible to apply [decorators](./decorators.md) to each of the options when using this form.\n", "file_path": "../../core/docs\\language-basics\\unions.md", "link_to_file": "file://../../core/docs\\language-basics\\unions.md"}, {"file_content": "---\ntitle: Cadl to TypeSpec rename completed in March 2023 release\n---\n\nAs you may recall from our previous email to partners, we are renaming the product as it becomes more mature, stable and one step closer to release.\n\nWith the 2023-03-13 release, We are pleased to announce that we have completed the process of changing the name of our product from **Cadl** to **TypeSpec**. This marks another important milestone. The new name better aligns with the functionality and benefits of the product, and we believe it will make it easier for our customers to understand and remember.\n\nWe understand that change can be challenging, and we appreciate your patience and support during this process.\n\n## Name Changes\n\n- Packages:\n\n  - NPM package scope:\n\n    - @cadl-lang/[xx] -> @typespec/[xx]\n\n  - Package names\n\n| Old Package Name    | Old Namespace        | New Package Name   | New Namespace            |\n| ------------------- | -------------------- | ------------------ | ------------------------ |\n| @cadl-lang/compiler | using Cadl;          | @typespec/compiler | using TypeSpec;          |\n| @cadl-lang/rest     | using Cadl.Http;     | @typespec/http;    | using TypeSpec.Http;     |\n| @cadl-lang/rest     | using Cadl.Rest;     | @typespec/rest     | using TypeSpec.Rest;     |\n| @cadl-lang/openapi  | using Cadl.OpenApi;  | @typespec/openapi  | using TypeSpec.OpenApi;  |\n| @cadl-lang/openapi3 | using Cadl.OpenApi3; | @typespec/openapi3 | using TypeSpec.OpenApi3; |\n\n- File extension:\n\n  - `.cadl` -> `.tsp`\n\n- Configuration file:\n\n  - `cadl-project.yaml` -> `tspconfig.yaml`\n\n- CLI\n\n  - `npx cadl compile .` -> `npx tsp compile .`\n\n- Compiler JS APIs\n  - All artifacts with `*Cadl*` in the name have been updated to `*TypeSpec*`. However, aliases have been created with older `*Cadl*` name with `@deprecated` flag.\n- Noteable changes:\n\n  - @cadl-lang/rest was split into two packages, @typespec/rest and @typespec/http\n\n- Back-compatibility\n  - `.cadl` files are continue be recognized by compiler.\n  - `cadl-project.yaml` is still supported if `tspconfig.yaml` not found\n\n## Migration tool\n\nAn experimental migration tool has been introduced to take care of many of the manual migration steps. Just execute following command in your TypeSpec folder.\n\n```bash\n    npx @typespec/migrate\n```\n\nIf you would like execute from a different folder or don't have a `package.json` that indicates compiler package versions, please see command line options:\n\n```bash\n     npx @typespec/migrate --help\n```\n\nThe migration tool will perform following steps:\n\n- Rename `cadl-project.yaml` to `tspconfig.yaml`.\n- Update `tspconfig.yaml` format to new `emit` schema if necessary.\n- Rename `.cadl` files to `.tsp`.\n- Update `import` and `using` statements in any `.tsp` files\n- Update `package.json` with new package name and versions.\n", "file_path": "../../core/docs\\release-notes\\cadl-typespec-migration.md", "link_to_file": "file://../../core/docs\\release-notes\\cadl-typespec-migration.md"}, {"file_content": "---\ntitle: July 2022\n---\n\n# Release Notes July 2022 (2022-07-08)\n\nThis release contains **breaking changes**\n\n- Emitter options normalized to use kebab-case instead of camelCase.\n- `@serviceHost` decorator replaced by `@server` decorator\n- Versioning decorators now use enumerated values instead of strings\n\n## Emitter options\n\nThis release brings a stricter option definition for emitters and requires usage of those options to be specified with the fully qualified name to prevent conflicts.\nAll options have also been renamed to match `kebab-case` naming.\nThe options can also be specified via the `tspconfig.yaml` file.\n\n### Migrating Command Line Scripts\n\nIf you had for example `--option operationPollingLocation=tenant`\n\n1. Use `tspconfig.yaml` project file **Recommended**\n\n   If you don't have that file yet, create it next to `package.json`, this file can be used to configure the emitters.\n\n   ```yaml\n   emitters:\n     <fully-qualified-emitter-package-name>:\n         <optionName>: <optionValue>\n\n   # For example\n   emitters:\n     @typespec/openapi3:\n       output-file: ./openapi.json\n   ```\n\n2. Via the `--option` flag\n\n   You can still use the `--option` flag but you'll need to specify the fully qualified name of the option.\n\n   ```bash\n   --option @<emitter-package>.<optionName>=<optionValue>\n\n   # For example\n   --option @typespec/openapi3.output-file=openapi.json\n   ```\n\n#### Renamed Emitter Options\n\n| Before                 | Now           |\n| ---------------------- | ------------- |\n| **@typespec/openapi3** |\n| `outputFile`           | `output-file` |\n\n## `@serviceHost` decorator replaced with `@server` decorator\n\nThe `@serviceHost` decorator that decorated the root namespace was used to specify the domain name of the base service endpoint. This functionality has been replaced by the `@server` decorator, which allows specifying full and parametrized Uris for the service endpoint, as described [here](https://microsoft.github.io/typespec/docs/standard-library/http/#service-definition-and-metadata)\n\n### Before\n\n```typespec\n@serviceHost(\"example.com\")\nnamespace MyService;\n```\n\n### After\n\n```typespec\n@server(\"https://example.com\")\nnamespace MyService;\n```\n\n## Versioning uses enums instead of strings\n\nVersions must now be specified using string-valued enumerations, and each of the versioning decorators must reference an enum value rather than using the version string directly.\n\n```typespec\n// Before\n@versioned(\"2021-01-12\" | \"2022-01-15-preview\")\nnamespace Api;\n\n// After\n@versioned(Versions)\nnamespace Api;\n\nenum Versions { v2021_01_12: \"2021-01-12\", v2022_01_15_preview: \"2022-01-15-preview\" }\n```\n\n```typespec\n// Before\n@added(\"2022-01-15-preview\")\nmodel Foo {}\n\n// After\n@added(Versions.v2022_01_15_preview)\nmodel Foo {}\n```\n", "file_path": "../../core/docs\\release-notes\\release-2022-07-08.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2022-07-08.md"}, {"file_content": "---\ntitle: August 2022\n---\n\n# Release Notes August 2022 (2022-08-10)\n\nThis release contains **breaking changes**\n\n- Operation parameters without decorators\n- OkResponse is no longer a template\n- Route resolution changes\n- Remove `Map` type\n- `@path` may not decorate optional properties or parameters without a default value\n\n## Operation parameters without decorators\n\nA single undecorated (not marked `@query`, `@header`, `@body` or `@path`) operation parameter will now become a property of the request body rather than have its type define the request body. This allows defining the body with multiple unannotated parameters, which can include unannotated properties that are spread into parameters. (Previously, more than one unannotated parameter was an error.)\n\nFor example, the following used to define a request body of type `string`, but now defines a request body that is an object with a property named `body` of type string.\n\n```typespec\nop create(body: string): void;\n```\n\nTo get the previous behavior, the parameter now needs to be explicitly marked with `@body`:\n\n```typespec\nop create(@body body: string): void;\n```\n\n## OkResponse is no longer a template\n\nPreviously, OkResponse took an argument for the body type. Now it is a simple model like the other XxxResponse types. Alone, it implies a status code of 200 with no body.\n\nSince 200 is the default status code for non-empty bodies, you can usually replace `OkResponse<T>` with simply `T`.\n\n```typespec\nop get(id: string): OkResponse<Pet>;\n```\n\nCan be:\n\n```typespec\nop get(id: string): Pet;\n```\n\nIn certain situations where the body type is not (necessarily) a model, you will need to use the new `Body<T>` type. For example.\n\n```typespec\nop list(): OkResponse<Pet[]>;\n```\n\nCan become:\n\n```typespec\nop list(): OkResponse & Body<Pet[]>;\n```\n\nSince 200 status code is used by default, this could also be:\n\n```typespec\nop list(): Pet[];\n```\n\nGeneric models based on `OkResponse<T>` may also require `Body<T>`. For example:\n\n```typespec\nmodel MyResponse<T> {\n  ...OkResponse<T>;\n  @header example: string;\n}\n```\n\nSince T is not constrainted to be a model, it might be an intrinsic type, an array, or the like, the template should be changed to use `Body<T>`:\n\n```typespec\nmodel MyResponse<T> {\n  ...OkResponse;\n  ...Body<T>;\n  @header example: string;\n}\n```\n\nIn general, the prior `OkResponse<T>` is equivalent to `OkResponse & Body<T>` now or, equivalently, `{ ...OkResponse, ...Body<T> }`. In practice there are many situations where you can leave out OkResponse altogether and use plain `T` rather than `Body<T>`.\n\nSee also https://microsoft.github.io/typespec/docs/standard-library/http/#request--response-bodies\n\n## Route resolution changes\n\nResolving operation routes now follows the following logic:\n\n- if there is a service namespace specified\n  - only emit the operations and interfaces under that namespace(recursively)\n- if not:\n  - only emit the operations and interfaces defined at the root (DO NOT look into namespaces)\n\n### Action if applicable\n\n- If a typespec spec used a service namespace without `@serviceTitle` add the `@serviceTitle` decorator to the service namespace, otherwise no routes will be emitted.\n- If a typespec spec contains service namespaces that are not child namespaces of the service namespace, move these namespaces under the service namespace.\n\n### Cases\n\n#### Operation at the root\n\n```typespec\nop test(): void;\n```\n\n\u2705 Stay the same\n\n| Before  | After   |\n| ------- | ------- |\n| `[\"/\"]` | `[\"/\"]` |\n\n#### Operation in namespace (not service namespace)\n\n```typespec\nnamespace DemoService;\n\nop test(): void;\n```\n\n\u26a0\ufe0f Output stays the same but add warning that no routes are emitted\n\n| Before | After |\n| ------ | ----- |\n| `[]`   | `[]`  |\n\n#### Operation in namespace (not service namespace) with @route\n\n```typespec\nnamespace DemoService;\n\n@route(\"/\")\nop test(): void;\n```\n\n\u26a0\ufe0f Now the same as previous case, no routes emitted and emit warning\n\n| Before  | After |\n| ------- | ----- |\n| `[\"/\"]` | `[]`  |\n\n##### Resolve by adding the `@serviceTitle` decorator\n\nAdd `@serviceTitle` to the namespace\n\n```typespec\n@serviceTitle(\"DemoService\")\nnamespace DemoService;\n\n@route(\"/\")\nop test(): void;\n```\n\n#### Operation in service namespace\n\n```typespec\n@serviceTitle(\"My Service\")\nnamespace Foo;\n\nop test(): void;\n```\n\n\u2705 Stay the same\n\n| Before  | After   |\n| ------- | ------- |\n| `[\"/\"]` | `[\"/\"]` |\n\n#### Operation in namespaces other than the service namespace\n\n```typespec\nimport \"@typespec/rest\";\n\nusing TypeSpec.Http;\n\n@serviceTitle(\"My Service\")\nnamespace Foo {\n  @route(\"in-service\")\n  op test(): void;\n}\n\nnamespace MyLib {\n  @route(\"my-lib\")\n  op test(): void;\n}\n```\n\n\u26a0\ufe0f Other namespace routes are not included anymore\n\n| Before                      | After             |\n| --------------------------- | ----------------- |\n| `[\"/in-service\", \"my-lib\"]` | `[\"/in-service\"]` |\n\n##### Resolve by making additional namespaces children of the service namespace\n\nMake any added namespaces children of the service namespace\n\n```typespec\nimport \"@typespec/rest\";\n\nusing TypeSpec.Http;\n\n@serviceTitle(\"My Service\")\nnamespace Foo {\n  @route(\"in-service\")\n  op test(): void;\n}\n\nnamespace Foo.MyLib {\n  @route(\"my-lib\")\n  op test(): void;\n}\n```\n\n## Remove Map type\n\n`Map` type was removed. Usages of `Map<string, T>` can be replaced with new type `Record<T>`. Other usages of `Map` may be replaced with `object`.\n\n### Map using string key type\n\n```typespec\nmodel Foo {\n  options: Map<string, string>;\n}\n```\n\n#### Replace with `Record<T>`\n\n```typespec\nmodel Foo {\n  options: Record<string>;\n}\n```\n\n### Map using non-string key type\n\n```typespec\nmodel Foo {\n  options: Map<int32, string>;\n}\n```\n\n#### Replace with `object`\n\n```typespec\nmodel Foo {\n  options: object;\n}\n```\n\n## `@path` may not decorate optional properties or parameters without a default\n\nProperties and parameters marked with the `@path` decorator should be required, but may be optional if they have a default value\n\n### optional path parameters\n\n```typespec\nmodel Foo {\n  @path\n  name?: string;\n}\n```\n\nWas a bad practice, but was allowed in previous versions. This will now throw an error diagnostic.\n\n### Resolve by making the property required\n\n```typespec\nmodel Foo {\n  @path\n  name: string;\n}\n```\n\n### Resolve by adding a default value\n\n```typespec\nmodel Foo {\n  @path\n  name?: string = \"singleton\";\n}\n```\n", "file_path": "../../core/docs\\release-notes\\release-2022-08-10.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2022-08-10.md"}, {"file_content": "---\ntitle: September 2022\n---\n\n# Release Notes September 2022 (2022-09-07)\n\nThis release contains **breaking changes**:\n\n- **`Api`**: Remove `Type` suffix\n- **`TypeSpec`**: Rename `Page` to `CollectionWithNextLink`\n- **`Api`**: `Enum.members` change typed from `EnumMember[]` to `Map<string, EnumMember>`\n- **`TypeSpec`** **`Api`**: **Deprecation** of `@consumes` `@produces` decorators\n\n## **[API]** `Type` suffix removed from most `Type`s\n\nThe following types have been renamed in the compiler API:\n\n- `ModelType` -> `Model`\n- `ModelTypeProperty` -> `ModelProperty`\n- `InterfaceType` -> `Interface`\n- `EnumType` -> `Enum`\n- `EnumMemberType` -> `EnumMember`\n- `TemplateParameterType` -> `TemplateParameter`\n- `NamespaceType` -> `Namespace`\n- `OperationType` -> `Operation`\n- `StringLiteralType` -> `StringLiteral`\n- `NumericLiteralType` -> `NumericLiteral`\n- `BooleanLiteralType` -> `BooleanLiteral`\n- `TupleType` -> `Tuple`\n- `UnionType` -> `Union`\n- `UnionTypeVariant` -> `UnionVariant`\n- `ProjectionType` -> `Projection`\n\nUpdate uses of the type names on the left with the type names on the right. The old names can still be used but they are deprecated and may be removed from a future release.\n\n## [TYPESPEC] Rename `Page` to `CollectionWithNextLink`\n\nIn library `@typespec/rest` in `TypeSpec.Rest.Resources` namespace the `Page` model was renamed to `CollectionWithNextLink`.\nThis resolve an issue with `Page` being to generic of a name for this very opinionated model.\n\nBefore\n\n```typespec\nop test(): Page<MyResource>;\n```\n\nRename to\n\n```typespec\nop test(): CollectionWithNextLink<MyResource>;\n```\n\n## **[Api]** `Enum.members` change to `Map` [#953](https://github.com/microsoft/typespec/pull/953)\n\nChanged the type of the `members` property of `Enum` from `EnumMember[]` => `Map<string, EnumMember>`\n\n```diff\n-members: EnumMember[];\n+members: Map<string, EnumMember>\n```\n\n## [TypeSpec] [Api] **Deprecation**: `@consumes` `@produces`\n\nConsumption of the data set by decorators was already removed in a previous release. Using them was a no-op.\n\nThe following are deprecated and will be removed in next release.\n\n- `@consumes`\n- `@produces`\n- `getConsumes`\n- `getProduces`\n\nAlternative is to use a `@header contentType: <contentType>` property on the operation parameters or return type\n", "file_path": "../../core/docs\\release-notes\\release-2022-09-07.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2022-09-07.md"}, {"file_content": "---\ntitle: October 2022\n---\n\n# Release Notes October 2022 (2022-10-12)\n\nThis release contains **breaking changes**:\n\n- **`TypeSpec`**: Cannot `extends` or `is` a model expression via alias\n- **`Api`**: Removed `createProgram` and changed `compile` parameter order\n- **`TypeSpec`** **Deprecation** `@service` decorator replacing `@serviceTitle` and `@serviceVersion`\n- **`TypeSpec`** **`Api`**: Move `@discriminator` to compiler\n\n## [TypeSpec] Cannot `extends` or `is` a model expression via alias [PR 1004](https://github.com/microsoft/typespec/pull/1004)\n\nUsing model expression for `is` or `extends` directly was already forbidden.\n\n<!-- prettier-ignore -->\n```typespec\nmodel IsModelExpr is {bar: string} {}\n\nmodel ExtendsModelExpr extends {bar: string} {}\n```\n\nThe following workaround was however tolerated. This PR remove this functionality.\n\n<!-- prettier-ignore -->\n```typespec\nalias ModExpr = {bar: string};\nmodel IsModelExprWAlias is ModExpr {}\n\nmodel ExtendsModelExprWAlias extends ModExpr {}\n```\n\nUse a named model instead of an alias.\n\n## [API] Removed `createProgram` and changed `compile` parameter order\n\n`createProgram` has been removed in favor of `compile`. The new compile has the same parameter as `createProgram`\n\n```ts\n// Before\ncreateProgram(host, \"main.tsp);\n\n// After\ncompile(host, \"main.tsp\");\n```\n\n`compile` api was changed to match the same order as old `createProggram`\n\n```ts\n// Before\ncompile(\"main.tsp\", host);\n\n// After\ncompile(host, \"main.tsp\");\n```\n\n## [TypeSpec] Deprecation: @service decorator replacing `@serviceTitle` and `@serviceVersion`\n\n- `@serviceTitle` has been deprecated\n- `@serviceVersion` has been deprecated\n\n```typespec\n// Before\n@serviceTitle(\"Pet Store\")\n@serviceVersion(\"v1\")\nnamespace PetStore;\n\n// After\n@service({\"Pet Store\", version: \"v1\"})\nnamespace PetStore;\n```\n\nThis allows to specify the service namespace without any title or version\n\n```typespec\n@service\nnamespace PetStore;\n```\n\n## [TypeSpec] [Api] Move `@discriminator` to compiler\n\nThe `@discriminator` has been moved to the compiler. This means that if you were using the fully qualified name to reference the decorator `@TypeSpec.Rest.disriminator` it should be changed to `@discriminator`\n\n**No changes**\n\n```typespec\nusing TypeSpec.Rest;\n\n@disriminator(\"kind\")\nmodel Pet {}\n```\n\n**Before**\n\n```typespec\n@TypeSpec.Rest.disriminator(\"kind\")\nmodel Pet {}\n```\n\n**After**\n\n```typespec\n@disriminator(\"kind\")\nmodel Pet {}\n```\n\n### Change to api\n\nthe `getDiscriminator` accessor has also been removed into the compiler.\n\nBefore\n\n<!-- prettier-ignore -->\n```ts\nimport { getDiscriminator } from \"@typespec/rest\";\n```\n\nAfter\n\n<!-- prettier-ignore -->\n```ts\nimport { getDiscriminator } from \"@typespec/compiler\";\n```\n", "file_path": "../../core/docs\\release-notes\\release-2022-10-12.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2022-10-12.md"}, {"file_content": "---\ntitle: December 2022\n---\n\n# Release Notes December 2022 (2022-12-07)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New features\n\n### Decorator signature help\n\nWith the decorator signature `extern dec` added in previous release and the doc comment support added in this version the IDE is able to provide a signature help for decorators\n\n![](./signature-help.png)\n\n## New `scalar` type\n\n:::danger\nThis is a breaking change [see details here](#change-to-typespec-intrinsic-models)\n:::\n\nThis release introduce a new [scalar](../language-basics/scalars.md) type meant to represent what were previously models with no properties actually representing an scalar value.\n\n```typespec\nscalar uuid extends string;\n```\n\n## Emitter options interpolation and standardization\n\nEmitter options are not able to interpolate other values. See [details](../introduction/configuration/configuration.md#variable-interpolation)\n\n```yaml\noutput-dir: {cwd}/generated\noptions:\n  @typespec/openapi3:\n    emitter-output-dir: {output-dir}/openapi3\n```\n\n## Breaking changes\n\n### `TypeSpec` `Api` `Compiler` Moved typespec intrinsic types to a new Type `scalar`\n\nA new type has been introduced to typespec in order to differentiate scalar from structured models types. Those new types can be declared using `scalar` and can extend another scalar using `extends`.\n\n#### Change to typespec intrinsic models\n\nAll of TypeSpec intrinsic models have been updated to be `scalar` types instead of `model`. In most cases this shouldn't affect a spec but if you are defining a custom model that `is` one of the intrinsic types you'll have to update it\n\nBefore\n\n```\nmodel MyStr is string;\n```\n\nAfter\n\n```\nscalar MyStr extends string;\n```\n\n##### Migration script\n\nThe following script can be used to automatically migrate previous usages.\n\n```typespec\nnpx @typespec/migrate\n```\n\n#### Change to Compiler API\n\nRemoved:\n\n- `getIntrinsicModelName`: Check it is a std type with `program.checker.isStdType(type)` and then use the `type.name` otherwise look for `type.baseScalar`\n- `isIntrinsic`: Check it is a std type with `program.checker.isStdType(type)` or just remove the check if goal was to omit intrinsic types from models.\n\nMigration:\n\n1. Add a new switch to handle the new `scalar` type\n2. To resolve a scalar type, check if its a std type using `program.checker.isStdType(type)`\n3. If yes, do the same behavior has before with `getIntrinsicModelName`\n4. If not, call `scalar.baseScalar` and repeat step 2.\n\n### `API` - Change to `onEmit` signature\n\nThe signature of `onEmit` has been updated to accommodate for changes to the emitter options\n\n**Before**\n\n```ts\nexport function $onEmit(program: Program, options: MyEmitterOptions);\n```\n\n**Now**\n\n```ts\nexport function $onEmit(context: EmitContext);\n```\n\nAccess properties\n\n| Before                  | Now                                                                                                             |\n| ----------------------- | --------------------------------------------------------------------------------------------------------------- |\n| `program`               | `context.program`                                                                                               |\n| `options`               | `context.options`                                                                                               |\n| `options[\"output-dir\"]` | `context.emitterOutputDir` [See details](#typespec-api-emitter-option-output-dir-renamed-to-emitter-output-dir) |\n\n### [TypeSpec] [Api] Emitter option `output-dir` renamed to `emitter-output-dir`\n\nThe option has been renamed for all emitters as `emitter-output-dir` is now managed in the compiler\nBefore\n\n```yaml\nemitters:\n  my-emitter:\n    output-dir: /path/to-output-dir\n```\n\nNow\n\n```yaml\nemitters:\n  my-emitter:\n    emitter-output-dir: {output-dir}/for-this-emitter\n#                        ^ can now reference the common output-dir\n```\n\n### Change to api\n\n**Before**\n\n```ts\nexport function $onEmit(program: Program, options: MyEmitterOptions) {\n  const outputDir = options[\"output-dir\"];\n}\n```\n\n**Now**\n\n```ts\nexport function $onEmit(context: EmitContext) {\n  const outputDir = context.emitterOutputDir;\n}\n```\n\n### `API > @typespec/compiler` Multiple services per typespec specs are now allowed making a service accessor obsolete.\n\nThe following functions have been deprecated\n\n```ts\nexport function getServiceTitle(program: Program): string;\nexport function getServiceVersion(program: Program): string;\nexport function getServiceNamespace(program: Program): Namespace;\nexport function getServiceNamespaceString(program: Program): string | undefined;\nexport function setServiceNamespace(program: Program, namespace: Namespace);\n```\n\nand replaced with\n\n```ts\nexport interface ServiceDetails {\n  title?: string;\n  version?: string;\n}\nexport interface Service extends ServiceDetails {\n  type: Namespace;\n}\n\nexport function listServices(program: Program): Service[];\nexport function getService(program: Program, namespace: Namespace): Service | undefined;\nexport function isService(program: Program, namespace: Namespace): boolean;\n\nexport function addService(program: Program, type: Namespace, details?: ServiceDetails);\n```\n\nOther changes to the service resolution:\n\n- Title won't be defaulted to `(title)`\n- Version won't be defaulted to `0000-00-00`\n- Service namespace won't be defaulted to global namespace\n\n| Before                               | To add support for multi serviceF                                                            |\n| ------------------------------------ | -------------------------------------------------------------------------------------------- |\n| `getServiceNamespace(program)`       | `listServices(program)` to get all services                                                  |\n| `getServiceNamespaceString(program)` | `getNamespaceName(service.type)` is where service is `getService(program, serviceNamespace)` |\n| `getServiceTitle(program)`           | `service.title` where service is `getService(program, serviceNamespace)`                     |\n| `getServiceVersion(program)`         | `service.version` where service is `getService(program, serviceNamespace)`                   |\n\n### `TypeSpec` Directives can no longer be placed in certain contexts.\n\nFor example, this is no longer valid:\n\n```typespec\nmodel M<\n#suppress example\nT\n> {}\n```\n\nAnd will now result in an error \"Cannot place directive on template parameter\".\n\nMove such directives up to the nearest statement, interface operation, model property, operation parameter, union variant, or enum member.\n\nFor the above example, that would be:\n\n```\n#suppress example\nmodel M<T> {}\n```\n\n## Deprecations\n\n:::caution\nDeprecated items will be removed in 2 release cycle.\n:::\n\n### `TypeSpec > @typespec/rest` - `@segmentSeparator` is deprecated. The `@actionSeparator` decorator should be used instead.\n\nBefore\n\n```typespec\n@autoRoute\nnamespace Things {\n  @action\n  @segmentSeparator(\":\")\n  @put\n  op customAction1(\n    @segment(\"things\")\n    @path\n    thingId: string,\n  ): string;\n}\n```\n\nAfter:\n\n```typespec\n@autoRoute\nnamespace Things {\n  @action\n  @actionSeparator(\":\")\n  @put\n  op customAction1(\n    @segment(\"things\")\n    @path\n    thingId: string,\n  ): string;\n}\n```\n\n### `TypeSpec` Deprecated `uri` being replaced by `url`\n\nBefore:\n\n```typespec\nmodel Server {\n  endpoint: uri;\n}\n```\n\nNow:\n\n```typespec\nmodel Server {\n  endpoint: url;\n}\n```\n\n### `Config` - Deprecated `emitters` property in the `tspconfig.yaml`\n\nThe `emitters` property of the configuration file has been deprecated and replaced by 2 new properties making it consistent with the CLI\n\nBefore:\n\n```yaml\nemitters:\n  \"@typespec/openapi3\":\n    output-file: openapi3.json\n  other-emitter: true\n```\n\nAfter:\n\n```yaml\nemit:\n  - \"@typespec/openapi3\"\n  - \"other-emitter\"\noptions:\n  @typespec/openapi3:\n    output-file: openapi3.json\n```\n", "file_path": "../../core/docs\\release-notes\\release-2022-12-07.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2022-12-07.md"}, {"file_content": "---\ntitle: January 2023\n---\n\n# Release Notes January 2023 (2023-01-12)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## Breaking Changes\n\n### `@typespec/openapi3` Default output-file is `openapi.yaml`\n\nAs the openapi3 emitter added support for serializing the openapi document to yaml it changed the default to emit yaml to `openapi.yaml`.\n\n```yaml\noptions:\n  @typespec/openapi3:\n     file-type: json\n```\n\nor alternatively specify the name of the file you'd want\n\n```yaml\noptions:\n  @typespec/openapi3:\n     output-file: custom.json\n```\n\n### [API] Templated operation inside interface\n\nThis breaking change affects libraries and emitters\n\n- `templateArguments` property on templated type is deprecated and has been replaced with more detailed `templateMapper`\n\n  If you where you using the `templateArgument` to find out if something was a template instance change\n\n  ```ts\n  type.templateArguments.length > 0;\n  ```\n\n  to\n\n  ```ts\n  isTemplateInstance(type);\n  ```\n\n- Interfaces might have some templated operations\n\n  If blindly including all operations in an interface you might need to make sure the operation is not a template declaration first.\n\n  For example with the following tsp code:\n\n  ```typespec\n  interface Factory {\n    read<T>(): T;\n    ping(): void;\n  }\n  ```\n\nThe emitter probably only wants to include the `ping()` operation but ignore read(). The `isTemplateDeclaration` helper can be used to filter out the template operations.\n", "file_path": "../../core/docs\\release-notes\\release-2023-01-12.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-01-12.md"}, {"file_content": "---\ntitle: February 2023\n---\n\n# Release Notes February 2023 (2023-02-07)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### Emitter Framework\n\nThe new emitter framework makes it simpler to build emitters from TypeSpec to other assets. It provides an easy way to handle TypeSpec types and provides a template for asset emitters to spell out the emitter tasks. It provides helpers to solve many difficult problems, including:\n\n- Constructing references between types\n- Handling circular references\n- Propagating type context based on containers or references\n- Class-based inheritance to encourage reuse and specialization of existing emitters\n\nDetails are available on the documentation website or in the [repository documentation] (https://github.com/microsoft/typespec/blob/main/docs/extending-typespec/emitter-framework.md).\n\n### Cli support for emitters in development\n\nUse the path to the emitter to specify emitter options, rather than the emitter name.\n\n### Allow `@autoroute` and `@route` to be used together\n\nProvide standard rules for combining `@route` and `@autoroute` decorators\n\n- Allow `@route` applied to an operation to override route settings from the interface\n- Allow `@route` on an operation to prepend the paths provided by `@autoroute`\n\n### Simplified versioning dependencies\n\nIntroduced the `@useDependency` decorator to replace `@versionedDependency` decorator. Simplify dependencies between versioned namespaces, by allowing each version to be decorated with the appropriate versioned dependency, rather than requiring the user to construct a dependency map.\n\n## Breaking Changes\n\nBreaking changes in this release resulted from removal of previously decorated types and functions, including:\n\n- `uri` scalar removed. Use the `url` scalar instead.\n- Removed deprecated metadata types with the 'type' suffix.\n  - Use `Enum` instead of `EnumType`\n  - Use `EnumMember` instead of `EnumMemberType`\n  - Use `Interface` instead of `InterfaceType`\n  - Use `Model` instead of `ModelType`\n  - Use `ModelProperty` instead of `ModelTypeProperty`\n  - Use `Namespace` instead of `NamespaceType`\n  - Use `Operation` instead of `OperationType`\n  - Use `Tuple` instead of `TupleType`\n  - Use `Union` instead of `UnionType`\n- Removed `Map<K, V>` type, use `Record<V>` instead\n- Removed `@serviceTitle` and `@serviceVersion` decorators. Use the `@service` decorator instead.\n- Removed helper and accessor functions associated with `@serviceTitle` and `@serviceVersion` decorators\n  - Replace `getServiceNamespace`, `getServiceTitle`, `getServiceVersion`, and `getServiceNamespaceString` with `getService` or `listServices`\n  - Replace `setServiceNamespace` with `addService`\n- Removed `@segmentSeparator`, use `@actionSeparator` instead\n- Removed `@produces` and `@consumes` decorators. Use `@header contentType: <ContentType>` instead in the operation return type\n- Removed `getSegmentSeparator` function. Use `getActionSeparator` instead\n- Removed `getProduces` and `getConsumes` functions. Use `getContentTypes` instead\n\n## Deprecations\n\n### Deprecates the `@versionedDependency` decorator in favor of the `@useDependency` decorator\n\nFor versioned libraries, `@useDependency` is applied to the version enum members\n\n#### Before (versioned namespace)\n\n```typespec\n@armProviderNamespace\n@service({\n  title: \"Microsoft.Observability\",\n})\n@versionedDependency(\n  [\n    [Microsoft.Observability.Versions.v2021_06_13_preview, Azure.Core.Versions.v1_0_Preview_2],\n    [Microsoft.Observability.Versions.v2022_04_30_preview, Azure.Core.Versions.v1_0_Preview_2]\n  ]\n)\n@versionedDependency(\n  [\n    [\n      Microsoft.Observability.Versions.v2021_06_13_preview,\n      Azure.ResourceManager.Versions.v1_0_Preview_1\n    ],\n    [\n      Microsoft.Observability.Versions.v2022_04_30_preview,\n      Azure.ResourceManager.Versions.v1_0_Preview_1\n    ]\n  ]\n)\n@versioned(Versions)\nnamespace Microsoft.Observability;\n\ninterface Operations extends Azure.ResourceManager.Operations {}\n\nenum Versions {\n  v2021_06_13_preview: \"2021-06-13-preview\",\n  v2022_04_30_preview: \"2022-04-30-preview\",\n}\n```\n\n#### After (Versioned namespace)\n\n```typespec\n@armProviderNamespace\n@service({\n  title: \"Microsoft.Observability\",\n})\n@versioned(Versions)\nnamespace Microsoft.Observability;\n\ninterface Operations extends Azure.ResourceManager.Operations {}\n\nenum Versions {\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2, Azure.ResourceManager.Versions.v1_0_Preview_1)\n  v2021_06_13_preview: \"2021-06-13-preview\",\n\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2, Azure.ResourceManager.Versions.v1_0_Preview_1)\n  v2022_04_30_preview: \"2022-04-30-preview\",\n}\n```\n\nFor unversioned libraries that reference versioned libraries, simply replace `@versionedDependency` with `@useDependency`\n\n#### Before (unversioned namespace using versioned library)\n\n```typespec\n@service({\n  title: \"Microsoft.EnvelopeTest\",\n  version: \"2021-09-21-preview\",\n})\n@versionedDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armProviderNamespace\nnamespace Microsoft.EnvelopeTest;\n```\n\n#### After (unversioned namespace using versioned library)\n\n```typespec\n@service({\n  title: \"Microsoft.EnvelopeTest\",\n  version: \"2021-09-21-preview\",\n})\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armProviderNamespace\nnamespace Microsoft.EnvelopeTest;\n```\n", "file_path": "../../core/docs\\release-notes\\release-2023-02-07.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-02-07.md"}, {"file_content": "---\ntitle: March 2023\n---\n\n# Release Notes March 2023 (2023-03-13)\n\n:::danger\nThis release contains **breaking changes**\n\nPlease see [Cadl to TypeSpec rename and migration FAQ](./cadl-typespec-migration.md)\n:::\n\n## New Features\n\n### Add--config option\n\nEnable specifying path to configuration file\n\n### Allow escaping identifiers using backticks\n\nIdentifiers may contain reserved words or non-standard characters when surrounded with backticks (`), for example:\n\n```typespec\nop `op`(): void;\n```\n\n### Correct Order of Application for augment decorators\n\nAugment decorators applied last\n\n### Added migration script for specs using Cadl\n\nMigration script available for existing specs, see `@typespec/migrate` for details\n\n### Added public formatIdentifier function\n\nAdded public formatIdentifier function.\n\n### Visibility defaults to read\n\nDefault visibility is configurable, but default to 'read'.\n\n## Breaking Changes\n\n### Cadl renamed to Typespec\n\nAll core cadl packages moved from the `@cadl-lang` group to the `@typespec` group\n\n| Old Package Name      | New Package Name               |\n| --------------------- | ------------------------------ |\n| @cadl-lang/compiler   | @typespec/compiler             |\n| @cadl-lang/rest       | @typespec/rest, @typespec/http |\n| @cadl-lang/migrate    | @typespec/migrate              |\n| @cadl-lang/openapi    | @typespec/openapi              |\n| @cadl-lang/openapi3   | @typespec/openapi3             |\n| @cadl-lang/versioning | @typespec/versioning           |\n\n### `rest` library split into `http` and `rest` libraries\n\nBasic http protocol support is in the `http` library, support for resources and ReST are in the `rest` library. The migration tool will correctly update imports in your spec to match the new\nlibraries.\n\n### Removed Support for Visual Studio 2019 in Visual Studio IDE extension\n\nYou must use a later version of Visual Studio\n\n### Removed `emitters` option in configuration\n\nUse `emit` and `options` instead\n", "file_path": "../../core/docs\\release-notes\\release-2023-03-13.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-03-13.md"}, {"file_content": "---\ntitle: April 2023\n---\n\n# Release Notes April 2023 (2023-04-11)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### @typespec/compiler\n\n- Emit diagnostic when ambiguous symbol exists between global and usings\n- Add support for referencing metatypes ModelProperty `::type` and Operation `::returnType` and `::parameters`\n- Relax constraint on derived type overrides\n- Prevent use of augment decorators on instantiated templates.\n- Allow projectedNames helpers to work with previous projections\n- Add helper `interpolatePath` for emitter to do additional interpolation on config properties\n- Api: Update `getTypeName` to omit standard library namespace\n- Allow overloads in interfaces to work under projection\n- Add pre-projection support\n- Provide access to extended interfaces in type graph\n- Document member ordering and fix projection rename reordering\n\n### @typespec/openapi3\n\n- Support shared routes\n- Update to use new `interpolatePath` logic to resolve the `output-file`\n\n### @typespec/migrate\n\n- Add migrate script for zonedDateTime\n- Add migration script for `@header` and `@query` format required\n\n## Bug Fixes\n\n### @typespec/compiler\n\n- Fix: emitter framework will now visit scalar declarations\n- Fix: Alias unknown ref crash\n- Fix: Empty model expression assignable to array\n- Fix: `tsp code uninstall` not finding extension to uninstall\n- Fix: Issue where template parameter type check wouldn't work if constraint is exact same type as next validation\n\n### @typespec/rest\n\n- Fix: Issue where `@action(\"\")` was treated the same as `@action`. Now this emits an error.\n\n### @typespec/versioning\n\n- Fix: Issue with using version as a template parameter across different namespaces. Includes a significant change in the versioning library internals.\n- Fix:Use pre-projections to fix issues with versioned resources.\n\n### VS Code extension\n\n- Fix: Highlighting of TypeSpec code blocks in markdown.\n\n## Breaking Changes\n\n### @typespec/versioning: Removed deprecated versioning symbols.\n\n- Removed `@versionedDependency` decorator. Use `@useDependency` instead.\n- Removed `getRenamedFromVersion`. Use `getRenamedFromVersions` instead.\n- Removed `getRenamedFromOldName`. Use `getNameAtVersion` instead.\n- Removed `getAddedOn`, `addedAfter`, `getRemovedOn` and `removedOnOrBefore`. Use `existsAtVersion` instead.\n- Removed `renamedAfter`. Use `hasDifferentNameAtVersion` instead.\n\n### @typespec/compiler: Removed `zonedDateTime` and replaced with `utcDateTime` and `offsetDateTime`\n\nTo disambiguate important time concepts and encourage best practice behavior in representing date-time types we\nremoved `zonedDateTime` which was being used to represent a time with offset, and replaced it with two new types that are more precisely defined:\n\n- `utcDateTime` which represents a precise instant in time. This type should be used to represent time values given in coordinated universal time (UTC) and unix timestamps. This is the preferred mechanism for capturing dateTime in most service specifications.\n- `offsetDateTime` which represents a time with offset. Note that while this time contains an offset from UTC, it does not contain any additional time zone information.\n\n#### Change instances of `zonedDateTime` to `utcDateTime`\n\n##### Old\n\n```typespec\nmodel MyModel {\n  createdAt: zonedDateTime;\n}\n```\n\n#### New\n\n```typespec\nmodel MyModel {\n  createdAt: utcDateTime;\n}\n```\n\n#### Use the (experimental) Migration tool to make this change\n\nThe (experimental) migration tool will automatically migrate instances of `zonedDateTime` to `utcDateTime`. To perform all migrations in a TypeSpec or Cadl specification package, execute:\n\n```bash\nnpx @typespec/migrate\n```\n\nIf you would like to execute from a different folder or don't have a package.json that indicates compiler package versions, please see command line options:\n\n```bash\nnpx @typespec/migrate --help\n```\n\n### @typespec/http: Removed header and query default format\n\n`@header` and `@query` no longer default the `format` to `csv` and `multi` respectively. A value must now be provided when the type is an array. The migration tool can also be used to make this change.\n\n### @typespec/lint: Removed global state\n\nRules from another library can no longer be enabled on a LibraryLinter.\n", "file_path": "../../core/docs\\release-notes\\release-2023-04-11.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-04-11.md"}, {"file_content": "---\ntitle: May 2023\n---\n\n# Release Notes May 2023 (2023-05-10)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### @typespec/compiler features\n\n- Add `@encode` decorator, with new formats for date and duration encoding support\n  - `\"rfc3339\"`, `\"rfc7231'` for `utcDateTime`, `offsetDateTime` types\n  - `\"unixTimestamp\"` support for `utcDateTime` type\n  - `\"iso8601\"` support for `duration` types\n  - `\"base64\"`, `\"base64url\"` support for `bytes` types\n- Allow default values for required model properties and parameters\n- `sourceModel` property added to `Model` types\n- `sourceOperation` property added to `Operation` types\n- `Model` and `Scalar` types added to `TypeSpec.Reflection` namespace\n\n### @typespec/http features\n\n- add `@sharedRoute` decorator\n- allow union types within a response status code\n\n### @typespec/openapi3 features\n\n- Enhanced support for shared routes\n- Support for union types within a response status code\n\n## Bug Fixes\n\n- General fixes to generated reference documentation for all modules\n\n### @typespec/compiler fixes\n\n- Fix: compiler mismatch error recommendation\n- Fix: Interface with templated operation causing crash if defined after use\n- Fix: Issue with templated operations in templated interface would get cached only by keying on the operation template args.\n- Fix: `missing-index` diagnostic showing at the wrong location\n- Fix: `--emit` pointing to emitter js entrypoint resolve correct options\n- Fix: `scalar` template parameter name conflict with each other\n\n### @typespec/migrate fixes\n\n- Fix: incorrect resolution of tsp version\n- Fix: always loading current version of compiler\n\n### @typespec/openapi3 fixes\n\n- Fix openapi3 emitter to mark request body required\n- Fix issue where shared request bodies did not emit correctly.\n\n### @typespec/rest\n\n- Add validation to ensure that @action or @collectionAction operations have a specified name when used with `@sharedRoute`\n\n### @typespec/versioning\n\n- Fix: Crash during validation when using certain templated models from versioned library\n- Added validation preventing version enums from having duplicate values.\n- Fix issue where \"is\" dependencies were not detected.\n- Raise error if versioned spec specifies a single service version.\n\n## Breaking Changes\n\n### `@typespec/compiler`: `isTemplateDeclaration` will only return true for the original declaration and not partially instantiated templates\n\nIf library or emitter code needs to detect a partially instantiated template, the code will need to check `isTemplateInstance` _and_ `isTemplateDeclaration` properties are false.\n\n## Deprecations\n\n### `@typespec/compiler`: Use `@encode` instead of `@format` for encoding scalars and properties of type `bytes`\n\nThe new `@encode` decorator should be used whenever the serialized type on the wire differs from the analogous TypeSpec type\n\n#### Old deprecated usage of `@format` decorator\n\n```typespec\nmodel Foo {\n  @format(\"base64url\")\n  bar: bytes;\n}\n```\n\n#### New usage of `@encode` decorator\n\n```typespec\nmodel Foo {\n  @encode(\"base64url\")\n  bar: bytes;\n}\n```\n\n### http: Use `@sharedRoute` instead of the `shared` property of `@route` options\n\nThe new `@sharedRoute` decorator replaces `@route` options for identifying operations that share a route\n\n#### Old deprecated usage of `@route` decorator `shared` option\n\n```typespec\n@route(\n  \"/doStuff\",\n  {\n    shared: true,\n  }\n)\nop doIntStuff(input: int32): int32;\n\n@route(\n  \"/doStuff\",\n  {\n    shared: true,\n  }\n)\nop doStringStuff(input: string): string;\n```\n\n#### New usage of `@sharedRoute` decorator\n\n```typespec\n@sharedRoute\n@route(\"/doStuff\")\nop doIntStuff(input: int32): int32;\n\n@sharedRoute\n@route(\"/doStuff\")\nop doStringStuff(input: string): string;\n```\n", "file_path": "../../core/docs\\release-notes\\release-2023-05-10.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-05-10.md"}, {"file_content": "---\ntitle: June 2023\n---\n\n# Release Notes June 2023 (2023-06-06)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n- Json Schema Emitter\n- New decimal types\n- Support for using doc comments instead of the @doc decorator\n- New `valueof` type constraint modifier for type literals\n- Lazy evaluation of emitter configuration\n- Signature Help for Template Arguments and other IDE improvements\n\n### New Decimal Types\n\nAdded support for `decimal` and `decimal128` types\n\n```typespec\nmodel Foo {\n  price: decimal;\n  shortPrice: decimal128;\n}\n```\n\nThese types represent values stored in decimal format which are often used in financial calculations to avoid rounding errors introduced by binary floating point formats. `decimal` can store values of any size and precision, while `decimal128` corresponds to the 128 bit decimal floating point format described by IEEE 754.\n\n### Support for Doc Comments\n\nDoc comments (`/** */`) will be treated as the documentation for types, unless there is an explicit `@doc` decorator\n\n```typespec\n/** This will now be the documentation for model Foo */\nmodel Foo {\n  name: string;\n}\n```\n\n### New `valueof` type constraint modifier to require type literals\n\nTemplates and decorators can now constrain arguments to literal types. For example, the following template constraint:\n\n```typespec\nmodel Foo<T extends valueof string> {\n  @doc(T)\n  name: string;\n}\n```\n\nwould match quoted literal strings, \"this\", as well as references to enum values. Templates and decorators that require string values should change to using this new formulation.\n\n### Allow lazy evaluation of emitter config\n\n- Validate linter configuration only for linters that are executing. This removes warnings for emitters that are configured but not available in a particular compilation.\n\n### Enable Signature Help for Template Arguments\n\n- Template completion will now have similar help in IDE language server as decorators currently do.\n\n### Show documentation Comments on Aliases in IDE Language Tooling\n\n- Documentation comments will show up in the IDE, just as documentation comments for other library types.\n\n### Ensure a dev release for all packages\n\n- Packages with no changes will now release with a `-dev.0` version in dev releases.\n\n### Json Schema Emitter\n\n- Core packages now contain a Json Schema emitter `@typespec/json-schema`\n\n## Bug Fixes\n\n-`tspconfig.yaml` should always get resolved relative to the entrypoint.\n\n- `Array` and `Record` doc comments are treated as developer documentation.\n\n- Fixed formatting of comment between decorator and `op` statement.\n\n- Decorators on operations may reference the same operation, or may reference an operation that references this operation.\n\n```typespec\ninterface FooOperations {\n  @nextPageOperation(getNextPage) // allowed\n  getNextPage(pageLink: url): Page<Foo>;\n}\n```\n\n- Fix validation for `unixTimeStamp`.\n\n- Fix diagnostic for `intrinsic type expected` to not assume `string` as the required type.\n\n- Fix error message for `@encode` errors.\n\n- Fix error handling when template is missing or invalid in `tsp init`.\n\n- Emitter framework: uppercase type argument type names when constructing a declaration name from a template instantiation.\n\n- Add reference documentation for missing decorators.\n\n- Remove dependency on `node-fetch`.\n\n- Remove inaccurate output directory message from compilation success.\n\n- Allow template resolution over http redirects for `tsp init` templates.\n\n- Improve signature help for an unterminated argument list.\n\n## New Deprecations\n\n- Templates that use decorators with the `valueof` constraint will receive a warning if their input types are not similarly constrained.\n\n```typespec\nmodel Foo<T extends string> {\n  @doc(T) // valueof constraint here will cause a warning\n  id: uuid;\n}\n```\n\nshould be changed to apply the valueof constraint to their parameters that are passed to such decorators:\n\n```typespec\nmodel Foo<T extends valueof string> {\n  @doc(T) // no warning\n  id: uuid;\n}\n```\n\n- The `object` type is deprecated. Templates and decorators should use TypeSpec.Reflection.Model to indicate a model contraint. In specs, `{}` designates and empty model, `unknown[]` indicates and empty array, and `Record<unknown>` indicates a keyed type with unknown property types.\n\n## Breaking Changes\n\n- Decorators that require literal type value marshalling MUST change to using the `valueof` keyword.\n\n```typespec\nextern dec myDecorator(target: Type, name: string);\n```\n\nMust be changed to use the valueof decorator\n\n```typespec\nextern dec myDecorator(target: Type, name: valueof string);\n```\n\n- Arrays are no longer assignable to an empty model (or object)\n\n- Remove `@format(\\\"url\\\") from url scalar. OpenAPI emitters will still emit the appropriate format, emitters should rely on the scalar type to determine how to process the url type, not the format string.\n", "file_path": "../../core/docs\\release-notes\\release-2023-06-06.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-06-06.md"}, {"file_content": "---\ntitle: July 2023\n---\n\n# Release Notes July 2023 (2023-07-11)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### `@typespec/compiler` and core language\n\n- New built-in linter system. Typespec libraries are able to define linting rules which can be configured in `tspconfig.yaml`. See documentation for [configuring a linter](https://microsoft.github.io/typespec/introduction/configuration#linter---configuring-linters) and [writing a linter](https://microsoft.github.io/typespec/extending-typespec/linters)\n- Allow decorators, directives and doc comments to be specified in any order\n- Format doc comments above decorators and directives\n- Improve formatting for properties with comments and decorators\n- Support for new Unicode 15.0 identifier characters\n\n### Emitter framework\n\n- Add `writeOutput` to TypeEmitter for additional customization in writing generated files\n- Add `meta` property to source files and declarations to store arbitrary metadata\n- Add support for emitting enum member references\n- Add new `TypeEmitter` methods for scalar instantiation\n\n### `@typespec/http` library\n\n- Add documentation on automatic header name resolution from property name for `@header` decorator\n\n### `@typespec/json-schema` emitter\n\n- Support `@extension` for adding arbitrary vendor extensions into the output\n- Add support for `Record<T>`\n- Support templates instantiated with intrinsic types and type expressions\n- Export emitter and related types from the npm package\n- By default, types that are not marked with `@jsonSchema` or are within a namespace with `@jsonSchema` are bundled into the schemas that reference them. Set the `emitAllRefs` option to true to get the previous behavior of emitting all types referenced as JSON Schema\n\n### `@typespec/openapi3` emitter\n\n- Omit `x-typespec-name` extension by default from openapi3 output. A new configuration and command line option `include-x-typespec-name: \\\"inline-only\\\" | \\\"never\\\"` has been added to get previous behavior\n\n### `@typespec/rest` library\n\n- Add `isListOperation` function migrated from `@typespec/compiler`\n\n## Bug Fixes\n\n### `@typespec/compiler` and core language bug fixes\n\n- Add support for `UTF-8 with bom` for other files loaded by typespec compiler. `.tsp` files already had support, this make it more available for any library/emitter using the compiler api to load a file.\n- Fix signature help after comment with no closing parenthesis or angle bracket\n- Doc comment `/** */` should override base type doc in `model is` or `op is`\n- Formatter incorrectly formatting `::` to `.`\n- Fix formatting issue with comment between decorator and scalar or interface\n- Fix stack overflow when a circular reference with `op is` exists inside an interface.\n- Clean up handling of non-standard entrypoints in language server\n- Fix stack overflow when referencing decorator target in checker and projections\n\n### `@typespec/openapi3` emitter bug fixes\n\n- OpenAPI emitters: treat union namespaces like namespaces for other types\n\n### Emitter framework bug fixes\n\n- Fix that some context methods were not being passed the expected parameters\n- Fix that context was set incorrectly for some `TypeEmitter` methods, and add missing context methods for model properties, enum members, and union variants\n\n### `@typespec/json-schema` emitter bug fixes\n\n- Fix a bug that could result in a schema being bundled more than once\n\n## Breaking Changes\n\n### For Specification Authors\n\n- Update tsp init template schema for future extensibility. Older tsp version will fail validation when trying to initialize a project with a new template definition.\n- Json Schema Emitter: the namespace has been corrected to TypeSpec.JsonSchema. Update any using statements from `JsonSchema` to `TypeSpec.JsonSchema`, and any references from `JsonSchema.[Type]` to `TypeSpec.JsonSchema.[Type]`.\n\n### For Emitters and Libraries\n\n- Minimum version of TypeScript updated to 5.0. TypeSpec is using new features available in TypeScript 5.0 which result in a definition file not parsable by older version. Note that this only affect compiling TypeScript code and is not breaking any JS or TypeSpec code. [See more information on typescript 5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/)\n- Emitter Framework: Add support for templates instantiated with types without declared names. In such cases, `TypeEmitter`'s declarationName method may return `undefined`, and so the various `*Instantiation` methods might be called with an undefined name, and `AssetEmitter`'s `emitDeclarationName` method might return undefined.\n- Make internal `@resourceTypeForKeyParam` decorator in `@typespec/rest` library private\n\n## Deprecations\n\n- `@list` decorator from TypeSpec core is deprecated. Use `@listsResource` from `@typespec/http` instead\n- `isListOperation` function from TypeSpec core is deprecated. Use `isListOperation` from `@typespec/http` instead\n- `getListOperationType` from TypeSpec core is deprecated\n- `@typespec/linter` Package is deprecated in favor of built-in linter system\n", "file_path": "../../core/docs\\release-notes\\release-2023-07-11.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-07-11.md"}, {"file_content": "---\ntitle: August 2023\n---\n\n# Release Notes August 2023 (2023-08-08)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### `@typespec/compiler` New Features\n\n- Allow unnamed variants in named unions\n- Add `#deprecated` directive to replace `@deprecated` decorator, allowing deprecation any language element\n- Add a new util `resolveCompilerOptions` to resolve compiler options from a given entrypoint. This will resolve the options from the tspconfig.yaml in the same way the cli would.\n- Improvements to compiler watch mode. Files loaded in previous compilation will be watched for changes.\n- Allow library dependency versions to be specified in init templates using the form `{ name: \\\"the-lib\\\", version: \\\"1.0.0\\\" }`\n- Update init template version compare to be greaterThanAndEqual instead of greaterThan.\n\n### `@typespec/http` New Features\n\n- Update model, operation and template docs for OpenAPI developers\n- Add collection format support for query and header properties: simple, form, ssv, tsv, pipes\n\n### `@typespec/openapi` and `@typespec/openapi3` New Features\n\n- Add new `@info` decorator providing the ability to specify the additional fields from openapi info object.\n- Support collection format support for query and header properties: simple, form, ssv, tsv, pipes\n- Change datetimes encoded with `rfc7231` to produce format `http-date` instead of `date-time-rfc7231` to be inline with [Openapi format registry](https://spec.openapis.org/registry/format/)\n\n## Bug Fixes\n\n### `@typespec/compiler` Bug Fixes\n\n- Fix: Compiler version mismatch error would fire incorrectly\n- Fix some issues with not reporting deprecation on template constraints\n- Fix issue where using augment decorators on spread model properties, enum members or operations extended from parent interface would have no effect.\n- Fix issue where using augment decorator on operation parameters applied to source operation parameter as well.\n- Fix `warn-as-error` configuration in `tspconfig.yaml` was ignored\n- Emit diagnostic for an unresolved metatype property reference\n- Fix crash when `using` argument is not a namespace\n\n### `@typespec/openapi3` Bug Fixes\n\n- Fix: Emit clear diagnostics for empty unions and enum types\n- Fix: Apply `@minItems` and `@maxItems` decorators on model array\n\n### `@typespec/jsonschema`\n\n- Fix: Crash when using interfaces inside a `@jsonSchema` namespace\n\n## Breaking Changes\n\n### `@typespec/compiler` Breaking Changes\n\n- Emitter Framework: `sourceFile` method can return a `Promise`. This allows running async processes when generating the file content, such as a formatter. This results in a potential breaking change if calling `emitSourceFile` where you'll have to add `await` before.\n- The helper function `formatTypeSpec` is now async. Formatter was updated to use prettier 3.0.\n", "file_path": "../../core/docs\\release-notes\\release-2023-08-08.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-08-08.md"}, {"file_content": "---\ntitle: September 2023\n---\n\n# Release Notes September 2023 (2023-09-12)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### `@typespec/compiler` New Features\n\n- Allow library authors to precisely define the visibility of operation templates with new decorators `@parameterVisibility` and `@returnTypeVisibility`, paired with corresponding accessor methods `getParameterVisibility` and `getReturnTypeVisibility`.\n- Add coloring for documentation comments in Visual Studio and Visual Studio Code language extensions.\n- Change yaml parser from `js-yaml` to `yaml`, enabling more precise validation and error reporting in `tspconfig.yaml`\n- Added validation to ensure that properties of a derived model (using `extends`) are compatible with the base model indexer.\n- Export `CompilerOptions` TypeScript type.\n- Report library information when library code crashes during `$onValidate` execution.\n- Diagnostics reported on a node with an `id` property will highlight the id instead of the entire node. For example, if a diagnostic is reported on a `model` type, the model name will be highlighted, instead of the entire model definition.\n\n### `@typespec/http` New Features\n\n- Add new helper method `resolveRequestVisibility` which incorporates settings from new core decorators `@parameterVisibility` and `@returnTypeVisibility`. This replaces the deprecated `getRequestVisibility` helper.\n- Add new helper method `getDefaultVisibilityForVerb` which returns the default visibility for Http verbs.\n- Add validation step to issue a warning when an `operation is` statement does not include route information from the original operation container (`interface` or `namespace`). This helps to prevent unexpected route changes when using operation references.\n- Add validation to prevent runtime errors when `OAuth2Auth` is given invalid `OAuth2Flow` arguments.\n\n### `@typespec/json-schema` New Features\n\n- Support decimal scalar types.\n\n### `@typespec/openapi3` New Features\n\n- Allow library authors to override default Http verb visibility in operation declarations.\n\n### `@typespec/protobuf` New features\n\n- Support `omit-unreachable-types` option.\n- Automatically convert empty operation parameters into a reference to `google.protobuf.Empty` instead of synthesizing an empty model.\n\n### `typespec-vscode` New features\n\n- Add color definition for `@param` tag in documentation comments\n\n## Bug Fixes\n\n### `@typespec/compiler` Bug Fixes\n\n- Fix issue where specifying a directory using the `--config` command line option would search the parent folder hierarchy looking for `tspconfig.yaml`.\n- Fix Stack overflow when a model property references itself.\n- Fix compiler crash when using the alias of a namespace that has decorators.\n- Fix compiler freeze when an invalid token appears between doc comment and type.\n- Fix compiler crash when relating recursive types.\n- Fix typo in format error diagnostic.\n\n### `@typespec/openapi3` Bug Fixes\n\n- Fixed issue where parameters marked with visibility \\\"create\\\" did not appear in a `PATCH` request body.\n- Fixed incorrect usage of `exclusiveMinimum` and `exclusiveMaximum` boolean properties.\n- Use `anyOf` instead of `oneOf` for operations with shared routes and different request or response bodies.\n- Fix handling of `Record<T>` in `model is` and `model extends` statements.\n\n### `@typespec/versioning` Bug Fixes\n\n- Fixed validation in `@typeChangedFrom` for incorrect versioned references.\n\n## Deprecations\n\n### `@typespec/compiler` Deprecations\n\n- The `@deprecated` decorator has been marked as deprecated. Use `#deprecated` directive instead.\n\n### `@typespec/http` Deprecations\n\n- The `getRequestVisibility` helper function is now deprecated. Use `resolveRequestVisibility` or `getDefaultVisibilityForVerb` instead.\n\n## Breaking Changes\n\n### `@typespec/compiler` Breaking Changes\n\n- A semicolon is now required at the end of augment decorator statements. The formatter was already inserting the semicolon, if omitted. For example:\n\n  ```tsp\n  @@doc(MyType.myProperty, \"Documentation for myProperty\");\n  ```\n", "file_path": "../../core/docs\\release-notes\\release-2023-09-12.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-09-12.md"}, {"file_content": "---\ntitle: October 2023\n---\n\n# Release Notes October 2023 (2023-10-11)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### `@typespec/compiler` New Features\n\n- The `never` type is now assignable to all types.\n- Allow constraint decorators (e.g. `@minValue`, `@maxValue`, `@maxLength`, etc.) to be applied to nullable types.\n- Add support for `@returns` and `@errors` doc comment tags.\n  - `@returns`(or `@returnsDoc` decorator) can be used to describe the success return types of an operation.\n  - `@errors`(or `@errorsDoc` decorator) can be used to describe the error return types of an operation.\n- Skip emit of `deprecated` diagnostic for a type reference that is used in a deprecated declaration statement.\n- Improve website performance by removing `decorators` export and importing decorators individually.\n\n### `@typespec/http` New Features\n\n- Add support for `@returns` and `@errors` doc comment tags.\n- Add support for status code ranges for http responses. **Change to API** Http responses can now also return a `HttpStatusCodeRange` object for their status codes.\n- Emit error diagnostic when multiple properties on a response model have the `@statusCode` decorator.\n\n### `@typespec/json-schema` New Features\n\n- Disable folding of serialized yaml if line is above 80 characters.\n\n### `@typespec/openapi` New Features\n\n- Remove `@typespec/rest` as a `peerDependency`.\n- Support Http Status Code ranges.\n- **Breaking Change** Changed namespace from `OpenAPI` to `TypeSpec.OpenAPI`.\n\n### `@typespec/openapi3` New Features\n\n- Remove `@typespec/rest` as a `peerDependency`.\n- Add support for constraints on union types.\n- Add support for `@returns` and `@errors` doc comment tags.\n- Add support for http status code ranges.\n\n### `@typespec/protobuf` New features\n\n- Added support for emitting documentation comments in protobuf specifications.\n\n### `@typespec/rest` New features\n\n- Remove peer dependency on `@typespec/http` library.\n\n## Bug Fixes\n\n### `@typespec/compiler` Bug Fixes\n\n- Fix: Correct handling of hyphens in doc comments.\n- Fix: Colorization of line comments extending into the next line.\n- Fix: Crash when using parentheses in directives.\n- Fix: Allow assigning negative and 0 values to `float64` types.\n- Fix: Return non-zero format code when tsp formatting fails.\n- Fix: Correct formatting of anonymous unions to exclude leading ':' character.\n- Fix: Unions and Enum members are now formatted following the same rules as model properties. An extra line will be added between members if the member is annotated with a decorator, directive or doc comment.\n- Fix: Correct formatting of comments between a directive or doc and its node.\n- Fix: `tsp init` was not creating the `tspconfig.yaml` file for templates that specified it.\n- Fix: `tsp init` will create a placeholder `tspconfig.yaml` file for templates that don't specify an explicit one.\n- Fix: `tsp init` was ignoring the `files` specified in an init template.\n- Fix: Language Server wasn't loading the `tspconfig.yaml` correctly resulting in some options being dropped, like the linter configuration.\n- Fix: Allow `null` to be assigned as a default value.\n- Fix: Using `TypeSpec.Xyz` namespace shouldn't require the `TypeSpec Prefix`.\n\n### `@typespec/openapi3` Bug Fixes\n\n- Fix: Correctly generate discriminated union mapping property with multiple visibilities.\n- Fix: Crash when assigning a numeric default to a union.\n- Fix: Using format `ssv` or `pipes` in `@header` produced an invalid OpenAPI3 schema. It will now change the type to string, ignore the format, and emit a warning diagnostic.\n- Fix: Allow using null as a default value.\n- Fix: Allow use of `@oneOf` on model properties.\n- Fix: Correct representation of CSV format.\n- Fix: Remove incorrect `statusCode` field for operations with shared routes.\n\n### `@typespec/rest` Bug Fixes\n\n- Fix: `@key` can now appear on the base model of a resource.\n\n### `@typespec/versioning` Bug Fixes\n\n- Ensure that use of `@renamedFrom` does not result in duplicate properties on a model.\n\n## Breaking Changes\n\n### `@typespec/http` Breaking Changes\n\n- Http responses can now also return a `HttpStatusCodeRange` object for their status codes. Emitters will need to handle the additional status code content when processing status codes.\n- Emit error diagnostic when multiple properties on a response model have the `@statusCode` decorator.\n\n### `@typespec/openapi` Breaking Changes\n\n- Changed namespace from `OpenAPI` to `TypeSpec.OpenAPI`.\n", "file_path": "../../core/docs\\release-notes\\release-2023-10-11.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-10-11.md"}, {"file_content": "---\ntitle: November 2023\n---\n\n# Release Notes November 2023 (2023-11-07)\n\n:::danger\nThis release contains **breaking changes**\n:::\n\n## New Features\n\n### `@typespec/compiler` New Features\n\n- Add new `unixTimestamp32` scalar to standard library.\n- Emitter Framework: Add hook for handling circular references.\n- Emitter Framework: `TypeEmitter` now supports Tuples.\n- Emit error diagnostic if a model spreads itself within its declaration.\n- Stop showing empty code frame when diagnostic has no location.\n\n### `@typespec/json-schema` New Features\n\n- Add support for `TupleLiteral`.\n\n### `@typespec/openapi3` New Features\n\n- Support `@summary` on data types which emit the JSON Schema `title` property.\n\n### `@typespec/playground` New features\n\n- Add a format button to the playground command bar.\n- Add a notification to the standalone playground when the playground has been saved.\n- Add resizable panes for the editor and output.\n\n## Bug Fixes\n\n### `@typespec/compiler` Bug Fixes\n\n- Fix: `@doc` and jsdoc comments disappear from multi-segment or nested namespaces.\n- Fix: Using `@overload` could result in incorrect `unassignable` type errors.\n- Fix: Referencing a template in an alias might cause augment decorators to not be applied on types referenced in the aliased type.\n- Fix: Issues with removing keys from `RekeyableMap`.\n- Fix: Properties filtered with `@withVisibility` will have their visibility removed. This prevent visibility from being applied twice and rendering invalid models.\n\n### `@typespec/openapi3` Bug Fixes\n\n- Fix: Stops emitting an error when using `@body _: void` in operation parameters and treat it as no body.\n- Fix: Using shared routes would, in some cases, result in a `duplicate-header` error.\n\n## Breaking Changes\n\n### Typescript types breaking change\n\nThe `package.json` files for all packages have been changed to use the standard `types` field instead of the legacy `typesVersions` field to specify types for subpath exports. This means that packages consuming TypeSpec must use the `moduleResolution` setting with `node16` or `nodenext` in their `tsconfig.json`.\nYou might see the following error:\n\n```bash\nCannot find module '@typespec/compiler/testing'. Did you mean to set the 'moduleResolution' option to 'nodenext'\n```\n\nThis can be resolved by changing the following in `tsconfig.json`:\n\n```diff\n-\"moduleResolution\": \"ESNext\",\n+\"moduleResolution\": \"node16\",\n```\n\n### Dropped Support for Node version 16\n\n- All typespec packages now specify node 18 as the minimum version. Consuming packages should no longer use node 16 and update the node specification in the `engines` section of their package.json file appropriately.\n\n### `@typespec/playground` Breaking Changes\n\n- Styles must be imported seperately with `import \\\"@typespec/playground/styles.css\\\";`.\n\n### `@typespec/versioning` Breaking Changes\n\n- Update targets for `@added`, `@removed`, `@renamedFrom`, `@madeOptional` and `@typeChangedFrom` to more clearly communicate where they can be used. Specs that applied these decorators to types that could not be versioned (like `namespace`) will now receive an error diagnostic.\n", "file_path": "../../core/docs\\release-notes\\release-2023-11-07.md", "link_to_file": "file://../../core/docs\\release-notes\\release-2023-11-07.md"}, {"file_content": "---\ntitle: \"Built-in Data types\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n# Data types\n## TypeSpec\n### `Array` {#Array}\n\n\n\n\n```typespec\nmodel Array<T>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | The type of the array elements |\n\n\n\n### `DefaultKeyVisibility` {#DefaultKeyVisibility}\n\nApplies a visibility setting to a collection of properties.\n\n```typespec\nmodel DefaultKeyVisibility<T, Visibility>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | An object whose properties are spread. |\n| Visibility | The visibility to apply to all properties. |\n\n\n\n### `object` {#object}\n\nRepresent a model\n\n```typespec\nmodel object\n```\n\n\n\n### `OmitDefaults` {#OmitDefaults}\n\nRepresents a collection of properties with default values omitted.\n\n```typespec\nmodel OmitDefaults<T>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | An object whose spread property defaults are all omitted. |\n\n\n\n### `OmitProperties` {#OmitProperties}\n\nRepresents a collection of omitted properties.\n\n```typespec\nmodel OmitProperties<T, TKeys>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | An object whose properties are spread. |\n| TKeys | The property keys to omit. |\n\n\n\n### `OptionalProperties` {#OptionalProperties}\n\nRepresents a collection of optional properties.\n\n```typespec\nmodel OptionalProperties<T>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | An object whose spread properties are all optional. |\n\n\n\n### `Record` {#Record}\n\n\n\n\n```typespec\nmodel Record<T>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | The type of the properties |\n\n\n\n### `ServiceOptions` {#ServiceOptions}\n\nService options.\n\n```typespec\nmodel ServiceOptions\n```\n\n\n\n### `UpdateableProperties` {#UpdateableProperties}\n\nRepresents a collection of updateable properties.\n\n```typespec\nmodel UpdateableProperties<T>\n```\n\n#### Template Parameters\n| Name | Description |\n|------|-------------|\n| T | An object whose spread properties are all updateable. |\n\n\n\n### `BytesKnownEncoding` {#BytesKnownEncoding}\n\nKnown encoding to use on bytes\n\n```typespec\nenum BytesKnownEncoding\n```\n\n\n\n### `DateTimeKnownEncoding` {#DateTimeKnownEncoding}\n\nKnown encoding to use on utcDateTime or offsetDateTime\n\n```typespec\nenum DateTimeKnownEncoding\n```\n\n\n\n### `DurationKnownEncoding` {#DurationKnownEncoding}\n\nKnown encoding to use on duration\n\n```typespec\nenum DurationKnownEncoding\n```\n\n\n\n### `boolean` {#boolean}\n\nBoolean with `true` and `false` values.\n\n```typespec\nscalar boolean\n```\n\n\n\n### `bytes` {#bytes}\n\nRepresent a byte array\n\n```typespec\nscalar bytes\n```\n\n\n\n### `decimal` {#decimal}\n\nA decimal number with any length and precision. This represent any `decimal` value possible.\nIt is commonly represented as `BigDecimal` in some languages.\n\n```typespec\nscalar decimal\n```\n\n\n\n### `decimal128` {#decimal128}\n\nA 128-bit decimal number.\n\n```typespec\nscalar decimal128\n```\n\n\n\n### `duration` {#duration}\n\nA duration/time period. e.g 5s, 10h\n\n```typespec\nscalar duration\n```\n\n\n\n### `float` {#float}\n\nA number with decimal value\n\n```typespec\nscalar float\n```\n\n\n\n### `float32` {#float32}\n\nA 32 bit floating point number. (`\u00b15.0 \u00d7 10^\u2212324` to `\u00b11.7 \u00d7 10^308`)\n\n```typespec\nscalar float32\n```\n\n\n\n### `float64` {#float64}\n\nA 32 bit floating point number. (`\u00b11.5 x 10^\u221245` to `\u00b13.4 x 10^38`)\n\n```typespec\nscalar float64\n```\n\n\n\n### `int16` {#int16}\n\nA 16-bit integer. (`-32,768` to `32,767`)\n\n```typespec\nscalar int16\n```\n\n\n\n### `int32` {#int32}\n\nA 32-bit integer. (`-2,147,483,648` to `2,147,483,647`)\n\n```typespec\nscalar int32\n```\n\n\n\n### `int64` {#int64}\n\nA 64-bit integer. (`-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`)\n\n```typespec\nscalar int64\n```\n\n\n\n### `int8` {#int8}\n\nA 8-bit integer. (`-128` to `127`)\n\n```typespec\nscalar int8\n```\n\n\n\n### `integer` {#integer}\n\nA whole number. This represent any `integer` value possible.\nIt is commonly represented as `BigInteger` in some languages.\n\n```typespec\nscalar integer\n```\n\n\n\n### `numeric` {#numeric}\n\nA numeric type\n\n```typespec\nscalar numeric\n```\n\n\n\n### `offsetDateTime` {#offsetDateTime}\n\nA date and time in a particular time zone, e.g. \"April 10th at 3:00am in PST\"\n\n```typespec\nscalar offsetDateTime\n```\n\n\n\n### `plainDate` {#plainDate}\n\nA date on a calendar without a time zone, e.g. \"April 10th\"\n\n```typespec\nscalar plainDate\n```\n\n\n\n### `plainTime` {#plainTime}\n\nA time on a clock without a time zone, e.g. \"3:00 am\"\n\n```typespec\nscalar plainTime\n```\n\n\n\n### `safeint` {#safeint}\n\nAn integer that can be serialized to JSON (`\u22129007199254740991 (\u2212(2^53 \u2212 1))` to `9007199254740991 (2^53 \u2212 1)` )\n\n```typespec\nscalar safeint\n```\n\n\n\n### `string` {#string}\n\nA sequence of textual characters.\n\n```typespec\nscalar string\n```\n\n\n\n### `uint16` {#uint16}\n\nA 16-bit unsigned integer (`0` to `65,535`)\n\n```typespec\nscalar uint16\n```\n\n\n\n### `uint32` {#uint32}\n\nA 32-bit unsigned integer (`0` to `4,294,967,295`)\n\n```typespec\nscalar uint32\n```\n\n\n\n### `uint64` {#uint64}\n\nA 64-bit unsigned integer (`0` to `18,446,744,073,709,551,615`)\n\n```typespec\nscalar uint64\n```\n\n\n\n### `uint8` {#uint8}\n\nA 8-bit unsigned integer (`0` to `255`)\n\n```typespec\nscalar uint8\n```\n\n\n\n### `unixTimestamp32` {#unixTimestamp32}\n\nRepresent a 32-bit unix timestamp datetime with 1s of granularity.\nIt measures time by the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970.\n\n```typespec\nscalar unixTimestamp32\n```\n\n\n\n### `url` {#url}\n\nRepresent a URL string as described by https://url.spec.whatwg.org/\n\n```typespec\nscalar url\n```\n\n\n\n### `utcDateTime` {#utcDateTime}\n\nAn instant in coordinated universal time (UTC)\"\n\n```typespec\nscalar utcDateTime\n```\n\n\n", "file_path": "../../core/docs\\standard-library\\built-in-data-types.md", "link_to_file": "file://../../core/docs\\standard-library\\built-in-data-types.md"}, {"file_content": "---\ntitle: \"Built-in Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n# Built-in Decorators\n## TypeSpec\n### `@deprecated` {#@deprecated}\n\nMark this type as deprecated.\n\nNOTE: This decorator **should not** be used, use the `#deprecated` directive instead.\n\n```typespec\n@deprecated(message: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| message | `valueof scalar string` | Deprecation message. |\n\n#### Examples\n\nUse the `#deprecated` directive instead:\n\n```typespec\n#deprecated \"Use ActionV2\"\nop Action<T>(): T;\n```\n\n\n### `@discriminator` {#@discriminator}\n\nSpecify the property to be used to discriminate this type.\n\n```typespec\n@discriminator(propertyName: valueof string)\n```\n\n#### Target\n\n`union Model | Union`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| propertyName | `valueof scalar string` | The property name to use for discrimination |\n\n#### Examples\n\n```typespec\n@discriminator(\"kind\")\nunion Pet{ cat: Cat, dog: Dog }\n\nmodel Cat {kind: \"cat\", meow: boolean}\nmodel Dog {kind: \"dog\", bark: boolean}\n```\n\n```typespec\n@discriminator(\"kind\")\nmodel Pet{ kind: string }\n\nmodel Cat extends Pet {kind: \"cat\", meow: boolean}\nmodel Dog extends Pet  {kind: \"dog\", bark: boolean}\n```\n\n\n### `@doc` {#@doc}\n\nAttach a documentation string.\n\n```typespec\n@doc(doc: valueof string, formatArgs?: {})\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| doc | `valueof scalar string` | Documentation string |\n| formatArgs | `model {}` | Record with key value pair that can be interpolated in the doc. |\n\n#### Examples\n\n```typespec\n@doc(\"Represent a Pet available in the PetStore\")\nmodel Pet {}\n```\n\n\n### `@encode` {#@encode}\n\nSpecify how to encode the target type.\n\n```typespec\n@encode(encoding: string | EnumMember, encodedAs?: Scalar)\n```\n\n#### Target\n\n`union Scalar | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| encoding | `union string \\| EnumMember` | Known name of an encoding. |\n| encodedAs | `Scalar` | What target type is this being encoded as. Default to string. |\n\n#### Examples\n##### offsetDateTime encoded with rfc7231\n\n\n```tsp\n@encode(\"rfc7231\")\nscalar myDateTime extends offsetDateTime;\n```\n\n##### utcDateTime encoded with unixTimestamp\n\n\n```tsp\n@encode(\"unixTimestamp\", int32)\nscalar myDateTime extends unixTimestamp;\n```\n\n\n### `@error` {#@error}\n\nSpecify that this model is an error type. Operations return error types when the operation has failed.\n\n```typespec\n@error\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\nNone\n\n#### Examples\n\n```typespec\n@error\nmodel PetStoreError {\ncode: string;\nmessage: string;\n}\n```\n\n\n### `@errorsDoc` {#@errorsDoc}\n\nAttach a documentation string to describe the error return types of an operation.\nIf an operation returns a union of success and errors it only describe the errors. See `@errorsDoc` for success documentation.\n\n```typespec\n@errorsDoc(doc: valueof string)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| doc | `valueof scalar string` | Documentation string |\n\n#### Examples\n\n```typespec\n@errorsDoc(\"Returns doc\")\nop get(): Pet | NotFound;\n```\n\n\n### `@format` {#@format}\n\nSpecify a known data format hint for this string type. For example `uuid`, `uri`, etc.\nThis differs from the `@pattern` decorator which is meant to specify a regular expression while `@format` accepts a known format name.\nThe format names are open ended and are left to emitter to interpret.\n\n```typespec\n@format(format: valueof string)\n```\n\n#### Target\n\n`union string | bytes | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| format | `valueof scalar string` | format name. |\n\n#### Examples\n\n```typespec\n@format(\"uuid\")\nscalar uuid extends string;\n```\n\n\n### `@friendlyName` {#@friendlyName}\n\nSpecifies how a templated type should name their instances.\n\n```typespec\n@friendlyName(name: valueof string, formatArgs?: unknown)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| name | `valueof scalar string` | name the template instance should take |\n| formatArgs | `(intrinsic) unknown` | Model with key value used to interpolate the name |\n\n#### Examples\n\n```typespec\n@friendlyName(\"{name}List\", T)\nmodel List<T> {\nvalue: T[];\nnextLink: string;\n}\n```\n\n\n### `@inspectType` {#@inspectType}\n\nA debugging decorator used to inspect a type.\n\n```typespec\n@inspectType(text: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| text | `valueof scalar string` | Custom text to log |\n\n\n\n### `@inspectTypeName` {#@inspectTypeName}\n\nA debugging decorator used to inspect a type name.\n\n```typespec\n@inspectTypeName(text: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| text | `valueof scalar string` | Custom text to log |\n\n\n\n### `@key` {#@key}\n\nMark a model property as the key to identify instances of that type\n\n```typespec\n@key(altName?: valueof string)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| altName | `valueof scalar string` | Name of the property. If not specified, the decorated property name is used. |\n\n#### Examples\n\n```typespec\nmodel Pet {\n@key id: string;\n}\n```\n\n\n### `@knownValues` {#@knownValues}\n\nProvide a set of known values to a string type.\n\n```typespec\n@knownValues(values: Enum)\n```\n\n#### Target\n\n`union string | numeric | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| values | `Enum` | Known values enum. |\n\n#### Examples\n\n```typespec\n@knownValues(KnownErrorCode)\nscalar ErrorCode extends string;\n\nenum KnownErrorCode {\nNotFound,\nInvalid,\n}\n```\n\n\n### `@list` {#@list}\n\nMark this operation as a `list` operation for resource types.\n\n```typespec\n@list(listedType?: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| listedType | `Model` | Optional type of the items in the list. |\n\n\n\n### `@maxItems` {#@maxItems}\n\nSpecify the maximum number of items this array should have.\n\n```typespec\n@maxItems(value: valueof integer)\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar integer` | Maximum number |\n\n#### Examples\n\n```typespec\n@maxItems(5)\nmodel Endpoints is string[];\n```\n\n\n### `@maxLength` {#@maxLength}\n\nSpecify the maximum length this string type should be.\n\n```typespec\n@maxLength(value: valueof integer)\n```\n\n#### Target\n\n`union string | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar integer` | Maximum length |\n\n#### Examples\n\n```typespec\n@maxLength(20)\nscalar Username extends string;\n```\n\n\n### `@maxValue` {#@maxValue}\n\nSpecify the maximum value this numeric type should be.\n\n```typespec\n@maxValue(value: valueof numeric)\n```\n\n#### Target\n\n`union numeric | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar numeric` | Maximum value |\n\n#### Examples\n\n```typespec\n@maxValue(200)\nscalar Age is int32;\n```\n\n\n### `@maxValueExclusive` {#@maxValueExclusive}\n\nSpecify the maximum value this numeric type should be, exclusive of the given\nvalue.\n\n```typespec\n@maxValueExclusive(value: valueof numeric)\n```\n\n#### Target\n\n`union numeric | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar numeric` | Maximum value |\n\n#### Examples\n\n```typespec\n@maxValueExclusive(50)\nscalar distance is float64;\n```\n\n\n### `@minItems` {#@minItems}\n\nSpecify the minimum number of items this array should have.\n\n```typespec\n@minItems(value: valueof integer)\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar integer` | Minimum number |\n\n#### Examples\n\n```typespec\n@minItems(1)\nmodel Endpoints is string[];\n```\n\n\n### `@minLength` {#@minLength}\n\nSpecify the minimum length this string type should be.\n\n```typespec\n@minLength(value: valueof integer)\n```\n\n#### Target\n\n`union string | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar integer` | Minimum length |\n\n#### Examples\n\n```typespec\n@minLength(2)\nscalar Username extends string;\n```\n\n\n### `@minValue` {#@minValue}\n\nSpecify the minimum value this numeric type should be.\n\n```typespec\n@minValue(value: valueof numeric)\n```\n\n#### Target\n\n`union numeric | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar numeric` | Minimum value |\n\n#### Examples\n\n```typespec\n@minValue(18)\nscalar Age is int32;\n```\n\n\n### `@minValueExclusive` {#@minValueExclusive}\n\nSpecify the minimum value this numeric type should be, exclusive of the given\nvalue.\n\n```typespec\n@minValueExclusive(value: valueof numeric)\n```\n\n#### Target\n\n`union numeric | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| value | `valueof scalar numeric` | Minimum value |\n\n#### Examples\n\n```typespec\n@minValueExclusive(0)\nscalar distance is float64;\n```\n\n\n### `@overload` {#@overload}\n\nSpecify this operation is an overload of the given operation.\n\n```typespec\n@overload(overloadbase: Operation)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| overloadbase | `Operation` | Base operation that should be a union of all overloads |\n\n#### Examples\n\n```typespec\nop upload(data: string | bytes, @header contentType: \"text/plain\" | \"application/octet-stream\"): void;\n@overload(upload)\nop uploadString(data: string, @header contentType: \"text/plain\" ): void;\n@overload(upload)\nop uploadBytes(data: bytes, @header contentType: \"application/octet-stream\"): void;\n```\n\n\n### `@parameterVisibility` {#@parameterVisibility}\n\nSets which visibilities apply to parameters for the given operation.\n\n```typespec\n@parameterVisibility(...visibilities: valueof string[])\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| visibilities | `valueof model string[]` | List of visibility strings which apply to this operation. |\n\n\n\n### `@pattern` {#@pattern}\n\nSpecify the the pattern this string should respect using simple regular expression syntax.\nThe following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.\nAdvanced features like look-around, capture groups, and references are not supported.\n\n```typespec\n@pattern(pattern: valueof string)\n```\n\n#### Target\n\n`union string | bytes | ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| pattern | `valueof scalar string` | Regular expression. |\n\n#### Examples\n\n```typespec\n@pattern(\"[a-z]+\")\nscalar LowerAlpha extends string;\n```\n\n\n### `@projectedName` {#@projectedName}\n\nProvide an alternative name for this type.\n\n```typespec\n@projectedName(targetName: valueof string, projectedName: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| targetName | `valueof scalar string` | Projection target |\n| projectedName | `valueof scalar string` | Alternative name |\n\n#### Examples\n\n```typespec\nmodel Certificate {\n@projectedName(\"json\", \"exp\")\nexpireAt: int32;\n}\n```\n\n\n### `@returnsDoc` {#@returnsDoc}\n\nAttach a documentation string to describe the successful return types of an operation.\nIf an operation returns a union of success and errors it only describe the success. See `@errorsDoc` for error documentation.\n\n```typespec\n@returnsDoc(doc: valueof string)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| doc | `valueof scalar string` | Documentation string |\n\n#### Examples\n\n```typespec\n@returnsDoc(\"Returns doc\")\nop get(): Pet | NotFound;\n```\n\n\n### `@returnTypeVisibility` {#@returnTypeVisibility}\n\nSets which visibilities apply to the return type for the given operation.\n\n```typespec\n@returnTypeVisibility(...visibilities: valueof string[])\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| visibilities | `valueof model string[]` | List of visibility strings which apply to this operation. |\n\n\n\n### `@secret` {#@secret}\n\nMark this string as a secret value that should be treated carefully to avoid exposure\n\n```typespec\n@secret\n```\n\n#### Target\n\n`union string | ModelProperty`\n\n#### Parameters\nNone\n\n#### Examples\n\n```typespec\n@secret\nscalar Password is string;\n```\n\n\n### `@service` {#@service}\n\nMark this namespace as describing a service and configure service properties.\n\n```typespec\n@service(options?: ServiceOptions)\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| options | `model ServiceOptions` | Optional configuration for the service. |\n\n#### Examples\n\n```typespec\n@service\nnamespace PetStore;\n```\n\n##### Setting service title\n\n```typespec\n@service({title: \"Pet store\"})\nnamespace PetStore;\n```\n\n##### Setting service version\n\n```typespec\n@service({version: \"1.0\"})\nnamespace PetStore;\n```\n\n\n### `@summary` {#@summary}\n\nTypically a short, single-line description.\n\n```typespec\n@summary(summary: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| summary | `valueof scalar string` | Summary string. |\n\n#### Examples\n\n```typespec\n@summary(\"This is a pet\")\nmodel Pet {}\n```\n\n\n### `@tag` {#@tag}\n\nAttaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a TypeSpec element.\n\n```typespec\n@tag(tag: valueof string)\n```\n\n#### Target\n\n`union Namespace | Interface | Operation`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| tag | `valueof scalar string` | Tag value |\n\n\n\n### `@visibility` {#@visibility}\n\nIndicates that a property is only considered to be present or applicable (\"visible\") with\nthe in the given named contexts (\"visibilities\"). When a property has no visibilities applied\nto it, it is implicitly visible always.\n\nAs far as the TypeSpec core library is concerned, visibilities are open-ended and can be arbitrary\nstrings, but  the following visibilities are well-known to standard libraries and should be used\nwith standard emitters that interpret them as follows:\n\n- \"read\": output of any operation.\n- \"create\": input to operations that create an entity..\n- \"query\": input to operations that read data.\n- \"update\": input to operations that update data.\n- \"delete\": input to operations that delete data.\n\nSee also: [Automatic visibility](https://microsoft.github.io/typespec/standard-library/http/operations#automatic-visibility)\n\n```typespec\n@visibility(...visibilities: valueof string[])\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| visibilities | `valueof model string[]` | List of visibilities which apply to this property. |\n\n#### Examples\n\n```typespec\nmodel Dog {\n// the service will generate an ID, so you don't need to send it.\n@visibility(\"read\") id: int32;\n// the service will store this secret name, but won't ever return it\n@visibility(\"create\", \"update\") secretName: string;\n// the regular name is always present\nname: string;\n}\n```\n\n\n### `@withDefaultKeyVisibility` {#@withDefaultKeyVisibility}\n\nSet the visibility of key properties in a model if not already set.\n\n```typespec\n@withDefaultKeyVisibility(visibility: valueof string)\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| visibility | `valueof scalar string` | The desired default visibility value. If a key property already has a `visibility` decorator then the default visibility is not applied. |\n\n\n\n### `@withOptionalProperties` {#@withOptionalProperties}\n\nReturns the model with required properties removed.\n\n```typespec\n@withOptionalProperties\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\nNone\n\n\n\n### `@withoutDefaultValues` {#@withoutDefaultValues}\n\nReturns the model with any default values removed.\n\n```typespec\n@withoutDefaultValues\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\nNone\n\n\n\n### `@withoutOmittedProperties` {#@withoutOmittedProperties}\n\nReturns the model with the given properties omitted.\n\n```typespec\n@withoutOmittedProperties(omit: string | Union)\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| omit | `union string \\| Union` | List of properties to omit |\n\n\n\n### `@withUpdateableProperties` {#@withUpdateableProperties}\n\nReturns the model with non-updateable properties removed.\n\n```typespec\n@withUpdateableProperties\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\nNone\n\n\n\n### `@withVisibility` {#@withVisibility}\n\nRemoves properties that are not considered to be present or applicable\n(\"visible\") in the given named contexts (\"visibilities\"). Can be used\ntogether with spread to effectively spread only visible properties into\na new model.\n\nSee also: [Automatic visibility](https://microsoft.github.io/typespec/standard-library/http/operations#automatic-visibility)\n\nWhen using an emitter that applies visibility automatically, it is generally\nnot necessary to use this decorator.\n\n```typespec\n@withVisibility(...visibilities: valueof string[])\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n| Name | Type | Description |\n|------|------|-------------|\n| visibilities | `valueof model string[]` | List of visibilities which apply to this property. |\n\n#### Examples\n\n```typespec\nmodel Dog {\n@visibility(\"read\") id: int32;\n@visibility(\"create\", \"update\") secretName: string;\nname: string;\n}\n\n// The spread operator will copy all the properties of Dog into DogRead,\n// and @withVisibility will then remove those that are not visible with\n// create or update visibility.\n//\n// In this case, the id property is removed, and the name and secretName\n// properties are kept.\n@withVisibility(\"create\", \"update\")\nmodel DogCreateOrUpdate {\n...Dog;\n}\n\n// In this case the id and name properties are kept and the secretName property\n// is removed.\n@withVisibility(\"read\")\nmodel DogRead {\n...Dog;\n}\n```\n\n", "file_path": "../../core/docs\\standard-library\\built-in-decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\built-in-decorators.md"}, {"file_content": "---\ntitle: Discriminated types\n---\n\nTypeSpec can express unions and inheritance. However, when sending types over the wire many languages need a way to discriminate between the various union variants or models in an inheritance hierarchy.\n\nTypeSpec provide the [`@discriminator` decorator](./built-in-decorators#@discriminator) to be able to help with this pattern.\n\n### Using polymorphism\n\n#### `string` discriminator\n\n```typespec\n@discriminator(\"kind\")\nmodel Pet {\n  name: string;\n  weight?: float32;\n}\nmodel Cat extends Pet {\n  kind: \"cat\";\n  meow: int32;\n}\nmodel Dog extends Pet {\n  kind: \"dog\";\n  bark: string;\n}\n```\n\n#### `enum` discriminator\n\n```typespec\nenum PetKind {\n  cat,\n  dog,\n}\n\n@discriminator(\"kind\")\nmodel Pet {\n  kind: PetKind;\n  name: string;\n  weight?: float32;\n}\nmodel Cat extends Pet {\n  kind: PetKind.cat;\n  meow: int32;\n}\nmodel Dog extends Pet {\n  kind: PetKind.dog;\n  bark: string;\n}\n```\n\n#### Nested discriminator\n\n```tsp\n@discriminator(\"kind\")\nmodel Pet {\n  kind: string;\n  name: string;\n  weight?: float32;\n}\n\n@discriminator(\"breed\")\nmodel Cat extends Pet {\n  kind: \"cat\";\n  breed: string;\n  meow: int32;\n}\n\n@discriminator(\"breed\")\nmodel Siamese extends Cat {\n  breed: \"siamese\";\n}\n\n@discriminator(\"breed\")\nmodel Bengal extends Cat {\n  breed: \"bengal\";\n}\n\nmodel Dog extends Pet {\n  kind: \"dog\";\n  bark: string;\n}\n```\n\n### Using unions\n\n```typespec\n@discriminator(\"kind\")\nunion Pet {\n  cat: Cat,\n  dog: Dog,\n}\n\nmodel Cat {\n  kind: \"cat\";\n  meow: int32;\n}\n\nmodel Dog {\n  kind: \"dog\";\n  bark: string;\n}\n```\n", "file_path": "../../core/docs\\standard-library\\discriminated-types.md", "link_to_file": "file://../../core/docs\\standard-library\\discriminated-types.md"}, {"file_content": "---\nid: projected-names\ntitle: Projected names\n---\n\n# Projected Names\n\nThere is some cases where the name you have in TypeSpec might differ from the name over the wire or for a certain language.\n\n## Known targets\n\nList of known targets.\n\n- Wire:\n  - `json`: Configure JSON representation of data\n  - `xml`: Configure XML representation of data\n- Language:\n  - `csharp`: Configure C# generated code\n  - `java`: Configure Java generated code\n  - `python`: Configure python generated code\n  - `javascript`: Configure javascript generated code\n  - `swift` : Configure swift generated code\n  - `c` : Configure C generated code\n- Type:\n  - `client`: Configure output for the client\n  - `server`: Configure output for the server\n\n## Update name for a given target\n\n### With decorator\n\nTo update the name of a TypeSpec entity you can use the `@projectedName` decorator. This decorator takes 2 parameters:\n\n- `string` target name. See [known targets](#known-targets)\n- `string` projected name. Whatever the name should be in the given target.\n\nExample:\n\n```typespec\nmodel Foo {\n  // Specify that when serializing to JSON `expireAt` property should be named `exp`\n  @projectedName(\"json\", \"exp\")\n  expireAt: string;\n}\n```\n\n### With projection\n\nThe decorator is just a syntax sugar for the `target` projection behind the scenes. In more complex cases you might want to just implement the projection manually.\n\n```typespec\nmodel Foo {\n  expireAt: string;\n}\n\nprojection Foo#target {\n  to(targetName) {\n    if targetName == \"json\" {\n      self::rename(\"exp\");\n    };\n  }\n}\n```\n\n## Example\n\n```typespec\nmodel CertificateAttributes {\n  @projectedName(\"json\", \"nbf\")\n  @projectedName(\"csharp\", \"ValidAfter\")\n  notBefore: int32;\n\n  @projectedName(\"json\", \"exp\")\n  expires: int32;\n\n  @projectedName(\"client\", \"createdAt\")\n  created: int32;\n\n  updated: int32;\n}\n```\n\n<table>\n<thead>\n<tr>\n<th>Json</th>\n<th>Typescript</th>\n<th>CSharp</th>\n</tr>\n</thead>\n<tr>\n<td>When serialized to Json property use the json projected name</td>\n<td>Typescript didn't provide any projected name so it keep the model as it is.</td>\n<td>Model uses the `csharp` projected names and keeps the reference to the JSON name in JsonProperty</td>\n</tr>\n<tr>\n<td>\n\n```json\n{\n  \"nbf\": 1430344421,\n  \"exp\": 2208988799,\n  \"created\": 1493938289,\n  \"updated\": 1493938291\n}\n```\n\n</td>\n<td>\n\n```ts\ninterface Attributes {\n  notBefore: number;\n  expires: number;\n  createdAt: number;\n  updated: number;\n}\n```\n\n</td>\n\n<td>\n\n```cs\nclass CertificateAttributes\n{\n  [JsonProperty(\"nbf\")]\n  public int ValidAfter {get; set;}\n\n  [JsonProperty(\"exp\")]\n  public int Expires {get; set;}\n\n  [JsonProperty(\"created\")]\n  public int CreatedAt {get; set;}\n\n  public int Updated {get; set;}\n}\n```\n\n</td>\n</tr>\n</table>\n", "file_path": "../../core/docs\\standard-library\\projected-names.md", "link_to_file": "file://../../core/docs\\standard-library\\projected-names.md"}, {"file_content": "---\ntitle: Authentication\n---\n\n# Configure Http Authentication\n\nNotes:\n\n- Authentication right now can ONLY be configured at the service level.\n\n## Configure\n\nAuthentication can be configured using the `@useAuth` decorator on the service namespace. The decorator accept a few options:\n\n- A security scheme (see options [here](https://github.com/microsoft/typespec/blob/main/packages/http/lib/auth.tsp)). This means this is the security scheme to use to authenticate this service.\n\n```typespec\n@useAuth(Auth1)\n```\n\n- A tuple of security scheme. This means ALL the different security schemes of the tuple MUST be used together to authenticate this service.\n\n```typespec\n// Use BOTH Auth1 or Auth2\n@useAuth([Auth1, Auth2])\n```\n\n- A union of security scheme. This means EITHER of the security schemes can be used to authenticate this service\n\n```typespec\n// Use EITHER Auth1 or Auth2\n@useAuth(Auth1 | Auth2)\n```\n\n- A union of tuple security scheme. This means EITHER of the security groups schemes can be used to authenticate this service\n\n```typespec\n// Use EITHER (Auth1 AND Auth2) OR Auth3\n@useAuth([Auth1, Auth2] | Auth3)\n```\n\n## Available security schemes\n\nModels can be found in https://github.com/microsoft/typespec/blob/main/packages/http/lib/auth.tsp\n\n### `BasicAuth`\n\nBasic authentication is a simple authentication scheme built into the HTTP protocol.\nThe client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password.\nFor example, to authorize as demo / p@55w0rd the client would send\n\n```\n Authorization: Basic ZGVtbzpwQDU1dzByZA==\n```\n\n```typespec\n@useAuth(BasicAuth)\n```\n\n### `BearerAuth`\n\nBearer authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens.\nThe name \u201cBearer authentication\u201d can be understood as \u201cgive access to the bearer of this token.\u201d The bearer token is a cryptic string, usually generated by the server in response to a login request.\nThe client must send this token in the Authorization header when making requests to protected resources:\n\n```\n  Authorization: Bearer <token>\n```\n\n```typespec\n@useAuth(BearerAuth)\n```\n\n### `ApiKeyAuth<TLocation extends ApiKeyLocation, TName extends string>`\n\nAn API key is a token that a client provides when making API calls. The key can be sent in the query string:\n\n```\nGET /something?api_key=abcdef12345\n```\n\n```typespec\n@useAuth(ApiKeyAuth<ApiKeyLocation.query, \"api_key\">)\n```\n\nor as a request header\n\n```\nGET /something HTTP/1.1\nX-API-Key: abcdef12345\n```\n\n```typespec\n@useAuth(ApiKeyAuth<ApiKeyLocation.header, \"X-API-KEY\">)\n```\n\nor as a cookie\n\n```\nGET /something HTTP/1.1\nCookie: X-API-KEY=abcdef12345\n```\n\n```typespec\n@useAuth(ApiKeyAuth<ApiKeyLocation.cookie, \"X-API-KEY\">)\n```\n\n### `OAuth2Auth<TFlows extends OAuth2Flow[]>`\n\nOAuth 2.0 is an authorization protocol that gives an API client limited access to user data on a web server.\nOAuth relies on authentication scenarios called flows, which allow the resource owner (user) to share the protected content from the resource server without sharing their credentials.\nFor that purpose, an OAuth 2.0 server issues access tokens that the client applications can use to access protected resources on behalf of the resource owner.\nFor more information about OAuth 2.0, see oauth.net and RFC 6749.\n", "file_path": "../../core/docs\\standard-library\\http\\authentication.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\authentication.md"}, {"file_content": "---\ntitle: Cheat sheet\n---\n\n## Verb\n\n| Feature          | Example                     |\n| ---------------- | --------------------------- |\n| Get operation    | `@get op read(): void`      |\n| Put operation    | `@put op set(): void`       |\n| Post operation   | `@post op add(): void`      |\n| Patch operation  | `@patch op patch(): void`   |\n| Delete operation | `@delete op delete(): void` |\n| Head operation   | `@head op read(): void`     |\n\n## Routing\n\n| Feature                            | Example                                                                                    |\n| ---------------------------------- | ------------------------------------------------------------------------------------------ |\n| Fixed route                        | `@route(\"/pets\") op list(): Pet[]`                                                         |\n| Route with path parameter          | `@route(\"/pets/{petId}\") op getPet(petId: string): Pet`                                    |\n| Route with multiple path parameter | `@route(\"/stores/{storeId}/pets/{petId}/\") op getPet(storeId: string, petId: string): Pet` |\n\n## Data types\n\n| Feature                 | Example                                     |\n| ----------------------- | ------------------------------------------- |\n| Request header          | `op read(@header traceparent: string): Pet` |\n| Response header         | `op read(): {@header eTag: string, ...Pet}` |\n| Query parameter         | `op list(@query filter: string): Pet[]`     |\n| Explicit body parameter | `op add(@body pet: Pet): void`              |\n| Implicit body parameter | `op add(...Pet): void`                      |\n| Status code             | `op read(): {@statusCode _: 200, ...Pet}`   |\n\n## Server\n\n| Feature       | Example                                                                               |\n| ------------- | ------------------------------------------------------------------------------------- |\n| Single        | `@server(\"https://example.com\", \"Example 1 endpoint\")`                                |\n| Multiple      | `@server(\"https://example1.com\", \"E1\") @server(\"https://example2.com\", \"E2\")`         |\n| Parameterized | `@server(\"https://{region}.example.com\", \"Region scoped endpoint\", {region: string})` |\n\n## Authentication\n\n_Details: [Authentication](./authentication.md)_\n\n| Feature         | Example                                     |\n| --------------- | ------------------------------------------- |\n| Basic auth      | `@useAuth(BasicAuth)`                       |\n| Bearer auth     | `@useAuth(BearerAuth)`                      |\n| Api key auth    | `@useAuth(ApiKeyAuth<\"header\", \"Api-Key\">)` |\n| OAuth2 key auth | `@useAuth(OAuth2Flow<[MyScope]>)`           |\n", "file_path": "../../core/docs\\standard-library\\http\\cheat-sheet.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\cheat-sheet.md"}, {"file_content": "---\ntitle: Content types\n---\n\n## Default behavior\n\nContent type is assumed to be `application/json` by default regardless of the type of the request or response body.\n\n**Examples:**\n\n```typespec\nop download(): bytes; // Returns a json string with the bytes serialized as a base64.\nop getContent(): string; // Returns a json string\nop getPet(): {\n  // Json object with a name property.\n  name: string;\n};\n```\n\n## Specify content type\n\nThe content type for an operation can be specified by including a header parameter named `contentType`.\n\n#### Request content type\n\n```typespec\nop uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\n```\n\n#### Response content type:\n\n```typespec\nop downloadImage(): {\n  @header contentType: \"image/png\";\n  @body image: bytes;\n};\n```\n\n#### Multiple content types\n\nIf there is multiples content types for the same body, they can be specified using a union of string.\n\n```typespec\nop uploadImage(@header contentType: \"image/png\" | \"image/jpeg\", @body image: bytes): void;\n```\n\n## Content type negotiation\n\nThere could be cases where you might the same endpoint to return different content depending on the content type requested. This can be achieved in 2 ways:\n\n- using shared routes where different content response is represented as a different operation that share the same endpoint\n- using overloads where each different content response is an overload.\n\nFor example assuming there is an api that lets you download the avatar as a `png` or `jpeg` which is decided by what `Accept` header is sent.\n\n### Option 1: Using shared route\n\n```tsp\nmodel PngImage {\n  @header contentType: \"image/png\";\n  @body image: bytes;\n}\n\nmodel JpegImage {\n  @header contentType: \"image/jpeg\";\n  @body image: bytes;\n}\n\n@route(\"/avatar\")\n@sharedRoute\nop getAvatarAsPng(@header accept: \"image/png\"): PngImage;\n\n@route(\"/avatar\")\n@sharedRoute\nop getAvatarAsJpeg(@header accept: \"image/jpeg\"): JpegImage;\n```\n\n### Option 2: Using overload\n\n```tsp\nmodel PngImage {\n  @header contentType: \"image/png\";\n  @body image: bytes;\n}\n\nmodel JpegImage {\n  @header contentType: \"image/jpeg\";\n  @body image: bytes;\n}\n\n@route(\"/avatar\")\nop getAvatar(@header accept: \"image/png\" | \"image/jpeg\"): PngImage | JpegImage;\n\n@overload(getAvatar)\nop getAvatarAsPng(@header accept: \"image/png\"): PngImage;\n\n@overload(getAvatar)\nop getAvatarAsJpeg(@header accept: \"image/jpeg\"): JpegImage;\n```\n", "file_path": "../../core/docs\\standard-library\\http\\content-types.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\content-types.md"}, {"file_content": "---\ntitle: Encoding of types\n---\n\nThis document describe how the http library interpret TypeSpec built-in types and how to configure\n\n## `bytes`\n\n**Default behavior:**\n\n- `bytes` are serialized as `base64` when used inside a model serialized as JSON\n- In request or response body it represent a binary payload.\n\n:::note\nThis behavior is only a specification and MUST be respected by the emitter. The http library DOES NOT automatically apply the `@encode(\"base64\")` when used inside a JSON model.\n:::\n\nUse `@encode` to configure\n\n```tsp\nmodel Pet {\n  icon: bytes; // Serialize as base64\n  @encode(BytesKnownEncoding.base64url) // Serialize as base64url\n  other: bytes;\n}\n\nop read(): Pet;\n\nop download(): bytes; // Return application/octet-stream\nop upload(@body data: bytes): void; // Accept application/octet-stream\n```\n\n## `utcDatetime` and `offsetDateTime`\n\n**Default behavior:**\n\n- Encoded as `rfc7231` when used in a header\n- Encoded as `rfc3339` otherwise.\n\n:::note\nThis behavior is only a specification and MUST be respected by the emitter. The http library DOES NOT automatically apply the `@encode(\"rfc7231\")` on `utcDatetime` and `offsetDateTime` when used in a header.\n:::\n\nUse `@encode` to configure.\n\n<table>\n<tr><td>TypeSpec</td><td>Example payload</td></tr>\n<tr>\n<td>\n\n```tsp\nmodel User {\n  // Headers\n  @header(\"Created-At\") createdAtHeader: utcDateTime;\n\n  @header(\"Created-At-Rfc3339\")\n  @encode(DateTimeKnownEncoding.rfc3339)\n  createdAtHeaderRfc3339Encoding: utcDateTime;\n\n  // In Json payload\n  createdAt: utcDateTime; // rfc3339\n\n  updatedAt: offsetDateTime; // rfc3339\n\n  @encode(DateTimeKnownEncoding.rfc7231)\n  createdAtPretty: utcDateTime; // rfc7231\n\n  @encode(DateTimeKnownEncoding.rfc7231)\n  updatedAtPretty: offsetDateTime; // rfc7231\n\n  @encode(DateTimeKnownEncoding.unixTimestamp, int32)\n  createdAtUnix: utcDateTime; // unixTime\n}\n```\n\n</td>\n<td>\n\n```yaml\nCreated-At: Wed, 12 Oct 2022 07:20:50 GMT\nCreated-At-Rfc3339: 2022-10-12T07:20:50.52Z\n```\n\n```json\n{\n  \"createdAt\": \"2022-10-12T07:20:50.52Z\",\n  \"updatedAt\": \"2022-10-25T07:20:50.52+07:00\",\n  \"createdAtPretty\": \"Wed, 12 Oct 2022 07:20:50 GMT\",\n  \"updatedAtPretty\": \"Tue, 25 Oct 2022 00:20:50 GMT\",\n  \"createdAtUnix\": 1665559250520\n}\n```\n\n</td>\n</tr>\n</table>\n\n## `duration`\n\n**Default behavior:**\n\n- Encoded as `ISO8601`\n\nUse `@encode` to configure.\n\n<table>\n<tr><td>TypeSpec</td><td>Example payload</td></tr>\n<tr>\n<td>\n\n```tsp\nmodel User {\n  runtime: duration; // ISO8601\n\n  @encode(DurationKnownEncoding.seconds, int32)\n  runtimeInSecondsInt: duration; // in seconds as an int32\n\n  @encode(DurationKnownEncoding.seconds, float32)\n  runtimeInSecondsFloat: duration; // in seconds as a float32\n}\n```\n\n</td>\n<td>\n\n```json\n{\n  \"runtime\": \"PT5M5S\",\n  \"runtimeInSecondsInt\": \"305\",\n  \"runtimeInSecondsFloat\": \"305.0\"\n}\n```\n\n</td>\n</tr>\n</table>\n", "file_path": "../../core/docs\\standard-library\\http\\encoding.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\encoding.md"}, {"file_content": "---\ntitle: Operations\n---\n\n# Http Operations\n\n## Operation verb\n\n**Default behavior:**\n\n- If `@post` operation has a request body\n- `@get` otherwise\n\n**Configure:**\n\nYou can use one of the [verb decorators](./reference/decorators.md): `@get`, `@put`, etc.\n\n## Route\n\nAn operation route can be specified using the `@route` decorator.\n\n```typespec\n@route(\"/pets\") op list(): Pet[];\n```\n\nRoute path parameters are declared using `{}`. Providing `@path` on the model property with the matching name is optional.\n\n```typespec\n@route(\"/pets/{petId}\") op get(petId: string): Pet;\n// or explicit @path\n@route(\"/pets/{petId}\") op get(@path petId: string): Pet;\n```\n\nRoute can be specified on a parent namespace or interface. In that case all the operations, interfaces and namespaces underneath will be prefixed with it.\n\n```typespec\n@route(\"/store\")\nnamespace PetStore {\n  op hello(): void; // `/store`\n  @route(\"ping\") op ping(): void; // `/store/ping`\n\n  @route(\"/pets\")\n  interface Pets {\n    list(): Pet[]; // `/store/pets`\n    @route(\"{petId}\") read(petId: string): Pet; // `/store/pets/{petId}`\n  }\n}\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): Pet[];\n  op read(@path petId: int32): Pet;\n}\n```\n\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\n\n```typespec\n@route(\"/pets/{petId}/toys\")\nnamespace PetToys {\n  op list(@path petId: int32): Toy[];\n}\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): {\n    @body pets: Pet[];\n  };\n  op read(@path petId: int32): {\n    @body pet: Pet;\n  };\n  @post\n  op create(@body pet: Pet): {};\n}\n```\n\nNote that in the absence of explicit `@body`:\n\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\n2. The set of properties of the return model that are not marked @header or @statusCode form the response body.\n3. If the return type is not a model, then it defines the response body.\n\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\n\nSee also [metadata](./operations.md#metadata) for more advanced details.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  @post\n  op create(...Pet): {};\n}\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): {\n    @body pets: Pet[];\n  };\n  op read(@path petId: int32, @header ifMatch?: string): {\n    @header eTag: string;\n    @body pet: Pet;\n  };\n  @post\n  op create(@body pet: Pet): {};\n}\n```\n\n## Status codes\n\n**Default behavior:**\n\n- `4xx,5xx` if response is marked with `@error`\n- `200` otherwise\n\n**Configure:**\n\nUse the `@header` decorator on a property named `statusCode` to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  @error\n  model Error {\n    code: string;\n  }\n\n  op list(@query skip: int32, @query top: int32): {\n    @body pets: Pet[]; // statusCode: 200 Implicit\n  };\n  op read(@path petId: int32, @header ifMatch?: string): {\n    @statusCode statusCode: 200;\n    @header eTag: string;\n    @body pet: Pet;\n  } | {\n    @statusCode statusCode: 404;\n  };\n  op create(@body pet: Pet): {\n    @statusCode statusCode: 204;\n  } | Error; //statusCode: 4xx,5xx as Error use `@error` decorator\n}\n```\n\n## Content type\n\n[See content types docs](./content-types.md)\n\n### Default behavior\n\nDepending on the body of the operation http library will assume different content types:\n\n- `bytes`: `application/octet-stream`\n- `string`: `text/plain`\n- an `object` or anything else: `application/json`\n\n**Examples:**\n\n```typespec\nop download(): bytes; // response content type is application/octet-stream\nop upload(@body file: bytes): void; // request content type is application/octet-stream\nop getContent(): string; // response content type is text/plain\nop getPet(): {\n  // response content type is application/json\n  name: string;\n};\n```\n\n### Specify content type\n\nThe content type for an operation can be specified by including a header parameter named `contentType`.\n\n#### Request content type\n\n```typespec\nop uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\n```\n\n#### Response content type:\n\n```typespec\nop downloadImage(): {\n  @header contentType: \"image/png\";\n  @body image: bytes;\n};\n```\n\n#### Multiple content types\n\n```typespec\nop uploadImage(@header contentType: \"image/png\" | \"image/jpeg\", @body image: bytes): void;\n```\n\n## Built-in response shapes\n\nSince status codes are so common for REST APIs, TypeSpec comes with some built-in types for common status codes so you don't need to declare status codes so frequently.\n\nThere is also a `Body<T>` type, which can be used as a shorthand for { @body body: T } when an explicit body is required.\n\nLets update our sample one last time to use these built-in types:\n\n```typespec\nmodel ETag {\n  @header eTag: string;\n}\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): OkResponse & Body<Pet[]>;\n  op read(@path petId: int32, @header ifMatch?: string): (OkResponse &\n    Body<Pet> &\n    ETag) | NotFoundResponse;\n  @post\n  op create(...Pet): NoContentResponse;\n}\n```\n\nNote that the default status code is 200 for non-empty bodies and 204 for empty bodies. Similarly, explicit `Body<T>` is not required when T is known to be a model. So the following terser form is equivalent:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): Pet[];\n  op read(@path petId: int32, @header ifMatch?: string): (Pet & ETag) | NotFoundResponse;\n  @post\n  op create(...Pet): {};\n}\n```\n\nFinally, another common style is to make helper response types that are\nshared across a larger service definition. In this style, you can be\nentirely explicit while also keeping operation definitions concise.\n\nFor example, we could write :\n\n```typespec\nmodel ListResponse<T> {\n  ...OkResponse;\n  ...Body<T[]>;\n}\n\nmodel ReadSuccessResponse<T> {\n  ...OkResponse;\n  ...ETag;\n  ...Body<T>;\n}\n\nalias ReadResponse<T> = ReadSuccessResponse<T> | NotFoundResponse;\n\nmodel CreateResponse {\n  ...NoContentResponse;\n}\n\n@route(\"/pets\")\nnamespace Pets {\n  op list(@query skip: int32, @query top: int32): ListResponse<Pet>;\n  op read(@path petId: int32, @header ifMatch?: string): ReadResponse<Pet>;\n  @post\n  op create(...Pet): CreateResponse;\n}\n```\n\n## Automatic visibility\n\nThe `@typespec/rest` library understands the following well-known [visibilities](../../standard-library/built-in-decorators.md#visibility-decorators) and provides functionality for emitters to apply them based on whether on request vs. response and HTTP method usage as detailed in the table below.\n\nSee [handling visibility and metadata](../../extending-typespec/emitter-metadata-handling.md) for how to incorporate this into\n\n| Name     | Visible in           |\n| -------- | -------------------- |\n| \"read\"   | Any response         |\n| \"query\"  | GET or HEAD request  |\n| \"create\" | POST or PUT request  |\n| \"update\" | PATCH or PUT request |\n| \"delete\" | DELETE request       |\n\nThis allows a single logical TypeSpec model to be used as in the following example:\n\n```typespec\nmodel User {\n  name: string;\n  @visibility(\"read\") id: string;\n  @visibility(\"create\") password: string;\n}\n\n@route(\"/users\")\ninterface Users {\n  @post create(@path id: string, ...User): User;\n  @get get(@path id: string): User;\n}\n```\n\nThere is a single logical user entity represented by the single TypeSpec type `User`, but the HTTP payload for this entity varies based on context. When returned in a response, the `id` property is included, but when sent in a request, it is not. Similarly, the `password` property is only included in create requests, but not present in responses.\n\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(\"read\")` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas. For example, `@visibility(\"create\")` applied to a model property of a type named Widget will generate a `WidgetCreate` schema.\n\nAnother emitter such as one generating client code can see and preserve a single logical type and deal with these HTTP payload differences by means other than type proliferation.\n\nModeling with logical entities rather than HTTP-specific shapes also keeps the TypeSpec spec decoupled from HTTP and REST and can allow the same spec to be used with multiple protocols.\n\n## Metadata\n\nThe properties that designate content for the HTTP envelope (`@header`, `@path`, `@query`, `@statusCode`) rather than the content in an HTTP payload are often called \"metadata\".\n\nMetadata is determined to be applicable or inapplicable based on the context that it is used:\n\n| Context       | Applicability       |\n| ------------- | ------------------- |\n| `@query`      | request only        |\n| `@path`       | request only        |\n| `@statusCode` | response only       |\n| `@header`     | request or response |\n\nAdditionally metadata that appears in an array element type always inapplicable.\n\nWhen metadata is deemed \"inapplicable\", for example, if a `@path` property is seen in a response, it becomes part of the payload instead unless the [@includeInapplicableMetadataInPayload](./reference/decorators.md#@TypeSpec.Rest.includeinapplicablemetadatainpayload) decorator is used and given a value of `false`.\n\nThe handling of metadata applicability furthers the goal of keeping a single logical model in TypeSpec. For example, this defines a logical `User` entity that has a name, ID and password, but further annotates that the ID is sent in the HTTP path and the HTTP body in responses. Also, using automatically visibility as before, we further indicate that the password is only present in create requests.\n\n```typespec\nmodel User {\n  name: string;\n  @path id: string;\n  @visibility(\"create\") password: string;\n}\n```\n\nThen, we can write operations in terms of the logical entity:\n\n```typespec\n@route(\"/users\")\ninterface Users {\n  @post create(...User): User;\n}\n```\n\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\n\n```\nPOST /Users/TypeSpecFan42 HTTP/1.1\nContent-Type: application/json\n{\n  \"name\": \"TypeSpec Fan\",\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\n}\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  name: \"TypeSpec Fan\",\n  id: \"TypeSpecFan42\n}\n```\n\n### Visibility vs. Metadata applicability\n\nMetadata properties are filtered based on visibility as [described above](#automatic-visibility). This is done independently before applicability is considered. If a a metadata property is not visible then it is neither part of the envelope nor the HTTP payload, irrespective of its applicability.\n\n### Nested metadata\n\nMetadata properties are not required to be top-level. They can also be nested deeper in a parameter or response model type. For example:\n\n```typespec\nmodel Thing {\n  headers: {\n    @header example: string;\n  };\n  name: string;\n}\n```\n\nNote that nesting in this sense does not require the use of anonymous models. This is equivalent:\n\n```typespec\nmodel Thing {\n  headers: Headers;\n  name: string;\n}\nmodel Headers {\n  @header example: string;\n}\n```\n\nIn the event that this nesting introduces duplication, then the least nested property with a given name is preferred and the duplicate metadata properties are ignored.\n\n```typespec\nmodel Thing {\n  headers: {\n    @header example: string; // preferred\n    more: {\n      @header example: string; // ignored\n    };\n  };\n}\n```\n\n## Emitter resources\n\nSee [Handling metadata and visibility in emitters for REST API](../../extending-typespec/emitter-metadata-handling.md) for information on how to handle metadata applicability and automatic visibility in a custom emitter.\n", "file_path": "../../core/docs\\standard-library\\http\\operations.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\operations.md"}, {"file_content": "---\ntitle: \"Data types\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Data types\n\n## TypeSpec.Http\n\n### `AcceptedResponse` {#TypeSpec.Http.AcceptedResponse}\n\nThe request has been accepted for processing, but processing has not yet completed.\n\n```typespec\nmodel TypeSpec.Http.AcceptedResponse\n```\n\n### `ApiKeyAuth` {#TypeSpec.Http.ApiKeyAuth}\n\nAn API key is a token that a client provides when making API calls. The key can be sent in the query string:\n\n```\nGET /something?api_key=abcdef12345\n```\n\nor as a request header\n\n```\nGET /something HTTP/1.1\nX-API-Key: abcdef12345\n```\n\nor as a cookie\n\n```\nGET /something HTTP/1.1\nCookie: X-API-KEY=abcdef12345\n```\n\n```typespec\nmodel TypeSpec.Http.ApiKeyAuth<TLocation, TName>\n```\n\n#### Template Parameters\n\n| Name      | Description                 |\n| --------- | --------------------------- |\n| TLocation | The location of the API key |\n| TName     | The name of the API key     |\n\n### `AuthorizationCodeFlow` {#TypeSpec.Http.AuthorizationCodeFlow}\n\nAuthorization Code flow\n\n```typespec\nmodel TypeSpec.Http.AuthorizationCodeFlow\n```\n\n### `BadRequestResponse` {#TypeSpec.Http.BadRequestResponse}\n\nThe server could not understand the request due to invalid syntax.\n\n```typespec\nmodel TypeSpec.Http.BadRequestResponse\n```\n\n### `BasicAuth` {#TypeSpec.Http.BasicAuth}\n\nBasic authentication is a simple authentication scheme built into the HTTP protocol.\nThe client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password.\nFor example, to authorize as demo / `p@55w0rd` the client would send\n\n```\nAuthorization: Basic ZGVtbzpwQDU1dzByZA==\n```\n\n```typespec\nmodel TypeSpec.Http.BasicAuth\n```\n\n### `BearerAuth` {#TypeSpec.Http.BearerAuth}\n\nBearer authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens.\nThe name \u201cBearer authentication\u201d can be understood as \u201cgive access to the bearer of this token.\u201d The bearer token is a cryptic string, usually generated by the server in response to a login request.\nThe client must send this token in the Authorization header when making requests to protected resources:\n\n```\nAuthorization: Bearer <token>\n```\n\n```typespec\nmodel TypeSpec.Http.BearerAuth\n```\n\n### `Body` {#TypeSpec.Http.Body}\n\nDefines a model with a single property of the given type, marked with `@body`.\n\nThis can be useful in situations where you cannot use a bare T as the body\nand it is awkward to add a property.\n\n```typespec\nmodel TypeSpec.Http.Body<T>\n```\n\n#### Template Parameters\n\n| Name | Description                              |\n| ---- | ---------------------------------------- |\n| T    | The type of the model's `body` property. |\n\n### `ClientCredentialsFlow` {#TypeSpec.Http.ClientCredentialsFlow}\n\nClient credentials flow\n\n```typespec\nmodel TypeSpec.Http.ClientCredentialsFlow\n```\n\n### `ConflictResponse` {#TypeSpec.Http.ConflictResponse}\n\nThe request conflicts with the current state of the server.\n\n```typespec\nmodel TypeSpec.Http.ConflictResponse\n```\n\n### `CreatedResponse` {#TypeSpec.Http.CreatedResponse}\n\nThe request has succeeded and a new resource has been created as a result.\n\n```typespec\nmodel TypeSpec.Http.CreatedResponse\n```\n\n### `ForbiddenResponse` {#TypeSpec.Http.ForbiddenResponse}\n\nAccess is forbidden.\n\n```typespec\nmodel TypeSpec.Http.ForbiddenResponse\n```\n\n### `HeaderOptions` {#TypeSpec.Http.HeaderOptions}\n\nHeader options.\n\n```typespec\nmodel TypeSpec.Http.HeaderOptions\n```\n\n### `ImplicitFlow` {#TypeSpec.Http.ImplicitFlow}\n\nImplicit flow\n\n```typespec\nmodel TypeSpec.Http.ImplicitFlow\n```\n\n### `LocationHeader` {#TypeSpec.Http.LocationHeader}\n\nThe Location header contains the URL where the status of the long running operation can be checked.\n\n```typespec\nmodel TypeSpec.Http.LocationHeader\n```\n\n### `MovedResponse` {#TypeSpec.Http.MovedResponse}\n\nThe URL of the requested resource has been changed permanently. The new URL is given in the response.\n\n```typespec\nmodel TypeSpec.Http.MovedResponse\n```\n\n### `NoContentResponse` {#TypeSpec.Http.NoContentResponse}\n\nThere is no content to send for this request, but the headers may be useful.\n\n```typespec\nmodel TypeSpec.Http.NoContentResponse\n```\n\n### `NotFoundResponse` {#TypeSpec.Http.NotFoundResponse}\n\nThe server cannot find the requested resource.\n\n```typespec\nmodel TypeSpec.Http.NotFoundResponse\n```\n\n### `NotModifiedResponse` {#TypeSpec.Http.NotModifiedResponse}\n\nThe client has made a conditional request and the resource has not been modified.\n\n```typespec\nmodel TypeSpec.Http.NotModifiedResponse\n```\n\n### `OAuth2Auth` {#TypeSpec.Http.OAuth2Auth}\n\nOAuth 2.0 is an authorization protocol that gives an API client limited access to user data on a web server.\nOAuth relies on authentication scenarios called flows, which allow the resource owner (user) to share the protected content from the resource server without sharing their credentials.\nFor that purpose, an OAuth 2.0 server issues access tokens that the client applications can use to access protected resources on behalf of the resource owner.\nFor more information about OAuth 2.0, see oauth.net and RFC 6749.\n\n```typespec\nmodel TypeSpec.Http.OAuth2Auth<TFlows>\n```\n\n#### Template Parameters\n\n| Name   | Description                        |\n| ------ | ---------------------------------- |\n| TFlows | The list of supported OAuth2 flows |\n\n### `OkResponse` {#TypeSpec.Http.OkResponse}\n\nThe request has succeeded.\n\n```typespec\nmodel TypeSpec.Http.OkResponse\n```\n\n### `PasswordFlow` {#TypeSpec.Http.PasswordFlow}\n\nResource Owner Password flow\n\n```typespec\nmodel TypeSpec.Http.PasswordFlow\n```\n\n### `PlainData` {#TypeSpec.Http.PlainData}\n\nProduces a new model with the same properties as T, but with `@query`,\n`@header`, `@body`, and `@path` decorators removed from all properties.\n\n```typespec\nmodel TypeSpec.Http.PlainData<T>\n```\n\n#### Template Parameters\n\n| Name | Description                            |\n| ---- | -------------------------------------- |\n| T    | The model to spread as the plain data. |\n\n### `QueryOptions` {#TypeSpec.Http.QueryOptions}\n\nQuery parameter options.\n\n```typespec\nmodel TypeSpec.Http.QueryOptions\n```\n\n### `Response` {#TypeSpec.Http.Response}\n\nDescribes an HTTP response.\n\n```typespec\nmodel TypeSpec.Http.Response<Status>\n```\n\n#### Template Parameters\n\n| Name   | Description                      |\n| ------ | -------------------------------- |\n| Status | The status code of the response. |\n\n### `UnauthorizedResponse` {#TypeSpec.Http.UnauthorizedResponse}\n\nAccess is unauthorized.\n\n```typespec\nmodel TypeSpec.Http.UnauthorizedResponse\n```\n\n### `ApiKeyLocation` {#TypeSpec.Http.ApiKeyLocation}\n\nDescribes the location of the API key\n\n```typespec\nenum TypeSpec.Http.ApiKeyLocation\n```\n\n### `AuthType` {#TypeSpec.Http.AuthType}\n\nAuthentication type\n\n```typespec\nenum TypeSpec.Http.AuthType\n```\n\n### `OAuth2FlowType` {#TypeSpec.Http.OAuth2FlowType}\n\nDescribes the OAuth2 flow type\n\n```typespec\nenum TypeSpec.Http.OAuth2FlowType\n```\n", "file_path": "../../core/docs\\standard-library\\http\\reference\\data-types.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\reference\\data-types.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.Http\n\n### `@body` {#@TypeSpec.Http.body}\n\nExplicitly specify that this property is to be set as the body\n\n```typespec\n@TypeSpec.Http.body\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\nop upload(@body image: bytes): void;\nop download(): {\n  @body image: bytes;\n};\n```\n\n### `@delete` {#@TypeSpec.Http.delete}\n\nSpecify the HTTP verb for the target operation to be `DELETE`.\n\n```typespec\n@TypeSpec.Http.delete\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@delete op set(petId: string): void;\n```\n\n### `@get` {#@TypeSpec.Http.get}\n\nSpecify the HTTP verb for the target operation to be `GET`.\n\n```typespec\n@TypeSpec.Http.get\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@get op read(): string;\n```\n\n### `@head` {#@TypeSpec.Http.head}\n\nSpecify the HTTP verb for the target operation to be `HEAD`.\n\n```typespec\n@TypeSpec.Http.head\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@head op ping(petId: string): void;\n```\n\n### `@header` {#@TypeSpec.Http.header}\n\nSpecify this property is to be sent or received as an HTTP header.\n\n```typespec\n@TypeSpec.Http.header(headerNameOrOptions?: string | TypeSpec.Http.HeaderOptions)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\n| Name                | Type                                          | Description                                                                                                                                                                                                 |\n| ------------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| headerNameOrOptions | `union string \\| TypeSpec.Http.HeaderOptions` | Optional name of the header when sent over HTTP or header options.<br />By default the header name will be the property name converted from camelCase to kebab-case. (e.g. `contentType` -> `content-type`) |\n\n#### Examples\n\n```typespec\nop read(@header accept: string): {\n  @header(\"ETag\") eTag: string;\n};\nop create(\n  @header({\n    name: \"X-Color\",\n    format: \"csv\",\n  })\n  colors: string[],\n): void;\n```\n\n##### Implicit header name\n\n```typespec\nop read(): {\n  @header contentType: string;\n}; // headerName: content-type\nop update(@header ifMatch: string): void; // headerName: if-match\n```\n\n### `@includeInapplicableMetadataInPayload` {#@TypeSpec.Http.includeInapplicableMetadataInPayload}\n\nSpecify if inapplicable metadata should be included in the payload for the given entity.\n\n```typespec\n@TypeSpec.Http.includeInapplicableMetadataInPayload(value: valueof boolean)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n\n| Name  | Type                     | Description                                                     |\n| ----- | ------------------------ | --------------------------------------------------------------- |\n| value | `valueof scalar boolean` | If true, inapplicable metadata will be included in the payload. |\n\n### `@patch` {#@TypeSpec.Http.patch}\n\nSpecify the HTTP verb for the target operation to be `PATCH`.\n\n```typespec\n@TypeSpec.Http.patch\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@patch op update(pet: Pet): void;\n```\n\n### `@path` {#@TypeSpec.Http.path}\n\nExplicitly specify that this property is to be interpolated as a path parameter.\n\n```typespec\n@TypeSpec.Http.path(paramName?: valueof string)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\n| Name      | Type                    | Description                                         |\n| --------- | ----------------------- | --------------------------------------------------- |\n| paramName | `valueof scalar string` | Optional name of the parameter in the url template. |\n\n#### Examples\n\n```typespec\n@route(\"/read/{explicit}/things/{implicit}\")\nop read(@path explicit: string, implicit: string): void;\n```\n\n### `@post` {#@TypeSpec.Http.post}\n\nSpecify the HTTP verb for the target operation to be `POST`.\n\n```typespec\n@TypeSpec.Http.post\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@post op create(pet: Pet): void;\n```\n\n### `@put` {#@TypeSpec.Http.put}\n\nSpecify the HTTP verb for the target operation to be `PUT`.\n\n```typespec\n@TypeSpec.Http.put\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@put op set(pet: Pet): void;\n```\n\n### `@query` {#@TypeSpec.Http.query}\n\nSpecify this property is to be sent as a query parameter.\n\n```typespec\n@TypeSpec.Http.query(queryNameOrOptions?: string | TypeSpec.Http.QueryOptions)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\n| Name               | Type                                         | Description                                                                     |\n| ------------------ | -------------------------------------------- | ------------------------------------------------------------------------------- |\n| queryNameOrOptions | `union string \\| TypeSpec.Http.QueryOptions` | Optional name of the query when included in the url or query parameter options. |\n\n#### Examples\n\n```typespec\nop read(@query select: string, @query(\"order-by\") orderBy: string): void;\nop list(\n  @query({\n    name: \"id\",\n    format: \"multi\",\n  })\n  ids: string[],\n): void;\n```\n\n### `@route` {#@TypeSpec.Http.route}\n\nDefines the relative route URI for the target operation\n\nThe first argument should be a URI fragment that may contain one or more path parameter fields.\nIf the namespace or interface that contains the operation is also marked with a `@route` decorator,\nit will be used as a prefix to the route URI of the operation.\n\n`@route` can only be applied to operations, namespaces, and interfaces.\n\n```typespec\n@TypeSpec.Http.route(path: valueof string, options?: (anonymous model))\n```\n\n#### Target\n\n`union Namespace | Interface | Operation`\n\n#### Parameters\n\n| Name    | Type                      | Description                                                                                                                                  |\n| ------- | ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| path    | `valueof scalar string`   | Relative route path. Cannot include query parameters.                                                                                        |\n| options | `model (anonymous model)` | Set of parameters used to configure the route. Supports `{shared: true}` which indicates that the route may be shared by several operations. |\n\n#### Examples\n\n```typespec\n@route(\"/widgets\")\nop getWidget(@path id: string): Widget;\n```\n\n### `@server` {#@TypeSpec.Http.server}\n\nSpecify the endpoint for this service.\n\n```typespec\n@TypeSpec.Http.server(url: valueof string, description: valueof string, parameters?: Record<unknown>)\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n\n| Name        | Type                    | Description                                             |\n| ----------- | ----------------------- | ------------------------------------------------------- |\n| url         | `valueof scalar string` | Server endpoint                                         |\n| description | `valueof scalar string` | Description of the endpoint                             |\n| parameters  | `model Record<unknown>` | Optional set of parameters used to interpolate the url. |\n\n#### Examples\n\n```typespec\n@service\n@server(\"https://example.com\", \"Single server endpoint\")\nnamespace PetStore;\n```\n\n##### parameterized\n\n```typespec\n@server(\"https://{region}.foo.com\", \"Regional endpoint\", {\n@doc(\"Region name\")\nregion?: string = \"westus\",\n})\n```\n\n### `@sharedRoute` {#@TypeSpec.Http.sharedRoute}\n\n`@sharedRoute` marks the operation as sharing a route path with other operations.\n\nWhen an operation is marked with `@sharedRoute`, it enables other operations to share the same\nroute path as long as those operations are also marked with `@sharedRoute`.\n\n`@sharedRoute` can only be applied directly to operations.\n\n```typespec\n@sharedRoute\n@route(\"/widgets\")\nop getWidget(@path id: string): Widget;\n```\n\n```typespec\n@TypeSpec.Http.sharedRoute\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\nNone\n\n### `@statusCode` {#@TypeSpec.Http.statusCode}\n\nSpecify the status code for this response. Property type must be a status code integer or a union of status code integer.\n\n```typespec\n@TypeSpec.Http.statusCode\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\nop read(): {@statusCode: 200, @body pet: Pet}\nop create(): {@statusCode: 201 | 202}\n```\n\n### `@useAuth` {#@TypeSpec.Http.useAuth}\n\nSpecify this service authentication. See the [documentation in the Http library](https://microsoft.github.io/typespec/standard-library/http/authentication) for full details.\n\n```typespec\n@TypeSpec.Http.useAuth(auth: {} | Union | {}[])\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n\n| Name | Type                        | Description                                                                                                                                                    |\n| ---- | --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| auth | `union {} \\| Union \\| {}[]` | Authentication configuration. Can be a single security scheme, a union(either option is valid authentication) or a tuple(Must use all authentication together) |\n\n#### Examples\n\n```typespec\n@service\n@useAuth(BasicAuth)\nnamespace PetStore;\n```\n", "file_path": "../../core/docs\\standard-library\\http\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\http\\reference\\decorators.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec HTTP protocol binding\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/http\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/http\n```\n\n</TabItem>\n</Tabs>\n\n## TypeSpec.Http\n\n### Decorators\n\n- [`@body`](./decorators.md#@TypeSpec.Http.body)\n- [`@delete`](./decorators.md#@TypeSpec.Http.delete)\n- [`@get`](./decorators.md#@TypeSpec.Http.get)\n- [`@head`](./decorators.md#@TypeSpec.Http.head)\n- [`@header`](./decorators.md#@TypeSpec.Http.header)\n- [`@includeInapplicableMetadataInPayload`](./decorators.md#@TypeSpec.Http.includeInapplicableMetadataInPayload)\n- [`@patch`](./decorators.md#@TypeSpec.Http.patch)\n- [`@path`](./decorators.md#@TypeSpec.Http.path)\n- [`@post`](./decorators.md#@TypeSpec.Http.post)\n- [`@put`](./decorators.md#@TypeSpec.Http.put)\n- [`@query`](./decorators.md#@TypeSpec.Http.query)\n- [`@route`](./decorators.md#@TypeSpec.Http.route)\n- [`@server`](./decorators.md#@TypeSpec.Http.server)\n- [`@sharedRoute`](./decorators.md#@TypeSpec.Http.sharedRoute)\n- [`@statusCode`](./decorators.md#@TypeSpec.Http.statusCode)\n- [`@useAuth`](./decorators.md#@TypeSpec.Http.useAuth)\n\n### Models\n\n- [`AcceptedResponse`](./data-types.md#TypeSpec.Http.AcceptedResponse)\n- [`ApiKeyAuth`](./data-types.md#TypeSpec.Http.ApiKeyAuth)\n- [`AuthorizationCodeFlow`](./data-types.md#TypeSpec.Http.AuthorizationCodeFlow)\n- [`BadRequestResponse`](./data-types.md#TypeSpec.Http.BadRequestResponse)\n- [`BasicAuth`](./data-types.md#TypeSpec.Http.BasicAuth)\n- [`BearerAuth`](./data-types.md#TypeSpec.Http.BearerAuth)\n- [`Body`](./data-types.md#TypeSpec.Http.Body)\n- [`ClientCredentialsFlow`](./data-types.md#TypeSpec.Http.ClientCredentialsFlow)\n- [`ConflictResponse`](./data-types.md#TypeSpec.Http.ConflictResponse)\n- [`CreatedResponse`](./data-types.md#TypeSpec.Http.CreatedResponse)\n- [`ForbiddenResponse`](./data-types.md#TypeSpec.Http.ForbiddenResponse)\n- [`HeaderOptions`](./data-types.md#TypeSpec.Http.HeaderOptions)\n- [`ImplicitFlow`](./data-types.md#TypeSpec.Http.ImplicitFlow)\n- [`LocationHeader`](./data-types.md#TypeSpec.Http.LocationHeader)\n- [`MovedResponse`](./data-types.md#TypeSpec.Http.MovedResponse)\n- [`NoContentResponse`](./data-types.md#TypeSpec.Http.NoContentResponse)\n- [`NotFoundResponse`](./data-types.md#TypeSpec.Http.NotFoundResponse)\n- [`NotModifiedResponse`](./data-types.md#TypeSpec.Http.NotModifiedResponse)\n- [`OAuth2Auth`](./data-types.md#TypeSpec.Http.OAuth2Auth)\n- [`OkResponse`](./data-types.md#TypeSpec.Http.OkResponse)\n- [`PasswordFlow`](./data-types.md#TypeSpec.Http.PasswordFlow)\n- [`PlainData`](./data-types.md#TypeSpec.Http.PlainData)\n- [`QueryOptions`](./data-types.md#TypeSpec.Http.QueryOptions)\n- [`Response`](./data-types.md#TypeSpec.Http.Response)\n- [`UnauthorizedResponse`](./data-types.md#TypeSpec.Http.UnauthorizedResponse)\n", "file_path": "../../core/docs\\standard-library\\http\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\http\\reference\\index.mdx"}, {"file_content": "---\ntitle: \"Data types\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Data types\n\n## TypeSpec.JsonSchema\n\n### `Json` {#TypeSpec.JsonSchema.Json}\n\nSpecify that the provided template argument should be emitted as raw JSON or YAML\nas opposed to a schema. Use in combination with the\n\n```typespec\nmodel TypeSpec.JsonSchema.Json<T>\n```\n\n#### Template Parameters\n\n| Name | Description                     |\n| ---- | ------------------------------- |\n| T    | the type to convert to raw JSON |\n\n### `Format` {#TypeSpec.JsonSchema.Format}\n\nWell-known JSON Schema formats.\n\n```typespec\nenum TypeSpec.JsonSchema.Format\n```\n", "file_path": "../../core/docs\\standard-library\\json-schema\\reference\\data-types.md", "link_to_file": "file://../../core/docs\\standard-library\\json-schema\\reference\\data-types.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.JsonSchema\n\n### `@baseUri` {#@TypeSpec.JsonSchema.baseUri}\n\nSet the base URI for any schemas emitted from types within this namespace.\n\n```typespec\n@TypeSpec.JsonSchema.baseUri(baseUri: valueof string)\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n\n| Name    | Type                    | Description                                                              |\n| ------- | ----------------------- | ------------------------------------------------------------------------ |\n| baseUri | `valueof scalar string` | the base URI. Schema IDs inside this namespace are relative to this URI. |\n\n### `@contains` {#@TypeSpec.JsonSchema.contains}\n\nSpecify that the array must contain at least one instance of the provided type.\nUse `@minContains` and `@maxContains` to customize how many instances to expect.\n\n```typespec\n@TypeSpec.JsonSchema.contains(value: unknown)\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                  | Description                      |\n| ----- | --------------------- | -------------------------------- |\n| value | `(intrinsic) unknown` | The type the array must contain. |\n\n### `@contentEncoding` {#@TypeSpec.JsonSchema.contentEncoding}\n\nSpecify the encoding used for the contents of a string.\n\n```typespec\n@TypeSpec.JsonSchema.contentEncoding(value: valueof string)\n```\n\n#### Target\n\n`union string | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                    | Description |\n| ----- | ----------------------- | ----------- |\n| value | `valueof scalar string` | <br />      |\n\n### `@contentMediaType` {#@TypeSpec.JsonSchema.contentMediaType}\n\nSpecify the content type of content stored in a string.\n\n```typespec\n@TypeSpec.JsonSchema.contentMediaType(value: valueof string)\n```\n\n#### Target\n\n`union string | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                    | Description                           |\n| ----- | ----------------------- | ------------------------------------- |\n| value | `valueof scalar string` | the media type of the string contents |\n\n### `@contentSchema` {#@TypeSpec.JsonSchema.contentSchema}\n\nSpecify the schema for the contents of a string when interpreted according to the content's\nmedia type and encoding.\n\n```typespec\n@TypeSpec.JsonSchema.contentSchema(value: unknown)\n```\n\n#### Target\n\n`union string | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                  | Description                       |\n| ----- | --------------------- | --------------------------------- |\n| value | `(intrinsic) unknown` | the schema of the string contents |\n\n### `@extension` {#@TypeSpec.JsonSchema.extension}\n\nSpecify a custom property to add to the emitted schema. Useful for adding custom keywords\nand other vendor-specific extensions. The value will be converted to a schema unless the parameter\nis wrapped in the `Json<T>` template. For example, `@extension(\"x-schema\", { x: \"value\" })` will\nemit a JSON schema value for `x-schema`, whereas `@extension(\"x-schema\", Json<{x: \"value\"}>)` will\nemit the raw JSON code `{x: \"value\"}`.\n\n```typespec\n@TypeSpec.JsonSchema.extension(key: valueof string, value: unknown)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n\n| Name  | Type                    | Description                                                                          |\n| ----- | ----------------------- | ------------------------------------------------------------------------------------ |\n| key   | `valueof scalar string` | the name of the keyword of vendor extension, e.g. `x-custom`.                        |\n| value | `(intrinsic) unknown`   | the value of the keyword. Will be converted to a schema unless wrapped in `Json<T>`. |\n\n### `@id` {#@TypeSpec.JsonSchema.id}\n\nSpecify the JSON Schema id. If this model or a parent namespace has a base URI,\nthe provided ID will be relative to that base URI.\n\nBy default, the id will be constructed based on the declaration's name.\n\n```typespec\n@TypeSpec.JsonSchema.id(id: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n\n| Name | Type                    | Description                                     |\n| ---- | ----------------------- | ----------------------------------------------- |\n| id   | `valueof scalar string` | the id of the JSON schema for this declaration. |\n\n### `@jsonSchema` {#@TypeSpec.JsonSchema.jsonSchema}\n\nAdd to namespaces to emit models within that namespace to JSON schema.\nAdd to another declaration to emit that declaration to JSON schema.\n\nOptionally, for namespaces, you can provide a baseUri, and for other declarations,\nyou can provide the id.\n\n```typespec\n@TypeSpec.JsonSchema.jsonSchema(baseUri?: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n\n| Name    | Type                    | Description                                         |\n| ------- | ----------------------- | --------------------------------------------------- |\n| baseUri | `valueof scalar string` | Schema IDs are interpreted as relative to this URI. |\n\n### `@maxContains` {#@TypeSpec.JsonSchema.maxContains}\n\nSpecify that the array must contain at most some number of the types provided\nby the contains decorator.\n\n```typespec\n@TypeSpec.JsonSchema.maxContains(value: valueof int32)\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                   | Description                                            |\n| ----- | ---------------------- | ------------------------------------------------------ |\n| value | `valueof scalar int32` | The maximum number of instances the array must contain |\n\n### `@maxProperties` {#@TypeSpec.JsonSchema.maxProperties}\n\nSpecify the maximum number of properties this object can have.\n\n```typespec\n@TypeSpec.JsonSchema.maxProperties(value: valueof int32)\n```\n\n#### Target\n\n`union Record<unknown> | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                   | Description                                            |\n| ----- | ---------------------- | ------------------------------------------------------ |\n| value | `valueof scalar int32` | The maximum number of properties this object can have. |\n\n### `@minContains` {#@TypeSpec.JsonSchema.minContains}\n\nSpecify that the array must contain at least some number of the types provided\nby the contains decorator.\n\n```typespec\n@TypeSpec.JsonSchema.minContains(value: valueof int32)\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                   | Description                                            |\n| ----- | ---------------------- | ------------------------------------------------------ |\n| value | `valueof scalar int32` | The minimum number of instances the array must contain |\n\n### `@minProperties` {#@TypeSpec.JsonSchema.minProperties}\n\nSpecify the minimum number of properties this object can have.\n\n```typespec\n@TypeSpec.JsonSchema.minProperties(value: valueof int32)\n```\n\n#### Target\n\n`union Record<unknown> | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                   | Description                                            |\n| ----- | ---------------------- | ------------------------------------------------------ |\n| value | `valueof scalar int32` | The minimum number of properties this object can have. |\n\n### `@multipleOf` {#@TypeSpec.JsonSchema.multipleOf}\n\nSpecify that the numeric type must be a multiple of some numeric value.\n\n```typespec\n@TypeSpec.JsonSchema.multipleOf(value: valueof numeric)\n```\n\n#### Target\n\n`union numeric | ModelProperty`\n\n#### Parameters\n\n| Name  | Type                     | Description                                        |\n| ----- | ------------------------ | -------------------------------------------------- |\n| value | `valueof scalar numeric` | The numeric type must be a multiple of this value. |\n\n### `@prefixItems` {#@TypeSpec.JsonSchema.prefixItems}\n\nSpecify that the target array must begin with the provided types.\n\n```typespec\n@TypeSpec.JsonSchema.prefixItems(value: unknown[])\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n\n| Name  | Type              | Description                                                                 |\n| ----- | ----------------- | --------------------------------------------------------------------------- |\n| value | `model unknown[]` | a tuple containing the types that must be present at the start of the array |\n\n### `@uniqueItems` {#@TypeSpec.JsonSchema.uniqueItems}\n\nSpecify that every item in the array must be unique.\n\n```typespec\n@TypeSpec.JsonSchema.uniqueItems\n```\n\n#### Target\n\n`union unknown[] | ModelProperty`\n\n#### Parameters\n\nNone\n", "file_path": "../../core/docs\\standard-library\\json-schema\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\json-schema\\reference\\decorators.md"}, {"file_content": "---\ntitle: \"Emitter usage\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Emitter\n\n## Usage\n\n1. Via the command line\n\n```bash\ntsp compile . --emit=@typespec/json-schema\n```\n\n2. Via the config\n\n```yaml\nemit:\n  - \"@typespec/json-schema\"\n```\n\n## Emitter options\n\n### `file-type`\n\n**Type:** `\"yaml\" | \"json\"`\n\nSerialize the schema as either yaml or json.\n\n### `int64-strategy`\n\n**Type:** `\"string\" | \"number\"`\n\nHow to handle 64 bit integers on the wire. Options are:\n\n- string: serialize as a string (widely interoperable)\n- number: serialize as a number (not widely interoperable)\n\n### `bundleId`\n\n**Type:** `string`\n\nWhen provided, bundle all the schemas into a single json schema document with schemas under $defs. The provided id is the id of the root document and is also used for the file name.\n\n### `emitAllModels`\n\n**Type:** `boolean`\n\nWhen true, emit all model declarations to JSON Schema without requiring the @jsonSchema decorator.\n\n### `emitAllRefs`\n\n**Type:** `boolean`\n\nWhen true, emit all references as json schema files, even if the referenced type does not have the `@jsonSchema` decorator or is not within a namespace with the `@jsonSchema` decorator.\n", "file_path": "../../core/docs\\standard-library\\json-schema\\reference\\emitter.md", "link_to_file": "file://../../core/docs\\standard-library\\json-schema\\reference\\emitter.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec library for emitting TypeSpec to JSON Schema and converting JSON Schema to TypeSpec\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/json-schema\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/json-schema\n```\n\n</TabItem>\n</Tabs>\n\n## Emitter usage\n\n[See documentation](./emitter.md)\n\n## TypeSpec.JsonSchema\n\n### Decorators\n\n- [`@baseUri`](./decorators.md#@TypeSpec.JsonSchema.baseUri)\n- [`@contains`](./decorators.md#@TypeSpec.JsonSchema.contains)\n- [`@contentEncoding`](./decorators.md#@TypeSpec.JsonSchema.contentEncoding)\n- [`@contentMediaType`](./decorators.md#@TypeSpec.JsonSchema.contentMediaType)\n- [`@contentSchema`](./decorators.md#@TypeSpec.JsonSchema.contentSchema)\n- [`@extension`](./decorators.md#@TypeSpec.JsonSchema.extension)\n- [`@id`](./decorators.md#@TypeSpec.JsonSchema.id)\n- [`@jsonSchema`](./decorators.md#@TypeSpec.JsonSchema.jsonSchema)\n- [`@maxContains`](./decorators.md#@TypeSpec.JsonSchema.maxContains)\n- [`@maxProperties`](./decorators.md#@TypeSpec.JsonSchema.maxProperties)\n- [`@minContains`](./decorators.md#@TypeSpec.JsonSchema.minContains)\n- [`@minProperties`](./decorators.md#@TypeSpec.JsonSchema.minProperties)\n- [`@multipleOf`](./decorators.md#@TypeSpec.JsonSchema.multipleOf)\n- [`@prefixItems`](./decorators.md#@TypeSpec.JsonSchema.prefixItems)\n- [`@uniqueItems`](./decorators.md#@TypeSpec.JsonSchema.uniqueItems)\n\n### Models\n\n- [`Json`](./data-types.md#TypeSpec.JsonSchema.Json)\n", "file_path": "../../core/docs\\standard-library\\json-schema\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\json-schema\\reference\\index.mdx"}, {"file_content": "---\ntitle: \"Data types\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Data types\n\n## TypeSpec.OpenAPI\n\n### `AdditionalInfo` {#TypeSpec.OpenAPI.AdditionalInfo}\n\nAdditional information for the OpenAPI document.\n\n```typespec\nmodel TypeSpec.OpenAPI.AdditionalInfo\n```\n\n### `Contact` {#TypeSpec.OpenAPI.Contact}\n\nContact information for the exposed API.\n\n```typespec\nmodel TypeSpec.OpenAPI.Contact\n```\n\n### `License` {#TypeSpec.OpenAPI.License}\n\nLicense information for the exposed API.\n\n```typespec\nmodel TypeSpec.OpenAPI.License\n```\n", "file_path": "../../core/docs\\standard-library\\openapi\\reference\\data-types.md", "link_to_file": "file://../../core/docs\\standard-library\\openapi\\reference\\data-types.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.OpenAPI\n\n### `@defaultResponse` {#@TypeSpec.OpenAPI.defaultResponse}\n\nSpecify that this model is to be treated as the OpenAPI `default` response.\nThis differs from the compiler built-in `@error` decorator as this does not necessarily represent an error.\n\n```typespec\n@TypeSpec.OpenAPI.defaultResponse\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@defaultResponse\nmodel PetStoreResponse is object;\n\nop listPets(): Pet[] | PetStoreResponse;\n```\n\n### `@extension` {#@TypeSpec.OpenAPI.extension}\n\nAttach some custom data to the OpenAPI element generated from this type.\n\n```typespec\n@TypeSpec.OpenAPI.extension(key: valueof string, value: unknown)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n\n| Name  | Type                    | Description                         |\n| ----- | ----------------------- | ----------------------------------- |\n| key   | `valueof scalar string` | Extension key. Must start with `x-` |\n| value | `(intrinsic) unknown`   | Extension value.                    |\n\n#### Examples\n\n```typespec\n@extension(\"x-custom\", \"My value\")\n@extension(\n  \"x-pageable\",\n  {\n    nextLink: \"x-next-link\",\n  }\n)\nop read(): string;\n```\n\n### `@externalDocs` {#@TypeSpec.OpenAPI.externalDocs}\n\nSpecify the OpenAPI `externalDocs` property for this type.\n\n```typespec\n@TypeSpec.OpenAPI.externalDocs(url: valueof string, description?: valueof string)\n```\n\n#### Target\n\n`(intrinsic) unknown`\n\n#### Parameters\n\n| Name        | Type                    | Description             |\n| ----------- | ----------------------- | ----------------------- |\n| url         | `valueof scalar string` | Url to the docs         |\n| description | `valueof scalar string` | Description of the docs |\n\n#### Examples\n\n```typespec\n@externalDocs(\n  \"https://example.com/detailed.md\",\n  \"Detailed information on how to use this operation\"\n)\nop listPets(): Pet[];\n```\n\n### `@info` {#@TypeSpec.OpenAPI.info}\n\nSpecify OpenAPI additional information.\nThe service `title` and `version` are already specified using `@service`.\n\n```typespec\n@TypeSpec.OpenAPI.info(additionalInfo: TypeSpec.OpenAPI.AdditionalInfo)\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n\n| Name           | Type                                    | Description            |\n| -------------- | --------------------------------------- | ---------------------- |\n| additionalInfo | `model TypeSpec.OpenAPI.AdditionalInfo` | Additional information |\n\n### `@operationId` {#@TypeSpec.OpenAPI.operationId}\n\nSpecify the OpenAPI `operationId` property for this operation.\n\n```typespec\n@TypeSpec.OpenAPI.operationId(operationId: valueof string)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name        | Type                    | Description         |\n| ----------- | ----------------------- | ------------------- |\n| operationId | `valueof scalar string` | Operation id value. |\n\n#### Examples\n\n```typespec\n@operationId(\"download\")\nop read(): string;\n```\n", "file_path": "../../core/docs\\standard-library\\openapi\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\openapi\\reference\\decorators.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec library providing OpenAPI concepts\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/openapi\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/openapi\n```\n\n</TabItem>\n</Tabs>\n\n## TypeSpec.OpenAPI\n\n### Decorators\n\n- [`@defaultResponse`](./decorators.md#@TypeSpec.OpenAPI.defaultResponse)\n- [`@extension`](./decorators.md#@TypeSpec.OpenAPI.extension)\n- [`@externalDocs`](./decorators.md#@TypeSpec.OpenAPI.externalDocs)\n- [`@info`](./decorators.md#@TypeSpec.OpenAPI.info)\n- [`@operationId`](./decorators.md#@TypeSpec.OpenAPI.operationId)\n\n### Models\n\n- [`AdditionalInfo`](./data-types.md#TypeSpec.OpenAPI.AdditionalInfo)\n- [`Contact`](./data-types.md#TypeSpec.OpenAPI.Contact)\n- [`License`](./data-types.md#TypeSpec.OpenAPI.License)\n", "file_path": "../../core/docs\\standard-library\\openapi\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\openapi\\reference\\index.mdx"}, {"file_content": "---\ntitle: Diagnostics\n---\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\n\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\n\nHow to fix ???\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter.\nThis generally happens when a model or parameter is renamed with the `@friendlyName` decorator.\n\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n## inline-cycle\n\n???\n\n## invalid-default\n\n???\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\nrequired by the OpenAPI v3 specification.\n\nTo fix this issue, change the extension name to start with \"x-\".\n\n## invalid-schema\n\n???\n\n## invalid-server-variable\n\nThis diagnostic is issued when the a variable in the `@server` decorator is not defined as a string type.\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\n\nTo fix this issue, make sure all server variables are string type.\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter.\nThis is not permitted by the OpenAPI v3 specification.\n\nTo fix this issue, redesign the API to only use paths without query parameters.\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\nrepresented in OpenAPI.\n\nTo fix this issue, correct the composition to produce a valid schema or remove it altogether.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types.\n\nTo fix this issue, correct the composition to produce a valid schema or remove it altogether.\n", "file_path": "../../core/docs\\standard-library\\openapi3\\diagnostics.md", "link_to_file": "file://../../core/docs\\standard-library\\openapi3\\diagnostics.md"}, {"file_content": "---\ntitle: Emitter operation\n---\n\n# How the OpenAPI emitter works\n\nThe OpenAPI emitter converts TypeSpec language elements into their natural OpenAPI expression as described below.\n\n## Servers\n\nIf the TypeSpec file contains an [(Http) `@server` decorator](../rest/reference/decorators.md#@TypeSpec.Http.server)\nthe OpenAPI emitter will generate a `servers` object with the server URL, description, and variables specified in the decorator.\n\nYou can specify multiple `@server` decorators to obtain multiple entries in the `servers` object.\n\n## Operations\n\nEach TypeSpec operation becomes an OpenAPI operation.\n\nThe HTTP method for the operation is either explicitly specified with an [(Http) `@get`, `@post`, `@put`, `@patch`, or `@delete` decorator][http-verb-decorators] on the operation or it is inferred from the operation name and signature.\n\nThe path for the operation comes from the [(Http) `@route` decorator][http-route-decorator] on the operation.\nThe `@route` decorator can also be specified on a namespace and/or an interface (group of operations).\nWhen specified, the route for the enclosing namespace(s) and interface are prefixed to the operation route.\n\n[http-verb-decorators]: ../rest/reference/decorators.md\n[http-route-decorator]: ../rest/reference/decorators.md#@TypeSpec.Http.route\n\nThe fields of the [OpenAPI Operation object][] are set as described below.\n\n[openapi operation object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\n\n### description\n\nThe description field is set from the [(built-in) `@doc` decorator][doc-decorator] on the TypeSpec operation, and omitted when `@doc` is not present.\n\n[doc-decorator]: ../built-in-decorators.md#doc\n\n### summary\n\nThe summary field is set from the [(built-in) `@summary` decorator][summary-decorator] on the TypeSpec operation, and omitted when `@summary` is not present.\n\n[summary-decorator]: ../built-in-decorators.md#summary\n\n### operationId\n\nThe operationId can be explicitly specified with the [(OpenAPI) `@operationId` decorator][openapi-operationid-decorator],\nand otherwise is simple the operation name, prefixed with \"<interface*name>*\" when the operation is within an interface.\n\n[openapi-operationid-decorator]: ../built-in-decorators.md#operationId\n\n### parameters and requestBody\n\nThe parameters of the TypeSpec operation are translated into the parameter list and requestBody for the OpenAPI operation.\n\nThe `in` field of a parameter is specified with an [(Http) `@query`, `@header`, or `@path` decorator][http-parameter-decorators].\nA parameter without one of these decorators is assumed to be passed in the request body.\n\nThe request body parameter can also be explicitly decorated with an [(Http) `@body` decorator][http-body-decorator].\nIn the absence of explicit `@body`, the set of parameters that are not marked `@header`, `@query`, or `@path` form the request body\nand this request body is defined as required. If the request body should be optional, the body must be declared as\noptional property with the `@body` decorator.\n\n[http-parameter-decorators]: ../rest/reference/decorators.md#data-types\n[http-body-decorator]: ../rest/reference/decorators.md#@TypeSpec.Http.body\n\nThe content of a (built-in) `@doc` decorator on a parameter will be set in the description.\n\nThe TypeSpec parameter type will be translated into an appropriate OpenAPI schema for the parameter.\n\nLikewise, the type of the body parameter(s) will be translated into an appropriate OpenAPI schema for the requestBody.\nThe request body will use the \"application/json\" media type unless the body model includes an explicit `content-type`\nheader.\n\nSee also [metadata](../http/operations.md#metadata) for more advanced details.\n\n### responses\n\nThe return type(s) of the TypeSpec operation are translated into responses for the OpenAPI operation.\nThe status code for a response can be specified as a property in the return type model with the [(Http) `@statusCode` decorator][http-statuscode-decorator] (the property name is ignored).\nIf the [(built-in) `@error` decorator][error-decorator] is specified on a return type, this return type becomes the \"default\" response for the operation.\nThe media type for a response will be \"application/json\" unless the return type model includes an explicit `content-type`\nheader.\nModels with different status codes and/or media types can be unioned together to describe complex response designs.\n\nWhen a return type model has a property explicitly decorated with an [(Http) `@body` decorator][http-body-decorator], this\nis taken as the response body.\nIn the absence of explicit `@body`, the properties that are not marked `@statusCode` or `@header` form the response body.\n\n[http-statuscode-decorator]: ../rest/reference/decorators.md#@TypeSpec.Http.statuscode\n[error-decorator]: ../built-in-decorators.md#error\n\nSee also [metadata](../http/operations.md#metadata) for more advanced details.\n\n### tags\n\nAny tags specified with the [(built-in) `@tag` decorator][tag-decorator] on the operation, interface, or\nenclosing namespace(s) are included in the OpenAPI operation's tags array.\n\n[tag-decorator]: ../built-in-decorators.md#tag\n\n### deprecated\n\nIf the [(built-in) `#deprecated` directive][deprecated-decorator] is specified on the operation, then the operation's\ndeprecated field is set to true.\n\n[deprecated-decorator]: ../built-in-decorators.md#deprecated\n\n### externalDocs\n\nIf the TypeSpec operation has an [(OpenAPI) `@externalDocs` decorator](../openapi/reference/decorators.md#@OpenAPI.externaldocs) this will produce\nan externalDocs field in the OpenAPI operation.\n\n### Specification extensions\n\nAny extensions specified on the TypeSpec operation with the [(OpenAPI) `@extension` decorator](../openapi/reference/decorators.md#OpenAPI.extension)\nare included in the emitted OpenAPI operation.\n\n## Models and enums\n\nModels and enums are converted into schemas in the generated OpenAPI definition. Intrinsic types in TypeSpec are represented\nwith a JSON Schema type that most closely matches the semantics of the TypeSpec type.\n\nModels defined inline will result in an inline schema. Explicitly declared models will be defined in the `components/schemas`\nsection with the TypeSpec name qualified by any enclosing namespaces.\n\nA special case is an instantiation of a model template, it is treated as an inline model unless the model template has\na [(built-in) `@friendlyName` decorator][friendlyname], in which case the schema is defined in `components/schemas` with the friendly-name.\n\n[friendlyname]: ../built-in-decorators.md#friendlyname\n\nThe following table shows how TypeSpec types are translated to JSON Schema types:\n\n| TypeSpec type    | OpenAPI `type`/`format`           | Notes                                                                     |\n| ---------------- | --------------------------------- | ------------------------------------------------------------------------- |\n| `int32`          | `type: integer, format: int32`    |                                                                           |\n| `int64`          | `type: integer, format: int64`    |                                                                           |\n| `float32`        | `type: number, format: float`     |                                                                           |\n| `float64`        | `type: number, format: double`    |                                                                           |\n| `string`         | `type: string`                    |                                                                           |\n| `bytes`          | `type: string, format: byte`      | for content-type == 'application/json' or 'text/plain'                    |\n| `bytes`          | `type: string, format: binary`    | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\n| `boolean`        | `type: boolean`                   |                                                                           |\n| `plainDate`      | `type: string, format: date`      |                                                                           |\n| `utcDateTime`    | `type: string, format: date-time` | RFC 3339 date in coordinated universal time (UTC)                         |\n| `offsetDateTime` | `type: string, format: date-time` | RFC 3339 date with timezone offset                                        |\n\n[See encoding and format](#encoding-and-formats) for other way to encode those types.\n\nThere are a variety of decorators that can modify or add metadata to the definitions produced in the generated OpenAPI.\n\nFor a numeric element (integer or float):\n\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Notes |\n| ------------------ | -------- | --------------------------- | ----- |\n| `@minValue(value)` | built-in | `minimum: value`            |       |\n| `@maxValue(value)` | built-in | `maximum: value`            |       |\n\nFor any element defined as a `string` or a type that extends from `string`:\n\n| Decorator           | Library  | OpenAPI/JSON Schema keyword | Notes                                                      |\n| ------------------- | -------- | --------------------------- | ---------------------------------------------------------- |\n| `@format(name)`     | built-in | `format: name`              | When format is not determined by type or another decorator |\n| `@minLength(value)` | built-in | `minLength: value`          |                                                            |\n| `@maxLength(value)` | built-in | `maxLength: value`          |                                                            |\n| `@pattern(regex)`   | built-in | `pattern: regex`            |                                                            |\n| `@secret`           | built-in | `format: password`          |                                                            |\n\nFor an array type:\n\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Notes |\n| ------------------ | -------- | --------------------------- | ----- |\n| `@minItems(value)` | built-in | `minItems: value`           |       |\n| `@maxItems(value)` | built-in | `maxItems: value`           |       |\n\nThe OpenAPI emitter provides an [`@useRef` decorator](../openapi/reference/decorators.md#@OpenAPI.useref) which will replace the TypeSpec model type in emitter output\nwith a reference to a pre-existing named OpenAPI schema. This can be useful for \"common\" schemas.\n\nExample:\n\n```typespec\n@useRef(\"common.json#/components/schemas/Sku\")\nmodel Sku {\n...\n}\n```\n\nEnums can be defined in TypeSpec with the [`enum` statement](../../language-basics/enums.md), e.g.:\n\n```typespec\nenum Color {\n  Red: \"red\",\n  Blue: \"blue\",\n  Green: \"green\",\n}\n```\n\nThe union operator can also be used to define the enum values inline, e.g.:\n\n```typespec\nstatus: \"Running\" | \"Stopped\" | \"Failed\"\n```\n\nThe OpenAPI emitter converts both of these into a schema definition containing an \"enum\" with the list of defined values.\n\n### Model composition\n\nTypeSpec has several mechanisms for model composition and extension. The following describes how these are handled in the OpenAPI emitter.\n\n#### Spread\n\nThe spread operator does not convey any semantic relationship between the source and target models so the OpenAPI emitter\ntreats this as if the properties of the source model were explicitly included in the target model at the position where the\nspread appears.\n\n#### Extends\n\nWhen one model extends another model, this is intended to convey and inheritance relationship. While OpenAPI has no formal\nconstruct for inheritance, the OpenAPI emitter represents this form of composition with an `allOf` in the schema of the child model\nthat references the schema for the parent model.\n\n##### Extends with discriminator\n\nThe OpenAPI emitter supports the `@discriminator(propertyName)` decorator on a `model`. This will produce a `discriminator` object\nwith the named property in the schema for this model.\n\nModels that extend this model must define this property with a literal string value, and these values must be distinct across all the\nmodels that extend this model. These values are used to construct a `mapping` for the discriminator.\n\nThe `@discriminator` decorator can be used to create multi-level discriminated inheritance but must use a different discriminated property at each level.\n\n#### Is\n\nThe `is` keyword provides a form of composition similar to the spread operator, where no semantic relationship is conveyed between\nthe source and target models. The OpenAPI emitter represents this form of composition with an independent schema that contains\nall the same properties as the model named by the `is` keyword, plus any properties defined directly on the model.\n\n#### Union\n\nUnions are another form of model composition.\n\nUnions can be defined in two different ways in TypeSpec. One way is with\n[the union type operator](../../language-basics/unions.md#union-expressions), `|`:\n\n```typespec\nalias GoodBreed = Beagle | GermanShepherd | GoldenRetriever;\n```\n\nThe second way is with [the `union` statement](../../language-basics/unions.md#named-unions)\nwhich not only declares the variant models but also assigns a name for each.\n\n```typespec\nunion GoodBreed {\n  beagle: Beagle,\n  shepherd: GermanShepherd,\n  retriever: GoldenRetriever,\n}\n```\n\nThe OpenAPI emitter represents either form of union with an `anyOf` with an element for each option of the union.\nThe OpenAPI emitter ignores the \"names\" for variants in named unions.\n\nThe OpenAPI emitter also defines the[`@oneOf` decorator](../openapi/reference/decorators.md#OpenAPI.oneof) which can be specified on a `union` statement to indicate\nthat a union should be emitted as a `oneOf` rather than `anyOf`.\n\n## Encoding and formats\n\nWhen working with the `@encode` decorator the rule is as follow. Given the 3 values `encoding`, `encodeAs` and `realType` where `@encode(encoding, encodeAs) _: realType`:\n\n1. If `realType` is `utcDateTime` or `offsetDateTime`:\n   - `encoding` of `rfc3339` will produce `type: string, format: date-time`\n   - `encoding` of `rfc7231` will produce `type: string, format: http-date`\n1. If `realType` is `utcDateTime` and `encoding` is `unixTimestamp`:\n   - `encodeAs` of any integer type will produce `type: integer, format: unixtime`\n1. If the schema of encodeAs produces a `format` use it (e.g. encoding as `int32` will produce an `type: integer, format: integer` )\n1. Otherwise use the `encoding` as the format\n\n**Summary table**\n\n| encoding                                         | Openapi3                          | Swagger 2.0 (autorest)            |\n| ------------------------------------------------ | --------------------------------- | --------------------------------- |\n| `@encode(\"seconds\", int32) _: duration`          | `type: integer, format: int32`    | `type: integer, format: int32`    |\n| `@encode(\"seconds\", float32) _: duration`        | `type: number, format: float32`   | `type: number, format: float32`   |\n| `@encode(\"ISO8601\") _: duration`                 | `type: number, format: duration`  | `type: number, format: duration`  |\n| `@encode(\"unixTimestamp\", int32) _: utcDateTime` | `type: integer, format: unixtime` | `type: integer, format: unixtime` |\n| `@encode(\"unixTimestamp\", int64) _: utcDateTime` | `type: integer, format: unixtime` | `type: integer, format: unixtime` |\n| `@encode(\"rfc3339\") _: utcDateTime`              | `type: string, format: date-time` | `type: string, format: date-time` |\n| `@encode(\"rfc7231\") _: utcDateTime`              | `type: string, format: http-date` | `type: string, format: http-date` |\n| `@encode(\"http-date\") _: utcDateTime`            | `type: string, format: http-date` | `type: string, format: http-date` |\n\n## Security Definitions\n\nThe OpenAPI emitter takes the [(http) `@useAuth` decorator](../rest/reference/decorators.md#@TypeSpec.Http.useauth)\n\n### Examples\n\nThe following example shows how to define a security scheme for Azure Active Directory authentication:\n\n```typespec\n@useAuth(AADToken)\nnamespace Contoso.WidgetManager;\n@doc(\"The Azure Active Directory OAuth2 Flow\")\nmodel AADToken\n  is OAuth2Auth<[\n    {\n      type: OAuth2FlowType.authorizationCode;\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\n      tokenUrl: \"https://api.example.com/oauth2/token\";\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\n    }\n  ]>;\n```\n", "file_path": "../../core/docs\\standard-library\\openapi3\\openapi.md", "link_to_file": "file://../../core/docs\\standard-library\\openapi3\\openapi.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.OpenAPI\n\n### `@oneOf` {#@TypeSpec.OpenAPI.oneOf}\n\nSpecify that `oneOf` should be used instead of `anyOf` for that union.\n\n```typespec\n@TypeSpec.OpenAPI.oneOf\n```\n\n#### Target\n\n`union Union | ModelProperty`\n\n#### Parameters\n\nNone\n\n### `@useRef` {#@TypeSpec.OpenAPI.useRef}\n\nSpecify an external reference that should be used inside of emitting this type.\n\n```typespec\n@TypeSpec.OpenAPI.useRef(ref: valueof string)\n```\n\n#### Target\n\n`union Model | ModelProperty`\n\n#### Parameters\n\n| Name | Type                    | Description                                                          |\n| ---- | ----------------------- | -------------------------------------------------------------------- |\n| ref  | `valueof scalar string` | External reference(e.g. \"../../common.json#/components/schemas/Foo\") |\n", "file_path": "../../core/docs\\standard-library\\openapi3\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\openapi3\\reference\\decorators.md"}, {"file_content": "---\ntitle: \"Emitter usage\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Emitter\n\n## Usage\n\n1. Via the command line\n\n```bash\ntsp compile . --emit=@typespec/openapi3\n```\n\n2. Via the config\n\n```yaml\nemit:\n  - \"@typespec/openapi3\"\n```\n\n## Emitter options\n\n### `file-type`\n\n**Type:** `\"yaml\" | \"json\"`\n\nIf the content should be serialized as YAML or JSON. Default 'yaml', it not specified infer from the `output-file` extension\n\n### `output-file`\n\n**Type:** `string`\n\nName of the output file.\nOutput file will interpolate the following values:\n\n- service-name: Name of the service if multiple\n- version: Version of the service if multiple\n\nDefault: `{service-name}.{version}.openapi.yaml` or `.json` if `file-type` is `\"json\"`\n\nExample Single service no versioning\n\n- `openapi.yaml`\n\nExample Multiple services no versioning\n\n- `openapi.Org1.Service1.yaml`\n- `openapi.Org1.Service2.yaml`\n\nExample Single service with versioning\n\n- `openapi.v1.yaml`\n- `openapi.v2.yaml`\n\nExample Multiple service with versioning\n\n- `openapi.Org1.Service1.v1.yaml`\n- `openapi.Org1.Service1.v2.yaml`\n- `openapi.Org1.Service2.v1.0.yaml`\n- `openapi.Org1.Service2.v1.1.yaml`\n\n### `new-line`\n\n**Type:** `\"crlf\" | \"lf\"`\n\nSet the newline character for emitting files.\n\n### `omit-unreachable-types`\n\n**Type:** `boolean`\n\nOmit unreachable types.\nBy default all types declared under the service namespace will be included. With this flag on only types references in an operation will be emitted.\n\n### `include-x-typespec-name`\n\n**Type:** `\"inline-only\" | \"never\"`\n\nIf the generated openapi types should have the `x-typespec-name` extension set with the name of the TypeSpec type that created it.\nThis extension is meant for debugging and should not be depended on.\n", "file_path": "../../core/docs\\standard-library\\openapi3\\reference\\emitter.md", "link_to_file": "file://../../core/docs\\standard-library\\openapi3\\reference\\emitter.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec library for emitting OpenAPI 3.0 from the TypeSpec REST protocol binding\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/openapi3\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/openapi3\n```\n\n</TabItem>\n</Tabs>\n\n## Emitter usage\n\n[See documentation](./emitter.md)\n\n## TypeSpec.OpenAPI\n\n### Decorators\n\n- [`@oneOf`](./decorators.md#@TypeSpec.OpenAPI.oneOf)\n- [`@useRef`](./decorators.md#@TypeSpec.OpenAPI.useRef)\n", "file_path": "../../core/docs\\standard-library\\openapi3\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\openapi3\\reference\\index.mdx"}, {"file_content": "---\ntitle: Guide\n---\n\n# The Protobuf Emitter guide\n\nTypeSpec provides an emitter (`@typespec/protobuf`) that generates Protocol Buffers specifications from TypeSpec sources as part of its standard library. The resulting Protobuf files may be used as inputs for creating gRPC services or any other tools compatible with Protocol Buffers.\n\n**Note**: The Protobuf emitter uses Protocol Buffers 3 (proto3) syntax. Your workflow (`protoc` version, etc.) must support proto3 to utilize this emitter.\n\n## Core concepts\n\nThe Protobuf emitter enables you to write TypeSpec and convert it into equivalent Protocol Buffers for use with Protobuf-enabled systems (such as gRPC). Your TypeSpec models and interfaces must adhere to certain requirements and restrictions in order for the emitter to convert them to Protobuf.\n\n### Packages\n\nA protobuf package is defined by the [`TypeSpec.Protobuf.package` decorator][protobuf-package], which applies to a TypeSpec namespace. A package essentially defines a `.proto` file, and everything within the decorated namespace will be emitted to a single file.\n\nThe following TypeSpec namespace results in a Protobuf file named `main.proto` that contains the contents of the `Test` namespace converted into Protobuf.\n\n```typespec\n@package\nnamespace Test {\n// ...\n\n}\n```\n\nPackage names may be provided using the optional `PackageDetails` argument to the `@package` decorator. The following TypeSpec namespace will result in a file `com/example/test.proto` that has the line `package com.example.test;` within it:\n\n```typespec\n@package({\n  name: \"com.example.test\",\n})\nnamespace Test {\n// ...\n\n}\n```\n\nTypeSpec objects (models, enums, etc.) are converted to Protobuf declarations within their nearest ancestor that has a package annotation. As a result, unlike in Protobuf, TypeSpec declarations of packages may be nested arbitrarily.p\n\n### Messages\n\nTypeSpec models are converted into Protobuf messages. The following TypeSpec model:\n\n```typespec\nmodel TestMessage {\n  @field(1) n: int32;\n}\n```\n\nwill be converted into the following Protobuf message:\n\n```proto3\nmessage TestMessage {\n  int32 n = 1;\n}\n```\n\nModels are converted into messages and included in the Protobuf file if any of the following conditions are met:\n\n- The model is explicitly annotated with the [`TypeSpec.Protobuf.message` decorator][protobuf-message].\n- The model is referenced by any service operation (see [Services](#services) below).\n- The model is a direct child of a [package namespace](#packages) and has _every_ field annotated with the [`TypeSpec.Protobuf.field` decorator][protobuf-field].\n\n#### Field indices\n\nProtobuf requires that the offset of each field within a Protobuf message be manually specified. In TypeSpec, the field indices are specified using the [`TypeSpec.Protobuf.field` decorator][protobuf-field]. All fields within a model must have an attached `@field` decorator to be converted into a Protobuf message.\n\nThe following TypeSpec model:\n\n```typespec\nmodel TestMessage {\n  @field(1) n: int32;\n}\n```\n\nwill be converted into the following Protobuf message:\n\n```proto3\nmessage TestMessage {\n  int32 n = 1;\n}\n```\n\n### Services\n\nTypeSpec has a concept of a \"service\" defined by the [`TypeSpec.service` decorator][native-service], but the Protobuf concept of a \"service\" is different and is indicated by the [`TypeSpec.Protobuf.service` decorator][protobuf-service].\n\nWhen using the Protobuf emitter, a Protobuf service designation is applied to an _interface_ within a package. For example, the following TypeSpec:\n\n```typespec\n@package\nnamespace Example {\n  @Protobuf.service\n  interface Test {\n    // ...\n  }\n}\n```\n\nwill yield the following Protobuf file (named `example.proto`):\n\n```proto3\nsyntax = \"proto3\";\n\npackage example;\n\nservice Test {\n  // ...\n}\n```\n\n#### Operations\n\nWithin a [service interface](#services), TypeSpec operations represent Protobuf service methods. Each operation in the service interface is converted into an equivalent Protobuf method declaration. For example, the following specification:\n\n```typespec\nmodel Input {\n  @field(1) exampleField: string;\n}\n\nmodel Output {\n  @field(1) parsed: uint32;\n}\n\n@Protobuf.service\ninterface Example {\n  testOperation(...Input): Output;\n}\n```\n\nResults in the following `.proto` file:\n\n```proto3\nmessage Input {\n  string exampleField = 1;\n}\n\nmessage Output {\n  uint32 parsed = 1;\n}\n\nservice Example {\n  rpc TestOperation(Input) returns (Output);\n}\n```\n\n#### Streams\n\nThe Protobuf emitter supports declaring the streaming mode of an operation using the [`TypeSpec.Protobuf.stream` decorator][protobuf-stream]. The streaming mode is specified using the [`StreamMode`][protobuf-stream-mode] enum. An operation can have one of four streaming modes:\n\n- `None`: this is the default mode and indicates that neither the request nor response are streamed.\n\n  Example: `rpc Example(In) returns (Out);`\n\n- `In`: indicates that the request is streamed, but the response is received synchronously.\n\n  Example: `rpc Example(stream In) returns (Out);`\n\n- `Out`: indicates that the request is sent synchronously, but the response is streamed.\n\n  Example: `rpc Example(In) returns (stream Out);`\n\n- `Duplex`: indicates that both the request and response are streamed.\n\n  Example: `rpc Example(stream In) returns (stream Out);`\n\n[native-service]: ../built-in-decorators#service\n[protobuf-service]: reference/decorators#@TypeSpec.Protobuf.service\n[protobuf-package]: reference/decorators#@TypeSpec.Protobuf.package\n[protobuf-field]: reference/decorators#@TypeSpec.Protobuf.field\n[protobuf-stream]: reference/decorators#@TypeSpec.Protobuf.stream\n[protobuf-stream-mode]: reference/data-types#TypeSpec.Protobuf.StreamMode\n[protobuf-message]: reference/decorators#@TypeSpec.Protobuf.message\n", "file_path": "../../core/docs\\standard-library\\protobuf\\guide.md", "link_to_file": "file://../../core/docs\\standard-library\\protobuf\\guide.md"}, {"file_content": "---\ntitle: \"Data types\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Data types\n\n## TypeSpec.Protobuf\n\n### `Extern` {#TypeSpec.Protobuf.Extern}\n\nA model that represents an external Protobuf reference. This type can be used to import and utilize Protobuf\ndeclarations that are not declared in TypeSpec within TypeSpec sources. When the emitter encounters an `Extern`, it\nwill insert an `import` statement for the corresponding `Path` and refer to the type by `Name`.\n\n#### Usage\n\nIf you have a file called `test.proto` that declares a package named `test` and a message named `Widget`, you can\nuse the `Extern` type to declare a model in TypeSpec that refers to your external definition of `test.Widget`. See\nthe example below.\n\nWhen the TypeSpec definition of `Widget` is encountered, the Protobuf emitter will represent it as a reference to\n`test.Widget` and insert an import for it, rather than attempt to convert the model to an equivalent message.\n\n```typespec\nmodel TypeSpec.Protobuf.Extern<Path, Name>\n```\n\n#### Template Parameters\n\n| Name | Description                                                                              |\n| ---- | ---------------------------------------------------------------------------------------- |\n| Path | the relative path to a `.proto` file to import                                           |\n| Name | the fully-qualified reference to the type this model represents within the `.proto` file |\n\n#### Examples\n\n```typespec\nmodel Widget is Extern<\"path/to/test.proto\", \"test.Widget\">;\n```\n\n### `Map` {#TypeSpec.Protobuf.Map}\n\nA type representing a Protobuf `map`. Instances of this type in models will be converted to the built-in `map` type\nin Protobuf.\n\nThe key type of a Protobuf `map` must be any integral type or `string`. The value type can be any type other than\nanother `Map`.\n\n```typespec\nmodel TypeSpec.Protobuf.Map<K, V>\n```\n\n#### Template Parameters\n\n| Name | Description                                      |\n| ---- | ------------------------------------------------ |\n| K    | the key type (any integral type or string)       |\n| V    | the value type (any type other than another map) |\n\n### `PackageDetails` {#TypeSpec.Protobuf.PackageDetails}\n\nDetails applied to a package definition by the [`@package`](./decorators#\n\n```typespec\nmodel TypeSpec.Protobuf.PackageDetails\n```\n\n### `StreamMode` {#TypeSpec.Protobuf.StreamMode}\n\nThe streaming mode of an operation. One of:\n\n- `Duplex`: both the input and output of the operation are streaming.\n- `In`: the input of the operation is streaming.\n- `Out`: the output of the operation is streaming.\n- `None`: neither the input nor the output are streaming.\n\nSee the [`@stream`](./decorators#\n\n```typespec\nenum TypeSpec.Protobuf.StreamMode\n```\n\n### `fixed32` {#TypeSpec.Protobuf.fixed32}\n\nAn unsigned 32-bit integer that will use the `fixed32` encoding when used in a Protobuf message.\n\n#### Protobuf binary format\n\nAlways four bytes. More efficient than `uint32` if values are often greater than 2<sup>28</sup>.\n\n```typespec\nscalar TypeSpec.Protobuf.fixed32\n```\n\n### `fixed64` {#TypeSpec.Protobuf.fixed64}\n\nAn unsigned 64-bit integer that will use the `fixed64` encoding when used in a Protobuf message.\n\n#### Protobuf binary format\n\nAlways eight bytes. More efficient than `uint64` if values are often greater than 2<sup>56</sup>.\n\n```typespec\nscalar TypeSpec.Protobuf.fixed64\n```\n\n### `sfixed32` {#TypeSpec.Protobuf.sfixed32}\n\nA signed 32-bit integer that will use the `sfixed32` encoding when used in a Protobuf message.\n\n#### Protobuf binary format\n\nAlways four bytes.\n\n```typespec\nscalar TypeSpec.Protobuf.sfixed32\n```\n\n### `sfixed64` {#TypeSpec.Protobuf.sfixed64}\n\nA signed 64-bit integer that will use the `sfixed64` encoding when used in a Protobuf message.\n\n#### Protobuf binary format\n\nAlways eight bytes.\n\n```typespec\nscalar TypeSpec.Protobuf.sfixed64\n```\n\n### `sint32` {#TypeSpec.Protobuf.sint32}\n\nA signed 32-bit integer that will use the `sint32` encoding when used in a Protobuf message.\n\n#### Protobuf binary format\n\nUses variable-length encoding. These more efficiently encode negative numbers than regular int32s.\n\n```typespec\nscalar TypeSpec.Protobuf.sint32\n```\n\n### `sint64` {#TypeSpec.Protobuf.sint64}\n\nA signed 64-bit integer that will use the `sint64` encoding when used in a Protobuf message.\n\n#### Protobuf binary format\n\nUses variable-length encoding. These more efficiently encode negative numbers than regular `int64s`.\n\n```typespec\nscalar TypeSpec.Protobuf.sint64\n```\n\n## TypeSpec.Protobuf.WellKnown\n\n### `Any` {#TypeSpec.Protobuf.WellKnown.Any}\n\nAny value.\n\nThis model references `google.protobuf.Any` from `google/protobuf/any.proto`.\n\n```typespec\nmodel TypeSpec.Protobuf.WellKnown.Any\n```\n\n### `Empty` {#TypeSpec.Protobuf.WellKnown.Empty}\n\nAn empty message.\n\nThis model references `google.protobuf.Empty` from `google/protobuf/empty.proto`.\n\n```typespec\nmodel TypeSpec.Protobuf.WellKnown.Empty\n```\n\n### `LatLng` {#TypeSpec.Protobuf.WellKnown.LatLng}\n\nA latitude and longitude.\n\nThis model references `google.type.LatLng` from `google/type/latlng.proto`.\n\n```typespec\nmodel TypeSpec.Protobuf.WellKnown.LatLng\n```\n\n### `Timestamp` {#TypeSpec.Protobuf.WellKnown.Timestamp}\n\nA timestamp.\n\nThis model references `google.protobuf.Timestamp` from `google/protobuf/timestamp.proto`.\n\n```typespec\nmodel TypeSpec.Protobuf.WellKnown.Timestamp\n```\n", "file_path": "../../core/docs\\standard-library\\protobuf\\reference\\data-types.md", "link_to_file": "file://../../core/docs\\standard-library\\protobuf\\reference\\data-types.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.Protobuf\n\n### `@field` {#@TypeSpec.Protobuf.field}\n\nDefines the field index of a model property for conversion to a Protobuf\nmessage.\n\nThe field index of a Protobuf message must:\n\n- fall between 1 and 2<sup>29</sup> - 1, inclusive.\n- not fall within the implementation reserved range of 19000 to 19999, inclusive.\n- not fall within any range that was [marked reserved](#\n\n```typespec\n@TypeSpec.Protobuf.field(index: valueof uint32)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\n| Name  | Type                    | Description                          |\n| ----- | ----------------------- | ------------------------------------ |\n| index | `valueof scalar uint32` | The whole-number index of the field. |\n\n#### Examples\n\n```typespec\nmodel ExampleMessage {\n  @field(1)\n  test: string;\n}\n```\n\n### `@message` {#@TypeSpec.Protobuf.message}\n\nDeclares that a model is a Protobuf message.\n\nMessages can be detected automatically if either of the following two conditions are met:\n\n- The model has a `@field` annotation on all of its properties.\n- The model is referenced by any service operation.\n\nThis decorator will force the emitter to check and emit a model.\n\n```typespec\n@TypeSpec.Protobuf.message\n```\n\n#### Target\n\n`model {}`\n\n#### Parameters\n\nNone\n\n### `@package` {#@TypeSpec.Protobuf.package}\n\nDeclares that a TypeSpec namespace constitutes a Protobuf package. The contents of the namespace will be emitted to a\nsingle Protobuf file.\n\n```typespec\n@TypeSpec.Protobuf.package(details?: TypeSpec.Protobuf.PackageDetails)\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n\n| Name    | Type                                     | Description                         |\n| ------- | ---------------------------------------- | ----------------------------------- |\n| details | `model TypeSpec.Protobuf.PackageDetails` | the optional details of the package |\n\n### `@reserve` {#@TypeSpec.Protobuf.reserve}\n\nReserve a field index, range, or name. If a field definition collides with a reservation, the emitter will produce\nan error.\n\nThis decorator accepts multiple reservations. Each reservation is one of the following:\n\n- a `string`, in which case the reservation refers to a field name.\n- a `uint32`, in which case the reservation refers to a field index.\n- a tuple `[uint32, uint32]`, in which case the reservation refers to a field range that is _inclusive_ of both ends.\n\nUnlike in Protobuf, where field name and index reservations must be separated, you can mix string and numeric field\nreservations in a single `@reserve` call in TypeSpec.\n\n#### API Compatibility Note\n\nField reservations prevent users of your Protobuf specification from using the given field names or indices. This can\nbe useful if a field is removed, as it will further prevent adding a new, incompatible field and will prevent users\nfrom utilizing the field index at runtime in a way that may break compatibility with users of older specifications.\n\nSee _[Protobuf Language Guide - Reserved Fields](https://protobuf.dev/programming-guides/proto3/#reserved)_ for more\ninformation.\n\n```typespec\n@TypeSpec.Protobuf.reserve(...reservations: valueof string | [uint32, uint32] | uint32[])\n```\n\n#### Target\n\n`model {}`\n\n#### Parameters\n\n| Name         | Type                                                   | Description                  |\n| ------------ | ------------------------------------------------------ | ---------------------------- |\n| reservations | `valueof model string \\| [uint32, uint32] \\| uint32[]` | a list of field reservations |\n\n#### Examples\n\n```typespec\n// Reserve the fields 8-15 inclusive, 100, and the field name \"test\" within a model.\n@reserve([8, 15], 100, \"test\")\nmodel Example {\n  // ...\n}\n```\n\n### `@service` {#@TypeSpec.Protobuf.service}\n\nDeclares that a TypeSpec interface constitutes a Protobuf service. The contents of the interface will be converted to\na `service` declaration in the resulting Protobuf file.\n\n```typespec\n@TypeSpec.Protobuf.service\n```\n\n#### Target\n\n`Interface`\n\n#### Parameters\n\nNone\n\n### `@stream` {#@TypeSpec.Protobuf.stream}\n\nSet the streaming mode of an operation. See [StreamMode](./data-types#TypeSpec.Protobuf.StreamMode) for more information.\n\n```typespec\n@TypeSpec.Protobuf.stream(mode: TypeSpec.Protobuf.StreamMode)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name | Type                                | Description                                    |\n| ---- | ----------------------------------- | ---------------------------------------------- |\n| mode | `enum TypeSpec.Protobuf.StreamMode` | The streaming mode to apply to this operation. |\n\n#### Examples\n\n```typespec\n@stream(StreamMode.Out)\nop logs(...LogsRequest): LogEvent;\n```\n\n```typespec\n@stream(StreamMode.Duplex)\nop connectToMessageService(...Message): Message;\n```\n", "file_path": "../../core/docs\\standard-library\\protobuf\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\protobuf\\reference\\decorators.md"}, {"file_content": "---\ntitle: \"Emitter usage\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Emitter\n\n## Usage\n\n1. Via the command line\n\n```bash\ntsp compile . --emit=@typespec/protobuf\n```\n\n2. Via the config\n\n```yaml\nemit:\n  - \"@typespec/protobuf\"\n```\n\n## Emitter options\n\n### `noEmit`\n\n**Type:** `boolean`\n\nIf set to `true`, this emitter will not write any files. It will still validate the TypeSpec sources to ensure they are compatible with Protobuf, but the files will simply not be written to the output directory.\n\n### `omit-unreachable-types`\n\n**Type:** `boolean`\n\nBy default, the emitter will create `message` declarations for any models in a namespace decorated with `@package` that have an `@field` decorator on every property. If this option is set to true, this behavior will be disabled, and only messages that are explicitly decorated with `@message` or that are reachable from a service operation will be emitted.\n", "file_path": "../../core/docs\\standard-library\\protobuf\\reference\\emitter.md", "link_to_file": "file://../../core/docs\\standard-library\\protobuf\\reference\\emitter.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec library and emitter for Protobuf (gRPC)\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/protobuf\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/protobuf\n```\n\n</TabItem>\n</Tabs>\n\n## Emitter usage\n\n[See documentation](./emitter.md)\n\n## TypeSpec.Protobuf\n\n### Decorators\n\n- [`@field`](./decorators.md#@TypeSpec.Protobuf.field)\n- [`@message`](./decorators.md#@TypeSpec.Protobuf.message)\n- [`@package`](./decorators.md#@TypeSpec.Protobuf.package)\n- [`@reserve`](./decorators.md#@TypeSpec.Protobuf.reserve)\n- [`@service`](./decorators.md#@TypeSpec.Protobuf.service)\n- [`@stream`](./decorators.md#@TypeSpec.Protobuf.stream)\n\n### Models\n\n- [`Extern`](./data-types.md#TypeSpec.Protobuf.Extern)\n- [`Map`](./data-types.md#TypeSpec.Protobuf.Map)\n- [`PackageDetails`](./data-types.md#TypeSpec.Protobuf.PackageDetails)\n\n## TypeSpec.Protobuf.WellKnown\n\n### Models\n\n- [`Any`](./data-types.md#TypeSpec.Protobuf.WellKnown.Any)\n- [`Empty`](./data-types.md#TypeSpec.Protobuf.WellKnown.Empty)\n- [`LatLng`](./data-types.md#TypeSpec.Protobuf.WellKnown.LatLng)\n- [`Timestamp`](./data-types.md#TypeSpec.Protobuf.WellKnown.Timestamp)\n", "file_path": "../../core/docs\\standard-library\\protobuf\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\protobuf\\reference\\index.mdx"}, {"file_content": "---\ntitle: Cheat sheet\n---\n\n## Resource Routing\n\n_Details: [Resource Routing](./resource-routing.md)_\n\n| Feature                  | Example                                                                             | Resolved Route |\n| ------------------------ | ----------------------------------------------------------------------------------- | -------------- |\n| Auto route               | `@autoRoute op get(@segment(\"pets\") @path id: string): void`                        | `/pets/{id}`   |\n| Custom segment seperator | `@autoRoute op get(@segment(\"pets\") @path @segmentSeparator(\":\") id: string): void` | `:pets/{id}`   |\n", "file_path": "../../core/docs\\standard-library\\rest\\cheat-sheet.md", "link_to_file": "file://../../core/docs\\standard-library\\rest\\cheat-sheet.md"}, {"file_content": "---\ntitle: Resource and routes\n---\n\n# Resources & routes\n\nResources are operations that are grouped in a namespace. You declare such a namespace by adding the `@route` decorator to provide the path to that resource:\n\n```typespec\nusing TypeSpec.Http;\n\n@route(\"/pets\")\nnamespace Pets {\n\n}\n```\n\nTo define an operation on this resource, you need to provide the HTTP verb for the route using the `@get`, `@head` `@post`, `@put`, `@patch`, or `@delete` decorators. If an HTTP method decorator is not specified then the default is post if there is a body and get otherwise. Lets add an operation to our `Pets` resource:\n\n```typespec\n@route(\"/pets\")\nnamespace Pets {\n  op list(): Pet[];\n\n  // or you could also use\n  @get op listPets(): Pet[];\n}\n```\n\nIf `@route` is applied to an interface, that route is not \"portable\". It will be applied to that interface but will not carry over if another interface extends it.\n\n```typespec\n// Operations prepended with /pets\n@route(\"/pets\")\ninterface PetOps {\n  list(): Pet[]\n}\n\n// Operations will *not* be prepended with /pets\ninterface MyPetOps extends PetOps {\n  ...\n}\n```\n\n### Automatic route generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate routes from operation parameters by applying the `@autoRoute` decorator to an operation or interface containing operations.\n\nFor this to work, an operation's path parameters (those marked with `@path`) must also be marked with\nthe `@segment` decorator to define the preceding path segment.\n\nThis is especially useful when reusing common parameter sets defined as model types.\n\nFor example:\n\n```typespec\nmodel CommonParameters {\n  @path\n  @segment(\"tenants\")\n  tenantId: string;\n\n  @path\n  @segment(\"users\")\n  userName: string;\n}\n\n@autoRoute\ninterface UserOperations {\n  @get\n  getUser(...CommonParameters): User | Error;\n\n  @put\n  updateUser(...CommonParameters, user: User): User | Error;\n}\n```\n\nThis will result in the following route for both operations\n\n```text\n/tenants/{tenantId}/users/{userName}\n```\n\nIf `@autoRoute` is applied to an interface, it is not \"portable\". It will be applied to that interface but will not carry over if another interface extends it.\n\n```typespec\n// Operations prepended with /pets\n@autoRoute\ninterface PetOps {\n  action(@path @segment(\"pets\") id: string): void;\n}\n\n// Operations will *not* be prepended with /pets\ninterface MyPetOps extends PetOps {\n  ...\n}\n```\n\n### Customizing Automatic Route Generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate\nroutes from operation parameters by applying the `@autoRoute` decorator to an operation, namespace,\nor interface containing operations.\n", "file_path": "../../core/docs\\standard-library\\rest\\resource-routing.md", "link_to_file": "file://../../core/docs\\standard-library\\rest\\resource-routing.md"}, {"file_content": "---\ntitle: \"Data types\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Data types\n\n## TypeSpec.Rest\n\n### `ResourceLocation` {#TypeSpec.Rest.ResourceLocation}\n\nA URL that points to a resource.\n\n```typespec\nscalar TypeSpec.Rest.ResourceLocation\n```\n\n## TypeSpec.Rest.Resource\n\n### `CollectionWithNextLink` {#TypeSpec.Rest.Resource.CollectionWithNextLink}\n\nStructure for a paging response using `value` and `nextLink` to represent pagination.\nThis only provides the model structure and not actual pagination support.\nSee https://github.com/microsoft/typespec/issues/705 for general paging support.\n\n```typespec\nmodel TypeSpec.Rest.Resource.CollectionWithNextLink<T>\n```\n\n#### Template Parameters\n\n| Name | Description                          |\n| ---- | ------------------------------------ |\n| T    | The resource type of the collection. |\n\n### `KeysOf` {#TypeSpec.Rest.Resource.KeysOf}\n\nDynamically gathers keys of the model type T.\n\n```typespec\nmodel TypeSpec.Rest.Resource.KeysOf<T>\n```\n\n#### Template Parameters\n\n| Name | Description       |\n| ---- | ----------------- |\n| T    | The target model. |\n\n### `ParentKeysOf` {#TypeSpec.Rest.Resource.ParentKeysOf}\n\nDynamically gathers parent keys of the model type T.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ParentKeysOf<T>\n```\n\n#### Template Parameters\n\n| Name | Description       |\n| ---- | ----------------- |\n| T    | The target model. |\n\n### `ResourceCollectionParameters` {#TypeSpec.Rest.Resource.ResourceCollectionParameters}\n\nRepresents collection operation parameters for resource TResource.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceCollectionParameters<TResource>\n```\n\n#### Template Parameters\n\n| Name      | Description         |\n| --------- | ------------------- |\n| TResource | The resource model. |\n\n### `ResourceCreatedResponse` {#TypeSpec.Rest.Resource.ResourceCreatedResponse}\n\nResource create operation completed successfully.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceCreatedResponse<T>\n```\n\n#### Template Parameters\n\n| Name | Description                          |\n| ---- | ------------------------------------ |\n| T    | The resource model that was created. |\n\n### `ResourceCreateModel` {#TypeSpec.Rest.Resource.ResourceCreateModel}\n\nResource create operation model.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceCreateModel<TResource>\n```\n\n#### Template Parameters\n\n| Name      | Description                   |\n| --------- | ----------------------------- |\n| TResource | The resource model to create. |\n\n### `ResourceCreateOrUpdateModel` {#TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel}\n\nResource create or update operation model.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>\n```\n\n#### Template Parameters\n\n| Name      | Description                             |\n| --------- | --------------------------------------- |\n| TResource | The resource model to create or update. |\n\n### `ResourceDeletedResponse` {#TypeSpec.Rest.Resource.ResourceDeletedResponse}\n\nResource deleted successfully.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceDeletedResponse\n```\n\n### `ResourceError` {#TypeSpec.Rest.Resource.ResourceError}\n\nThe default error response for resource operations.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceError\n```\n\n### `ResourceParameters` {#TypeSpec.Rest.Resource.ResourceParameters}\n\nRepresents operation parameters for resource TResource.\n\n```typespec\nmodel TypeSpec.Rest.Resource.ResourceParameters<TResource>\n```\n\n#### Template Parameters\n\n| Name      | Description         |\n| --------- | ------------------- |\n| TResource | The resource model. |\n", "file_path": "../../core/docs\\standard-library\\rest\\reference\\data-types.md", "link_to_file": "file://../../core/docs\\standard-library\\rest\\reference\\data-types.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.Rest\n\n### `@action` {#@TypeSpec.Rest.action}\n\nSpecify this operation is an action. (Scoped to a resource item /pets/{petId}/my-action)\n\n```typespec\n@TypeSpec.Rest.action(name?: valueof string)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name | Type                    | Description                                                                   |\n| ---- | ----------------------- | ----------------------------------------------------------------------------- |\n| name | `valueof scalar string` | Name of the action. If not specified, the name of the operation will be used. |\n\n### `@actionSeparator` {#@TypeSpec.Rest.actionSeparator}\n\nDefines the separator string that is inserted before the action name in auto-generated routes for actions.\n\n```typespec\n@TypeSpec.Rest.actionSeparator(seperator: valueof / | : | /:)\n```\n\n#### Target\n\n`union Model | ModelProperty | Operation`\n\n#### Parameters\n\n| Name      | Type                         | Description                                                      |\n| --------- | ---------------------------- | ---------------------------------------------------------------- |\n| seperator | `valueof union / \\| : \\| /:` | Seperator seperating the action segment from the rest of the url |\n\n### `@autoRoute` {#@TypeSpec.Rest.autoRoute}\n\nThis interface or operation should resolve its route automatically. To be used with resource types where the route segments area defined on the models.\n\n```typespec\n@TypeSpec.Rest.autoRoute\n```\n\n#### Target\n\n`union Interface | Operation`\n\n#### Parameters\n\nNone\n\n#### Examples\n\n```typespec\n@autoRoute\ninterface Pets {\n  get(@segment(\"pets\") @path id: string): void; //-> route: /pets/{id}\n}\n```\n\n### `@collectionAction` {#@TypeSpec.Rest.collectionAction}\n\nSpecify this operation is a collection action. (Scopped to a resource, /pets/my-action)\n\n```typespec\n@TypeSpec.Rest.collectionAction(resourceType: Model, name?: valueof string)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type                    | Description                                                                   |\n| ------------ | ----------------------- | ----------------------------------------------------------------------------- |\n| resourceType | `Model`                 | Resource marked with                                                          |\n| name         | `valueof scalar string` | Name of the action. If not specified, the name of the operation will be used. |\n\n### `@copyResourceKeyParameters` {#@TypeSpec.Rest.copyResourceKeyParameters}\n\nCopy the resource key parameters on the model\n\n```typespec\n@TypeSpec.Rest.copyResourceKeyParameters(filter?: valueof string)\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n\n| Name   | Type                    | Description                           |\n| ------ | ----------------------- | ------------------------------------- |\n| filter | `valueof scalar string` | Filter to exclude certain properties. |\n\n### `@createsOrReplacesResource` {#@TypeSpec.Rest.createsOrReplacesResource}\n\nSpecify that this is a CreateOrReplace operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.createsOrReplacesResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n\n### `@createsOrUpdatesResource` {#@TypeSpec.Rest.createsOrUpdatesResource}\n\nSpecify that this is a CreatesOrUpdate operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.createsOrUpdatesResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n\n### `@createsResource` {#@TypeSpec.Rest.createsResource}\n\nSpecify that this is a Create operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.createsResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n\n### `@deletesResource` {#@TypeSpec.Rest.deletesResource}\n\nSpecify that this is a Delete operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.deletesResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n\n### `@listsResource` {#@TypeSpec.Rest.listsResource}\n\nSpecify that this is a List operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.listsResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n\n### `@parentResource` {#@TypeSpec.Rest.parentResource}\n\nMark model as a child of the given parent resource.\n\n```typespec\n@TypeSpec.Rest.parentResource(parent: Model)\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n\n| Name   | Type    | Description   |\n| ------ | ------- | ------------- |\n| parent | `Model` | Parent model. |\n\n### `@readsResource` {#@TypeSpec.Rest.readsResource}\n\nSpecify that this is a Read operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.readsResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n\n### `@resource` {#@TypeSpec.Rest.resource}\n\nMark this model as a resource type with a name.\n\n```typespec\n@TypeSpec.Rest.resource(collectionName: valueof string)\n```\n\n#### Target\n\n`Model`\n\n#### Parameters\n\n| Name           | Type                    | Description            |\n| -------------- | ----------------------- | ---------------------- |\n| collectionName | `valueof scalar string` | type's collection name |\n\n### `@segment` {#@TypeSpec.Rest.segment}\n\nDefines the preceding path segment for a\n\n```typespec\n@TypeSpec.Rest.segment(name: valueof string)\n```\n\n#### Target\n\n`union Model | ModelProperty | Operation`\n\n#### Parameters\n\n| Name | Type                    | Description                                                                                    |\n| ---- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n| name | `valueof scalar string` | Segment that will be inserted into the operation route before the path parameter's name field. |\n\n#### Examples\n\n### `@segmentOf` {#@TypeSpec.Rest.segmentOf}\n\nReturns the URL segment of a given model if it has `@segment` and `@key` decorator.\n\n```typespec\n@TypeSpec.Rest.segmentOf(type: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name | Type    | Description  |\n| ---- | ------- | ------------ |\n| type | `Model` | Target model |\n\n### `@updatesResource` {#@TypeSpec.Rest.updatesResource}\n\nSpecify that this is a Update operation for a given resource.\n\n```typespec\n@TypeSpec.Rest.updatesResource(resourceType: Model)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name         | Type    | Description          |\n| ------------ | ------- | -------------------- |\n| resourceType | `Model` | Resource marked with |\n", "file_path": "../../core/docs\\standard-library\\rest\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\rest\\reference\\decorators.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec REST protocol binding\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/rest\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/rest\n```\n\n</TabItem>\n</Tabs>\n\n## TypeSpec.Rest\n\n### Decorators\n\n- [`@action`](./decorators.md#@TypeSpec.Rest.action)\n- [`@actionSeparator`](./decorators.md#@TypeSpec.Rest.actionSeparator)\n- [`@autoRoute`](./decorators.md#@TypeSpec.Rest.autoRoute)\n- [`@collectionAction`](./decorators.md#@TypeSpec.Rest.collectionAction)\n- [`@copyResourceKeyParameters`](./decorators.md#@TypeSpec.Rest.copyResourceKeyParameters)\n- [`@createsOrReplacesResource`](./decorators.md#@TypeSpec.Rest.createsOrReplacesResource)\n- [`@createsOrUpdatesResource`](./decorators.md#@TypeSpec.Rest.createsOrUpdatesResource)\n- [`@createsResource`](./decorators.md#@TypeSpec.Rest.createsResource)\n- [`@deletesResource`](./decorators.md#@TypeSpec.Rest.deletesResource)\n- [`@listsResource`](./decorators.md#@TypeSpec.Rest.listsResource)\n- [`@parentResource`](./decorators.md#@TypeSpec.Rest.parentResource)\n- [`@readsResource`](./decorators.md#@TypeSpec.Rest.readsResource)\n- [`@resource`](./decorators.md#@TypeSpec.Rest.resource)\n- [`@segment`](./decorators.md#@TypeSpec.Rest.segment)\n- [`@segmentOf`](./decorators.md#@TypeSpec.Rest.segmentOf)\n- [`@updatesResource`](./decorators.md#@TypeSpec.Rest.updatesResource)\n\n## TypeSpec.Rest.Resource\n\n### Interfaces\n\n- [`ExtensionResourceCollectionOperations`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations)\n- [`ExtensionResourceCreate`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceCreate)\n- [`ExtensionResourceCreateOrUpdate`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceCreateOrUpdate)\n- [`ExtensionResourceDelete`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceDelete)\n- [`ExtensionResourceInstanceOperations`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations)\n- [`ExtensionResourceList`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceList)\n- [`ExtensionResourceOperations`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceOperations)\n- [`ExtensionResourceRead`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceRead)\n- [`ExtensionResourceUpdate`](./interfaces.md#TypeSpec.Rest.Resource.ExtensionResourceUpdate)\n- [`ResourceCollectionOperations`](./interfaces.md#TypeSpec.Rest.Resource.ResourceCollectionOperations)\n- [`ResourceCreate`](./interfaces.md#TypeSpec.Rest.Resource.ResourceCreate)\n- [`ResourceCreateOrReplace`](./interfaces.md#TypeSpec.Rest.Resource.ResourceCreateOrReplace)\n- [`ResourceCreateOrUpdate`](./interfaces.md#TypeSpec.Rest.Resource.ResourceCreateOrUpdate)\n- [`ResourceDelete`](./interfaces.md#TypeSpec.Rest.Resource.ResourceDelete)\n- [`ResourceInstanceOperations`](./interfaces.md#TypeSpec.Rest.Resource.ResourceInstanceOperations)\n- [`ResourceList`](./interfaces.md#TypeSpec.Rest.Resource.ResourceList)\n- [`ResourceOperations`](./interfaces.md#TypeSpec.Rest.Resource.ResourceOperations)\n- [`ResourceRead`](./interfaces.md#TypeSpec.Rest.Resource.ResourceRead)\n- [`ResourceUpdate`](./interfaces.md#TypeSpec.Rest.Resource.ResourceUpdate)\n- [`SingletonResourceOperations`](./interfaces.md#TypeSpec.Rest.Resource.SingletonResourceOperations)\n- [`SingletonResourceRead`](./interfaces.md#TypeSpec.Rest.Resource.SingletonResourceRead)\n- [`SingletonResourceUpdate`](./interfaces.md#TypeSpec.Rest.Resource.SingletonResourceUpdate)\n\n### Models\n\n- [`CollectionWithNextLink`](./data-types.md#TypeSpec.Rest.Resource.CollectionWithNextLink)\n- [`KeysOf`](./data-types.md#TypeSpec.Rest.Resource.KeysOf)\n- [`ParentKeysOf`](./data-types.md#TypeSpec.Rest.Resource.ParentKeysOf)\n- [`ResourceCollectionParameters`](./data-types.md#TypeSpec.Rest.Resource.ResourceCollectionParameters)\n- [`ResourceCreatedResponse`](./data-types.md#TypeSpec.Rest.Resource.ResourceCreatedResponse)\n- [`ResourceCreateModel`](./data-types.md#TypeSpec.Rest.Resource.ResourceCreateModel)\n- [`ResourceCreateOrUpdateModel`](./data-types.md#TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel)\n- [`ResourceDeletedResponse`](./data-types.md#TypeSpec.Rest.Resource.ResourceDeletedResponse)\n- [`ResourceError`](./data-types.md#TypeSpec.Rest.Resource.ResourceError)\n- [`ResourceParameters`](./data-types.md#TypeSpec.Rest.Resource.ResourceParameters)\n", "file_path": "../../core/docs\\standard-library\\rest\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\rest\\reference\\index.mdx"}, {"file_content": "---\ntitle: \"Interfaces and Operations\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Interfaces and Operations\n\n## TypeSpec.Rest.Resource\n\n### `ExtensionResourceCollectionOperations` {#TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations}\n\nExtension resource operation templates for extension resource collections.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceCollectionOperations.create` {#TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations.create}\n\nCreates a new instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations.create(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TExtension | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n#### `ExtensionResourceCollectionOperations.list` {#TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations.list}\n\nLists all instances of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceCollectionOperations.list(): TypeSpec.Rest.Resource.CollectionWithNextLink<T> | TError\n```\n\n### `ExtensionResourceCreate` {#TypeSpec.Rest.Resource.ExtensionResourceCreate}\n\nExtension resource create operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceCreate<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceCreate.create` {#TypeSpec.Rest.Resource.ExtensionResourceCreate.create}\n\nCreates a new instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceCreate.create(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TExtension | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n### `ExtensionResourceCreateOrUpdate` {#TypeSpec.Rest.Resource.ExtensionResourceCreateOrUpdate}\n\nExtension resource create or update operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceCreateOrUpdate<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceCreateOrUpdate.createOrUpdate` {#TypeSpec.Rest.Resource.ExtensionResourceCreateOrUpdate.createOrUpdate}\n\nCreates or update an instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceCreateOrUpdate.createOrUpdate(resource: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TExtension | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n### `ExtensionResourceDelete` {#TypeSpec.Rest.Resource.ExtensionResourceDelete}\n\nExtension resource delete operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceDelete<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceDelete.delete` {#TypeSpec.Rest.Resource.ExtensionResourceDelete.delete}\n\nDeletes an existing instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceDelete.delete(): TypeSpec.Rest.Resource.ResourceDeletedResponse | TError\n```\n\n### `ExtensionResourceInstanceOperations` {#TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations}\n\nExtension resource operation templates for extension resource instances.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceInstanceOperations.get` {#TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations.get}\n\nGets an instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations.get(): TExtension | TError\n```\n\n#### `ExtensionResourceInstanceOperations.update` {#TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations.update}\n\nUpdates an existing instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TExtension | TError\n```\n\n#### `ExtensionResourceInstanceOperations.delete` {#TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations.delete}\n\nDeletes an existing instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceInstanceOperations.delete(): TypeSpec.Rest.Resource.ResourceDeletedResponse | TError\n```\n\n### `ExtensionResourceList` {#TypeSpec.Rest.Resource.ExtensionResourceList}\n\nExtension resource list operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceList<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceList.list` {#TypeSpec.Rest.Resource.ExtensionResourceList.list}\n\nLists all instances of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceList.list(): TypeSpec.Rest.Resource.CollectionWithNextLink<T> | TError\n```\n\n### `ExtensionResourceOperations` {#TypeSpec.Rest.Resource.ExtensionResourceOperations}\n\nExtension resource operation templates for extension resource instances and collections.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceOperations<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceOperations.get` {#TypeSpec.Rest.Resource.ExtensionResourceOperations.get}\n\nGets an instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceOperations.get(): TExtension | TError\n```\n\n#### `ExtensionResourceOperations.update` {#TypeSpec.Rest.Resource.ExtensionResourceOperations.update}\n\nUpdates an existing instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceOperations.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TExtension | TError\n```\n\n#### `ExtensionResourceOperations.delete` {#TypeSpec.Rest.Resource.ExtensionResourceOperations.delete}\n\nDeletes an existing instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceOperations.delete(): TypeSpec.Rest.Resource.ResourceDeletedResponse | TError\n```\n\n#### `ExtensionResourceOperations.create` {#TypeSpec.Rest.Resource.ExtensionResourceOperations.create}\n\nCreates a new instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceOperations.create(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TExtension | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n#### `ExtensionResourceOperations.list` {#TypeSpec.Rest.Resource.ExtensionResourceOperations.list}\n\nLists all instances of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceOperations.list(): TypeSpec.Rest.Resource.CollectionWithNextLink<T> | TError\n```\n\n### `ExtensionResourceRead` {#TypeSpec.Rest.Resource.ExtensionResourceRead}\n\nExtension resource read operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceRead<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceRead.get` {#TypeSpec.Rest.Resource.ExtensionResourceRead.get}\n\nGets an instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceRead.get(): TExtension | TError\n```\n\n### `ExtensionResourceUpdate` {#TypeSpec.Rest.Resource.ExtensionResourceUpdate}\n\nExtension resource update operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ExtensionResourceUpdate<TExtension, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TExtension | The extension resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `ExtensionResourceUpdate.update` {#TypeSpec.Rest.Resource.ExtensionResourceUpdate.update}\n\nUpdates an existing instance of the extension resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ExtensionResourceUpdate.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TExtension | TError\n```\n\n### `ResourceCollectionOperations` {#TypeSpec.Rest.Resource.ResourceCollectionOperations}\n\nResource operation templates for resource collections.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceCollectionOperations<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description         |\n| --------- | ------------------- |\n| TResource | The resource model. |\n| TError    | The error response. |\n\n#### `ResourceCollectionOperations.create` {#TypeSpec.Rest.Resource.ResourceCollectionOperations.create}\n\nCreates a new instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceCollectionOperations.create(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TResource | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n#### `ResourceCollectionOperations.list` {#TypeSpec.Rest.Resource.ResourceCollectionOperations.list}\n\nLists all instances of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceCollectionOperations.list(): TypeSpec.Rest.Resource.CollectionWithNextLink<T> | TError\n```\n\n### `ResourceCreate` {#TypeSpec.Rest.Resource.ResourceCreate}\n\nResource create operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceCreate<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description                   |\n| --------- | ----------------------------- |\n| TResource | The resource model to create. |\n| TError    | The error response.           |\n\n#### `ResourceCreate.create` {#TypeSpec.Rest.Resource.ResourceCreate.create}\n\nCreates a new instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceCreate.create(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TResource | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n### `ResourceCreateOrReplace` {#TypeSpec.Rest.Resource.ResourceCreateOrReplace}\n\nResource create or replace operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceCreateOrReplace<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description                              |\n| --------- | ---------------------------------------- |\n| TResource | The resource model to create or replace. |\n| TError    | The error response.                      |\n\n#### `ResourceCreateOrReplace.createOrReplace` {#TypeSpec.Rest.Resource.ResourceCreateOrReplace.createOrReplace}\n\nCreates or replaces a instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceCreateOrReplace.createOrReplace(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TResource | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n### `ResourceCreateOrUpdate` {#TypeSpec.Rest.Resource.ResourceCreateOrUpdate}\n\nResource create or update operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceCreateOrUpdate<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description                             |\n| --------- | --------------------------------------- |\n| TResource | The resource model to create or update. |\n| TError    | The error response.                     |\n\n#### `ResourceCreateOrUpdate.createOrUpdate` {#TypeSpec.Rest.Resource.ResourceCreateOrUpdate.createOrUpdate}\n\nCreates or update an instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceCreateOrUpdate.createOrUpdate(resource: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TResource | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n### `ResourceDelete` {#TypeSpec.Rest.Resource.ResourceDelete}\n\nResource delete operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceDelete<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description                   |\n| --------- | ----------------------------- |\n| TResource | The resource model to delete. |\n| TError    | The error response.           |\n\n#### `ResourceDelete.delete` {#TypeSpec.Rest.Resource.ResourceDelete.delete}\n\nDeletes an existing instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceDelete.delete(): TypeSpec.Rest.Resource.ResourceDeletedResponse | TError\n```\n\n### `ResourceInstanceOperations` {#TypeSpec.Rest.Resource.ResourceInstanceOperations}\n\nResource operation templates for resource instances.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceInstanceOperations<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description         |\n| --------- | ------------------- |\n| TResource | The resource model. |\n| TError    | The error response. |\n\n#### `ResourceInstanceOperations.get` {#TypeSpec.Rest.Resource.ResourceInstanceOperations.get}\n\nGets an instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceInstanceOperations.get(): TResource | TError\n```\n\n#### `ResourceInstanceOperations.update` {#TypeSpec.Rest.Resource.ResourceInstanceOperations.update}\n\nUpdates an existing instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceInstanceOperations.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TResource | TError\n```\n\n#### `ResourceInstanceOperations.delete` {#TypeSpec.Rest.Resource.ResourceInstanceOperations.delete}\n\nDeletes an existing instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceInstanceOperations.delete(): TypeSpec.Rest.Resource.ResourceDeletedResponse | TError\n```\n\n### `ResourceList` {#TypeSpec.Rest.Resource.ResourceList}\n\nResource list operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceList<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description                 |\n| --------- | --------------------------- |\n| TResource | The resource model to list. |\n| TError    | The error response.         |\n\n#### `ResourceList.list` {#TypeSpec.Rest.Resource.ResourceList.list}\n\nLists all instances of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceList.list(): TypeSpec.Rest.Resource.CollectionWithNextLink<T> | TError\n```\n\n### `ResourceOperations` {#TypeSpec.Rest.Resource.ResourceOperations}\n\nResource operation templates for resources.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceOperations<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description         |\n| --------- | ------------------- |\n| TResource | The resource model. |\n| TError    | The error response. |\n\n#### `ResourceOperations.get` {#TypeSpec.Rest.Resource.ResourceOperations.get}\n\nGets an instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceOperations.get(): TResource | TError\n```\n\n#### `ResourceOperations.update` {#TypeSpec.Rest.Resource.ResourceOperations.update}\n\nUpdates an existing instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceOperations.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TResource | TError\n```\n\n#### `ResourceOperations.delete` {#TypeSpec.Rest.Resource.ResourceOperations.delete}\n\nDeletes an existing instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceOperations.delete(): TypeSpec.Rest.Resource.ResourceDeletedResponse | TError\n```\n\n#### `ResourceOperations.create` {#TypeSpec.Rest.Resource.ResourceOperations.create}\n\nCreates a new instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceOperations.create(resource: TypeSpec.Rest.Resource.ResourceCreateModel<TResource>): TResource | TypeSpec.Rest.Resource.ResourceCreatedResponse<T> | TError\n```\n\n#### `ResourceOperations.list` {#TypeSpec.Rest.Resource.ResourceOperations.list}\n\nLists all instances of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceOperations.list(): TypeSpec.Rest.Resource.CollectionWithNextLink<T> | TError\n```\n\n### `ResourceRead` {#TypeSpec.Rest.Resource.ResourceRead}\n\nRepresent the resource GET operation.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceRead<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description         |\n| --------- | ------------------- |\n| TResource | The resource model. |\n| TError    | The error response. |\n\n#### `ResourceRead.get` {#TypeSpec.Rest.Resource.ResourceRead.get}\n\nGets an instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceRead.get(): TResource | TError\n```\n\n### `ResourceUpdate` {#TypeSpec.Rest.Resource.ResourceUpdate}\n\nResource update operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.ResourceUpdate<TResource, TError>\n```\n\n#### Template Parameters\n\n| Name      | Description                   |\n| --------- | ----------------------------- |\n| TResource | The resource model to update. |\n| TError    | The error response.           |\n\n#### `ResourceUpdate.update` {#TypeSpec.Rest.Resource.ResourceUpdate.update}\n\nUpdates an existing instance of the resource.\n\n```typespec\nop TypeSpec.Rest.Resource.ResourceUpdate.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TResource | TError\n```\n\n### `SingletonResourceOperations` {#TypeSpec.Rest.Resource.SingletonResourceOperations}\n\nSingleton resource operation templates for singleton resource instances.\n\n```typespec\ninterface TypeSpec.Rest.Resource.SingletonResourceOperations<TSingleton, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TSingleton | The singleton resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `SingletonResourceOperations.get` {#TypeSpec.Rest.Resource.SingletonResourceOperations.get}\n\nGets the singleton resource.\n\n```typespec\nop TypeSpec.Rest.Resource.SingletonResourceOperations.get(): TSingleton | TError\n```\n\n#### `SingletonResourceOperations.update` {#TypeSpec.Rest.Resource.SingletonResourceOperations.update}\n\nUpdates the singleton resource.\n\n```typespec\nop TypeSpec.Rest.Resource.SingletonResourceOperations.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TSingleton | TError\n```\n\n### `SingletonResourceRead` {#TypeSpec.Rest.Resource.SingletonResourceRead}\n\nSingleton resource read operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.SingletonResourceRead<TSingleton, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TSingleton | The singleton resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `SingletonResourceRead.get` {#TypeSpec.Rest.Resource.SingletonResourceRead.get}\n\nGets the singleton resource.\n\n```typespec\nop TypeSpec.Rest.Resource.SingletonResourceRead.get(): TSingleton | TError\n```\n\n### `SingletonResourceUpdate` {#TypeSpec.Rest.Resource.SingletonResourceUpdate}\n\nSingleton resource update operation template.\n\n```typespec\ninterface TypeSpec.Rest.Resource.SingletonResourceUpdate<TSingleton, TResource, TError>\n```\n\n#### Template Parameters\n\n| Name       | Description                   |\n| ---------- | ----------------------------- |\n| TSingleton | The singleton resource model. |\n| TResource  | The resource model.           |\n| TError     | The error response.           |\n\n#### `SingletonResourceUpdate.update` {#TypeSpec.Rest.Resource.SingletonResourceUpdate.update}\n\nUpdates the singleton resource.\n\n```typespec\nop TypeSpec.Rest.Resource.SingletonResourceUpdate.update(properties: TypeSpec.Rest.Resource.ResourceCreateOrUpdateModel<TResource>): TSingleton | TError\n```\n", "file_path": "../../core/docs\\standard-library\\rest\\reference\\interfaces.md", "link_to_file": "file://../../core/docs\\standard-library\\rest\\reference\\interfaces.md"}, {"file_content": "---\ntitle: Guide\n---\n\n## Creating Versioned APIs\n\nThe primary purpose of the TypeSpec.Versioning library is to provide a way to version APIs. Let's start with an unversioned API.\n\n```typespec\n@service({\n  title: \"Contoso Widget Manager\",\n})\nnamespace Contoso.WidgetManager;\n```\n\nTo make this API versioned, we need to add the `@versioned` decorator to the namespace and declare an enum that identifies the supported versions.\n\n```typespec\n@service({\n  title: \"Contoso Widget Manager\",\n})\n@versioned(Contoso.WidgetManager.Versions)\nnamespace Contoso.WidgetManager;\n\nenum Versions {\n  v1,\n}\n```\n\n## Declaring Versioned Dependencies\n\nBoth versioned and unversioned services can declare their dependency on versioned TypeSpec libraries. To declare a dependency on a versioned library, use the `@useDependency` decorator. For unversioned services, this will be declared on the namespace. For versioned services, this will be declared on the versioned enum.\n\nFor example, if our unversioned WidgetManager service has a dependency on the Azure.Core library, we would declare it like this:\n\n```typespec\n@service({\n  title: \"Contoso Widget Manager Unversioned\",\n})\n@useDependency(Azure.Core.v1_0_Preview_1)\nnamespace Contoso.WidgetManager.Unversioned;\n```\n\nIf our versioned WidgetManager service has a dependency on the Azure.Core library, we would declare it like this:\n\n```typespec\n@service({\n  title: \"Contoso Widget Manager\",\n})\n@versioned(Contoso.WidgetManager.Versions)\nnamespace Contoso.WidgetManager;\n\nenum Versions {\n  @useDependency(Azure.Core.v1_0_Preview_1)\n  v1,\n}\n```\n\nLet's assume we add a new version to our service, and it takes advantage of features in a newer version of the Azure.Core library. We can declare that dependency like this:\n\n```typespec\n@service({\n  title: \"Contoso Widget Manager\",\n})\n@versioned(Contoso.WidgetManager.Versions)\nnamespace Contoso.WidgetManager;\n\nenum Versions {\n  @useDependency(Azure.Core.v1_0_Preview_1)\n  v1,\n\n  @useDependency(Azure.Core.v1_0_Preview_2)\n  v2,\n}\n```\n\n## Versioning APIs\n\nThe versioning library makes it easy to version APIs. Let's start with a simple example. Let's say we have a service that has a single API that returns a list of widgets. We can declare that API like this:\n\n```typespec\nusing TypeSpec.Versioning;\nusing TypeSpec.Rest;\nusing TypeSpec.Http;\n\n@service({\n  title: \"Contoso Widget Manager\",\n})\n@versioned(Contoso.WidgetManager.Versions)\nnamespace Contoso.WidgetManager;\n\nenum Versions {\n  v1,\n}\n\n@error\nmodel Error {\n  code: string;\n  message?: string;\n}\n\nmodel Widget {\n  @key\n  id: string;\n\n  name: string;\n}\n\nop list(): Widget[] | Error;\n```\n\nNow let's say that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\n\n```typespec\nenum Versions {\n  v1,\n  v2,\n}\n\nmodel Widget {\n  @key\n  id: string;\n\n  name: string;\n}\n\n@route(\"/widget\")\nop list(): Widget[] | Error;\n\n@added(Versions.v2)\n@route(\"/widget/{id}\")\nop get(...Resource.KeysOf<Widget>): Widget | Error;\n```\n\nNow let's say that in version 3 of the service, we realize that `name` is inaccurate and that this field should be called `description`. Also, you\ndon't always have a description, so you decide it should be optional, not required. We can make these changes like this:\n\n```typespec\nmodel Widget {\n  @key\n  widgetId: string;\n\n  @renamedFrom(Versions.v3, \"name\")\n  @madeOptional(Versions.v3)\n  description?: string;\n}\n```\n\nYou can see that we made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the\n`@renamedFrom` and `@madeOptional` decorators identify the version in which the change was made, and the `@renamedFrom` decorator also identifies the\nprevious name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\n\nThe OpenAPI defintion of `Widget` for version 3 reflects the change:\n\n```yaml\nWidget:\n  type: object\n  properties:\n    id:\n      type: string\n    description:\n      type: string\n  required:\n    - id\n```\n\nBut the OpenAPI definition for versions 1 and 2 still reflect the original name and required nature of the property:\n\n```yaml\nWidget:\n  type: object\n  properties:\n    id:\n      type: string\n    name:\n      type: string\n  required:\n    - id\n    - name\n```\n\nThis is the common pattern with the versioning decorators. The TypeSpec should reflect the _current state_ of the API. The decorators identify the\nversion at which this definition became true and, depending on the decorator, the other parameters reflect the preview values in order to preserve\nthat information.\n", "file_path": "../../core/docs\\standard-library\\versioning\\guide.md", "link_to_file": "file://../../core/docs\\standard-library\\versioning\\guide.md"}, {"file_content": "---\ntitle: \"Decorators\"\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\n# Decorators\n\n## TypeSpec.Versioning\n\n### `@added` {#@TypeSpec.Versioning.added}\n\nIdentifies when the target was added.\n\n```typespec\n@TypeSpec.Versioning.added(version: EnumMember)\n```\n\n#### Target\n\n`union Model | ModelProperty | Operation | Enum | EnumMember | Union | UnionVariant | Scalar | Interface`\n\n#### Parameters\n\n| Name    | Type         | Description                               |\n| ------- | ------------ | ----------------------------------------- |\n| version | `EnumMember` | The version that the target was added in. |\n\n#### Examples\n\n```tsp\n@added(Versions.v2)\nop addedInV2(): void;\n\n@added(Versions.v2)\nmodel AlsoAddedInV2 {}\n\nmodel Foo {\n  name: string;\n\n  @added(Versions.v3)\n  addedInV3: string;\n}\n```\n\n### `@madeOptional` {#@TypeSpec.Versioning.madeOptional}\n\nIdentifies when a target was made optional.\n\n```typespec\n@TypeSpec.Versioning.madeOptional(version: EnumMember)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\n| Name    | Type         | Description                                       |\n| ------- | ------------ | ------------------------------------------------- |\n| version | `EnumMember` | The version that the target was made optional in. |\n\n#### Examples\n\n```tsp\nmodel Foo {\n  name: string;\n\n  @madeOptional(Versions.v2)\n  nickname: string;\n}\n```\n\n### `@removed` {#@TypeSpec.Versioning.removed}\n\nIdentifies when the target was removed.\n\n```typespec\n@TypeSpec.Versioning.removed(version: EnumMember)\n```\n\n#### Target\n\n`union Model | ModelProperty | Operation | Enum | EnumMember | Union | UnionVariant | Scalar | Interface`\n\n#### Parameters\n\n| Name    | Type         | Description                                 |\n| ------- | ------------ | ------------------------------------------- |\n| version | `EnumMember` | The version that the target was removed in. |\n\n#### Examples\n\n```tsp\n@removed(Versions.v2)\nop removedInV2(): void;\n\n@removed(Versions.v2)\nmodel AlsoRemovedInV2 {}\n\nmodel Foo {\n  name: string;\n\n  @removed(Versions.v3)\n  removedInV3: string;\n}\n```\n\n### `@renamedFrom` {#@TypeSpec.Versioning.renamedFrom}\n\nIdentifies when the target has been renamed.\n\n```typespec\n@TypeSpec.Versioning.renamedFrom(version: EnumMember, oldName: valueof string)\n```\n\n#### Target\n\n`union Model | ModelProperty | Operation | Enum | EnumMember | Union | UnionVariant | Scalar | Interface`\n\n#### Parameters\n\n| Name    | Type                    | Description                                 |\n| ------- | ----------------------- | ------------------------------------------- |\n| version | `EnumMember`            | The version that the target was renamed in. |\n| oldName | `valueof scalar string` | The previous name of the target.            |\n\n#### Examples\n\n```tsp\n@renamedFrom(Versions.v2, \"oldName\")\nop newName(): void;\n```\n\n### `@returnTypeChangedFrom` {#@TypeSpec.Versioning.returnTypeChangedFrom}\n\nIdentifies when the target type changed.\n\n```typespec\n@TypeSpec.Versioning.returnTypeChangedFrom(version: EnumMember, oldType: unknown)\n```\n\n#### Target\n\n`Operation`\n\n#### Parameters\n\n| Name    | Type                  | Description                                  |\n| ------- | --------------------- | -------------------------------------------- |\n| version | `EnumMember`          | The version that the target type changed in. |\n| oldType | `(intrinsic) unknown` | The previous type of the target.             |\n\n### `@typeChangedFrom` {#@TypeSpec.Versioning.typeChangedFrom}\n\nIdentifies when the target type changed.\n\n```typespec\n@TypeSpec.Versioning.typeChangedFrom(version: EnumMember, oldType: unknown)\n```\n\n#### Target\n\n`ModelProperty`\n\n#### Parameters\n\n| Name    | Type                  | Description                                  |\n| ------- | --------------------- | -------------------------------------------- |\n| version | `EnumMember`          | The version that the target type changed in. |\n| oldType | `(intrinsic) unknown` | The previous type of the target.             |\n\n### `@useDependency` {#@TypeSpec.Versioning.useDependency}\n\nIdentifies that a namespace or a given versioning enum member relies upon a versioned package.\n\n```typespec\n@TypeSpec.Versioning.useDependency(...versionRecords: EnumMember[])\n```\n\n#### Target\n\n`union EnumMember | Namespace`\n\n#### Parameters\n\n| Name           | Type                 | Description                                                           |\n| -------------- | -------------------- | --------------------------------------------------------------------- |\n| versionRecords | `model EnumMember[]` | The dependent library version(s) for the target namespace or version. |\n\n#### Examples\n\n##### Select a single version of `MyLib` to use\n\n```tsp\n@useDependency(MyLib.Versions.v1_1)\nnamespace NonVersionedService;\n```\n\n##### Select which version of the library match to which version of the service.\n\n```tsp\n@versioned(Versions)\nnamespace MyService1;\nenum Version {\n  @useDependency(MyLib.Versions.v1_1) // V1 use lib v1_1\n  v1,\n  @useDependency(MyLib.Versions.v1_1) // V2 use lib v1_1\n  v2,\n  @useDependency(MyLib.Versions.v2) // V3 use lib v2\n  v3,\n}\n```\n\n### `@versioned` {#@TypeSpec.Versioning.versioned}\n\nIdentifies that the decorated namespace is versioned by the provided enum.\n\n```typespec\n@TypeSpec.Versioning.versioned(versions: Enum)\n```\n\n#### Target\n\n`Namespace`\n\n#### Parameters\n\n| Name     | Type   | Description                                     |\n| -------- | ------ | ----------------------------------------------- |\n| versions | `Enum` | The enum that describes the supported versions. |\n\n#### Examples\n\n```tsp\n@versioned(Versions)\nnamespace MyService;\nenum Versions {\n  v1,\n  v2,\n  v3,\n}\n```\n", "file_path": "../../core/docs\\standard-library\\versioning\\reference\\decorators.md", "link_to_file": "file://../../core/docs\\standard-library\\versioning\\reference\\decorators.md"}, {"file_content": "---\ntitle: Overview\nsidebar_position: 0\ntoc_min_heading_level: 2\ntoc_max_heading_level: 3\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n# Overview\n\nTypeSpec library for declaring and emitting versioned APIs\n\n## Install\n\n<Tabs>\n<TabItem value=\"spec\" label=\"In a spec\" default>\n\n```bash\nnpm install @typespec/versioning\n```\n\n</TabItem>\n<TabItem value=\"library\" label=\"In a library\" default>\n\n```bash\nnpm install --save-peer @typespec/versioning\n```\n\n</TabItem>\n</Tabs>\n\n## TypeSpec.Versioning\n\n### Decorators\n\n- [`@added`](./decorators.md#@TypeSpec.Versioning.added)\n- [`@madeOptional`](./decorators.md#@TypeSpec.Versioning.madeOptional)\n- [`@removed`](./decorators.md#@TypeSpec.Versioning.removed)\n- [`@renamedFrom`](./decorators.md#@TypeSpec.Versioning.renamedFrom)\n- [`@returnTypeChangedFrom`](./decorators.md#@TypeSpec.Versioning.returnTypeChangedFrom)\n- [`@typeChangedFrom`](./decorators.md#@TypeSpec.Versioning.typeChangedFrom)\n- [`@useDependency`](./decorators.md#@TypeSpec.Versioning.useDependency)\n- [`@versioned`](./decorators.md#@TypeSpec.Versioning.versioned)\n", "file_path": "../../core/docs\\standard-library\\versioning\\reference\\index.mdx", "link_to_file": "file://../../core/docs\\standard-library\\versioning\\reference\\index.mdx"}]