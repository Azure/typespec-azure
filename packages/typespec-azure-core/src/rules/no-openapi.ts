import {
  DecoratedType,
  Decorator,
  Type,
  createRule,
  getTypeName,
  paramMessage,
} from "@typespec/compiler";

export const noOpenAPIRule = createRule({
  name: "no-openapi",
  description:
    "Azure specs should not be using decorators from @typespec/openapi or @azure-tools/typespec-autorest",
  severity: "warning",
  messages: {
    default: paramMessage`Azure specs should not be using decorator "${"name"}" from @typespec/openapi or @azure-tools/typespec-autorest. They will not apply to other emitter.`,
    operationId:
      "Operation ID is automatically generated by the OpenAPI emitters and should not normally be specified.",
    useRef: "Using @useRef should never be used in Azure specs.",
    example:
      "Using @example decorator explicitly is not allowed. See https://azure.github.io/typespec-azure/docs/next/migrate-swagger/faq/x-ms-examples",
  },
  create(context) {
    function checkDecorators(type: DecoratedType & Type) {
      for (const dec of type.decorators) {
        if (dec.definition) {
          const id = getTypeName(dec.definition.namespace);
          if (id === "TypeSpec.OpenAPI" || id === "Autorest") {
            context.reportDiagnostic({
              target: dec.node ?? type,
              format: { name: dec.decorator.name },
              messageId: getMessageId(dec.definition),
            });
          }
        }
      }
    }
    return {
      model: checkDecorators,
      modelProperty: checkDecorators,
      enum: checkDecorators,
      union: checkDecorators,
      operation: checkDecorators,
      enumMember: checkDecorators,
      unionVariant: checkDecorators,
      interface: checkDecorators,
      namespace: checkDecorators,
    };
  },
});

function getMessageId(dec: Decorator) {
  switch (dec.name) {
    case "@operationId":
      return "operationId";
    case "@useRef":
      return "useRef";
    case "@example":
      return "example";
    default:
      return "default";
  }
}
