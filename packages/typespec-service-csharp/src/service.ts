import {
  BooleanLiteral,
  EmitContext,
  Enum,
  IntrinsicType,
  Model,
  ModelProperty,
  Namespace,
  NumericLiteral,
  Operation,
  Program,
  Scalar,
  StringLiteral,
  Tuple,
  Type,
  Union,
  getDoc,
  getNamespaceFullName,
  getService,
  isErrorModel,
  isType,
} from "@typespec/compiler";
import {
  CodeTypeEmitter,
  Context,
  Declaration,
  EmitEntity,
  EmittedSourceFile,
  EmitterOutput,
  Scope,
  SourceFile,
  StringBuilder,
  TypeSpecDeclaration,
  code,
  createAssetEmitter,
} from "@typespec/compiler/emitter-framework";
import {
  HttpOperation,
  HttpOperationParameter,
  HttpOperationResponse,
  MetadataInfo,
  Visibility,
  createMetadataInfo,
  getHttpOperation,
} from "@typespec/http";
import { getResourceOperation } from "@typespec/rest";
import { exec } from "child_process";
import {
  emitOperationState,
  emitOperationStatus,
  emitResourceOperationStatus,
} from "./boilerplate.js";
import { CSharpSourceType, CSharpType, ControllerContext, NameCasingType } from "./interfaces.js";
import { CSharpServiceEmitterOptions } from "./lib.js";
import {
  ensureCSharpIdentifier,
  ensureCleanDirectory,
  formatComment,
  getCSharpIdentifier,
  getCSharpStatusCode,
  getCSharpTypeForScalar,
  getOperationVerbDecorator,
  hasNonMetadataProperties,
  isValueType,
} from "./utils.js";

export async function $onEmit(context: EmitContext<CSharpServiceEmitterOptions>) {
  let _unionCounter: number = 0;
  const controllers = new Map<string, ControllerContext>();
  const NoResourceContext: string = "RPCOperations";

  class CSharpCodeEmitter extends CodeTypeEmitter {
    #licenseHeader = `// Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.`;
    #sourceTypeKey: string = "sourceType";

    #metaInfo: MetadataInfo = createMetadataInfo(this.emitter.getProgram(), {
      canonicalVisibility: Visibility.Read,
      canShareProperty: (p) => true,
    });

    arrayDeclaration(array: Model, name: string, elementType: Type): EmitterOutput<string> {
      return this.emitter.result.declaration(
        ensureCSharpIdentifier(this.emitter.getProgram(), array, name),
        code`${this.emitter.emitTypeReference(elementType)}[]`
      );
    }

    arrayLiteral(array: Model, elementType: Type): EmitterOutput<string> {
      return this.emitter.result.rawCode(code`${this.emitter.emitTypeReference(elementType)}[]`);
    }

    booleanLiteral(boolean: BooleanLiteral): EmitterOutput<string> {
      return this.emitter.result.rawCode(code`${boolean.value === true ? "true" : "false"}`);
    }

    unionLiteral(union: Union): EmitterOutput<string> {
      const csType = this.#coalesceUnionTypes(union);
      return this.emitter.result.rawCode(csType && csType.isBuiltIn ? csType.name : "object");
    }

    declarationName(declarationType: TypeSpecDeclaration): string {
      switch (declarationType.kind) {
        case "Enum":
        case "Interface":
        case "Model":
        case "Operation":
          return getCSharpIdentifier(declarationType.name, NameCasingType.Class);
        case "Union":
          if (!declarationType.name) return `Union${_unionCounter++}`;
          return declarationType.name;
        case "Scalar":
        default:
          return declarationType.name;
      }
    }

    enumDeclaration(en: Enum, name: string): EmitterOutput<string> {
      const enumName = ensureCSharpIdentifier(this.emitter.getProgram(), en, name);
      const namespace = this.emitter.getContext().namespace;
      const doc = getDoc(this.emitter.getProgram(), en);
      return this.emitter.result.declaration(
        enumName,
        code`${this.#licenseHeader}
        // <auto-generated />

        using Microsoft.TypeSpec.ProviderHub.Controller;
        using Newtonsoft.Json;
        
        namespace ${namespace}
        {

            ${doc ? `${formatComment(doc)}` : ""}
            [JsonConverter(typeof(EnumJsonConverter<${enumName}>))]
            public readonly partial struct ${enumName}
            {
              public static readonly ${enumName} ${this.emitter.emitEnumMembers(en)};
        
                private readonly string _value;
        
                public ${enumName}(string value) =>
                    _value = value;
        
                public override string ToString() =>
                    _value;
        
                public static implicit operator string(${enumName} obj) =>
                    obj.ToString();
        
                public static implicit operator ${enumName}(string str) =>
                    new ${enumName}(str);
            }
        } `
      );
    }

    enumDeclarationContext(en: Enum): Context {
      const enumName = ensureCSharpIdentifier(this.emitter.getProgram(), en, en.name);
      const enumFile = this.emitter.createSourceFile(`models/${enumName}.cs`);
      enumFile.meta[this.#sourceTypeKey] = CSharpSourceType.Model;
      const enumNamespace = `${
        en.namespace
          ? ensureCSharpIdentifier(
              this.emitter.getProgram(),
              en.namespace,
              getNamespaceFullName(en.namespace)
            )
          : "TypeSpec"
      }.Service.Models`;
      return {
        namespace: enumNamespace,
        file: enumFile,
        scope: enumFile.globalScope,
      };
    }

    enumMembers(en: Enum): EmitterOutput<string> {
      const result = new StringBuilder();
      let i = 0;
      for (const [name, member] of en.members) {
        i++;
        result.push(
          code`${ensureCSharpIdentifier(this.emitter.getProgram(), member, name)} = "${
            member.value ? (member.value as string) : name
          }"`
        );
        if (i < en.members.size) result.pushLiteralSegment(", ");
      }

      return this.emitter.result.rawCode(result.reduce());
    }

    intrinsic(intrinsic: IntrinsicType, name: string): EmitterOutput<string> {
      if (intrinsic.name === "unknown") {
        return this.emitter.result.rawCode(code`JsonObject`);
      } else {
        return this.emitter.result.rawCode(code`null`);
      }
    }

    modelDeclaration(model: Model, name: string): EmitterOutput<string> {
      const className = ensureCSharpIdentifier(this.emitter.getProgram(), model, name);
      const namespace = this.emitter.getContext().namespace;
      const doc = getDoc(this.emitter.getProgram(), model);
      const decl = this.emitter.result.declaration(
        className,
        code`${this.#licenseHeader}
      // <auto-generated />
      using System;
      using System.Collections.Generic;
      using Newtonsoft.Json;
      
      namespace ${namespace} {

      ${doc ? `${formatComment(doc)}` : ""}
      public partial class ${className}${this.#getTemplateParameters(model)} ${
        model.baseModel ? `: ${this.emitter.emitTypeReference(model.baseModel)}` : ""
      } {
      ${this.emitter.emitModelProperties(model)}
    }
   } `
      );

      return decl;
    }

    modelDeclarationContext(model: Model, name: string): Context {
      const modelName = ensureCSharpIdentifier(this.emitter.getProgram(), model, model.name);
      const modelFile = this.emitter.createSourceFile(`models/${modelName}.cs`);
      modelFile.meta[this.#sourceTypeKey] = CSharpSourceType.Model;
      const modelNamespace = `${
        model.namespace
          ? ensureCSharpIdentifier(
              this.emitter.getProgram(),
              model.namespace,
              getNamespaceFullName(model.namespace)
            )
          : "TypeSpec"
      }.Service.Models`;
      return {
        namespace: modelNamespace,
        file: modelFile,
        scope: modelFile.globalScope,
      };
    }

    modelInstantiationContext(model: Model): Context {
      const sourceFile = this.emitter.createSourceFile("models/Globals.cs");
      sourceFile.meta[this.#sourceTypeKey] = CSharpSourceType.Model;
      const modelNamespace = `${
        model.namespace
          ? ensureCSharpIdentifier(
              this.emitter.getProgram(),
              model.namespace,
              getNamespaceFullName(model.namespace)
            )
          : "TypeSpec"
      }.Service.Models`;
      return {
        file: sourceFile,
        scope: sourceFile.globalScope,
        namespace: modelNamespace,
      };
    }

    modelInstantiation(model: Model, name: string): EmitterOutput<string> {
      if (this.emitter.getProgram().checker.isStdType(model, "Record")) {
        //const indexerValue = model.indexer!.value;
        return code`Dictionary<string, object>`;
      }
      switch (model.name ?? name) {
        case "AcceptedResponse":
        case "OperationStatus":
        case "ResourceOperationStatus":
          return code`${model.name ?? name}`;
        default:
          return code`object`;
      }
    }

    modelProperties(model: Model): EmitterOutput<string> {
      const result: StringBuilder = new StringBuilder();
      for (const [_, prop] of model.properties) {
        if (prop.type.kind !== "Intrinsic" || prop.type.name !== "never")
          result.push(code`${this.emitter.emitModelProperty(prop)}`);
      }

      return result.reduce();
    }

    #isRecord(type: Type): boolean {
      return type.kind === "Model" && type.name === "Record" && type.indexer !== undefined;
    }

    modelPropertyLiteral(property: ModelProperty): EmitterOutput<string> {
      const propertyName = ensureCSharpIdentifier(
        this.emitter.getProgram(),
        property,
        property.name
      );
      const [typeName, typeDefault] = this.#findPropertyType(property);
      const doc = getDoc(this.emitter.getProgram(), property);
      //const attributes = getAttributes(this.emitter.getProgram(), property);
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      const defaultValue = property.default
        ? // eslint-disable-next-line @typescript-eslint/no-deprecated
          code`${this.emitter.emitType(property.default)}`
        : typeDefault;
      return this.emitter.result.rawCode(code`
      ${doc ? `${formatComment(doc)}` : ""}
      [JsonProperty("${property.name}")]
    public ${typeName}${
      property.optional || isValueType(this.emitter.getProgram(), property.type) ? "?" : ""
    } ${propertyName} { get; ${typeDefault ? "}" : "set; }"}${
      defaultValue ? ` = ${defaultValue};\n` : "\n"
    }
      `);
    }

    #findPropertyType(
      property: ModelProperty
    ): [EmitterOutput<string>, string | boolean | undefined] {
      switch (property.type.kind) {
        case "String":
          return [code`string`, `"${property.type.value}"`];
        case "Boolean":
          return [code`bool`, `${property.type.value === true ? true : false}`];
        case "Number":
        case "Object":
          return [code`object`, undefined];
        case "Model":
          if (this.#isRecord(property.type)) {
            return [code`JsonObject`, undefined];
          }
          return [code`${this.emitter.emitTypeReference(property.type)}`, undefined];
        default:
          return [code`${this.emitter.emitTypeReference(property.type)}`, undefined];
      }
    }

    modelPropertyReference(property: ModelProperty): EmitterOutput<string> {
      return this.emitter.emitTypeReference(property.type);
    }
    numericLiteral(number: NumericLiteral): EmitterOutput<string> {
      return this.emitter.result.rawCode(code`${number.value.toString()}`);
    }

    interfaceOperationDeclarationContext(operation: Operation): Context {
      const resource = getResourceOperation(this.emitter.getProgram(), operation);
      const resourceName: string =
        resource === undefined ? NoResourceContext : resource.resourceType.name;
      return this.#createOrGetResourceContext(resourceName, operation, resource?.resourceType);
    }
    interfaceOperationDeclaration(operation: Operation, name: string): EmitterOutput<string> {
      const operationName = ensureCSharpIdentifier(
        this.emitter.getProgram(),
        operation,
        name,
        NameCasingType.Method
      );
      const doc = getDoc(this.emitter.getProgram(), operation);
      const [httpOperation, _] = getHttpOperation(this.emitter.getProgram(), operation);
      const declParams = this.#emitOperationParameters(httpOperation);
      return this.emitter.result.declaration(
        operation.name,
        code`
        ${doc ? `${formatComment(doc)}` : ""}
        [${getOperationVerbDecorator(httpOperation)}]
        [Route("${httpOperation.path}")]
        ${this.emitter.emitOperationReturnType(operation)}
        public async Task<IActionResult> ${operationName}(${declParams})
        {
          var result = await On${operationName}Async(${this.#emitOperationCallParameters(
            httpOperation
          )});
          return result;
        }
        
        protected virtual Task<IActionResult> On${operationName}Async(${declParams}) {
          return Task.FromResult<IActionResult>(Ok());
        }`
      );
    }

    operationReturnType(operation: Operation, returnType: Type): EmitterOutput<string> {
      const [httpOperation, _] = getHttpOperation(this.emitter.getProgram(), operation);
      //const _toss = this.emitter.emitTypeReference(returnType);
      return this.#emitOperationResponses(httpOperation);
    }
    #emitOperationResponses(operation: HttpOperation): EmitterOutput<string> {
      const builder: StringBuilder = new StringBuilder();
      let i = 0;
      const validResponses = operation.responses.filter(
        (r) =>
          !isErrorModel(this.emitter.getProgram(), r.type) &&
          r.type.instantiationParameters === undefined &&
          (r.type.kind !== "Model" || r.type.templateMapper !== undefined) &&
          getCSharpStatusCode(r.statusCodes) !== undefined
      );
      for (const response of validResponses) {
        i++;
        builder.push(code`${this.#emitOperationResponseDecorator(response)}`);
        if (i < validResponses.length) {
          builder.pushLiteralSegment("\n");
        }
      }

      return builder.reduce();
    }

    #emitOperationResponseDecorator(response: HttpOperationResponse) {
      const responseType = this.#metaInfo.getEffectivePayloadType(response.type, Visibility.Read);
      return this.emitter.result.rawCode(
        code`[ProducesResponseType((int)${getCSharpStatusCode(
          response.statusCodes
        )!}, Type = typeof(${this.#emitResponseType(responseType)}))]`
      );
    }

    #emitResponseType(type: Type) {
      switch (type.kind) {
        case "Boolean":
          return "bool";
        case "Number":
          return "double";
        case "Scalar":
          return code`this.#emitCSharpType(getCSharpTypeForScalar(this.emitter.getProgram(), type))`;
        case "String":
          return "string";
        case "Model":
          if (this.#isRecord(type)) {
            return "JsonObject";
          }
          if (
            type.name === "" &&
            !hasNonMetadataProperties(this.emitter.getContext().getProgram(), type)
          )
            return code`void`;
          if (type.name === "") return code`System.Object`;

          return this.#emitKnownTypeReference(type);
        case "Intrinsic":
        default:
          return "object";
      }
    }

    #emitKnownTypeReference(model: Model): string | StringBuilder {
      const namespaceName = this.#getNamespaceFullName(model.namespace);
      if (namespaceName === "Azure.Core" || namespaceName === "Azure.Core.Foundations") {
        if (model.name === "CustomPage" && model.templateMapper) {
          return code`Pageable${this.#emitInstantationArguments(model, 1)}`;
        }
        if (model.name === "OperationStatus" && model.templateMapper) {
          return code`OperationStatus${this.#emitInstantationArguments(model, 1)}`;
        }
        if (model.name === "ResourceOperationStatus" && model.templateMapper) {
          return code`ResourceOperationStatus${this.#emitInstantationArguments(model, 1)}`;
        }
      }

      return code`${model.name}`;
    }

    #emitInstantationArguments(model: Model, limit: number = model.templateMapper!.args.length) {
      const builder: StringBuilder = new StringBuilder();
      builder.pushLiteralSegment("<");
      let pushed = 0;
      for (const arg of model.templateMapper!.args) {
        if (
          isType(arg) &&
          arg.kind !== "Intrinsic" &&
          (arg.kind !== "Model" ||
            (arg.name !== "" && arg.name !== "Error" && arg.name !== "AcceptedResponse"))
        ) {
          if (pushed > 0) {
            builder.pushLiteralSegment(", ");
          }
          builder.push(code`${this.#emitResponseType(arg)}`);
          pushed++;
        }

        if (pushed >= limit) {
          break;
        }
      }
      if (pushed < 1) return "";
      builder.pushLiteralSegment(">");
      return builder.reduce();
    }

    #emitOperationParameters(operation: HttpOperation): EmitterOutput<string> {
      const signature = new StringBuilder();
      const bodyParam = operation.parameters.body;
      let i = 0;
      const pathParameters = operation.parameters.parameters.filter((p) => p.type === "path");
      for (const parameter of pathParameters) {
        i++;
        if (parameter.param.type.kind !== "Intrinsic" || parameter.param.type.name !== "never") {
          signature.push(
            code`${this.#emitOperationSignatureParameter(operation, parameter)}${
              i < pathParameters.length || bodyParam !== undefined ? ", " : ""
            }`
          );
        }
      }
      if (bodyParam !== undefined) {
        signature.push(
          code`${this.emitter.emitTypeReference(
            this.#metaInfo.getEffectivePayloadType(
              bodyParam.type,
              Visibility.Create & Visibility.Update
            )
          )} body`
        );
      }

      return signature.reduce();
    }
    #emitOperationSignatureParameter(
      operation: HttpOperation,
      httpParam: HttpOperationParameter
    ): EmitterOutput<string> {
      const name = httpParam.name;
      const parameter = httpParam.param;
      const emittedName = ensureCSharpIdentifier(
        this.emitter.getProgram(),
        parameter,
        name,
        NameCasingType.Parameter
      );
      const [emittedType, emittedDefault] = this.#findPropertyType(parameter);
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      const defaultValue = parameter.default
        ? // eslint-disable-next-line @typescript-eslint/no-deprecated
          code`${this.emitter.emitType(parameter.default)}`
        : emittedDefault;
      return this.emitter.result.rawCode(
        code`${emittedType} ${emittedName}${defaultValue === undefined ? "" : ` = ${defaultValue}`}`
      );
    }

    #emitOperationCallParameters(operation: HttpOperation): EmitterOutput<string> {
      const signature = new StringBuilder();
      const bodyParam = operation.parameters.body;
      let i = 0;
      const pathParameters = operation.parameters.parameters.filter((p) => p.type === "path");
      for (const parameter of pathParameters) {
        i++;
        if (parameter.param.type.kind !== "Intrinsic" || parameter.param.type.name !== "never") {
          signature.push(
            code`${this.#emitOperationCallParameter(operation, parameter)}${
              i < pathParameters.length || bodyParam !== undefined ? ", " : ""
            }`
          );
        }
      }
      if (bodyParam !== undefined) {
        signature.push(code`body`);
      }

      return signature.reduce();
    }
    #emitOperationCallParameter(
      operation: HttpOperation,
      httpParam: HttpOperationParameter
    ): EmitterOutput<string> {
      const name = httpParam.name;
      const parameter = httpParam.param;
      const emittedName = ensureCSharpIdentifier(
        this.emitter.getProgram(),
        parameter,
        name,
        NameCasingType.Parameter
      );
      return this.emitter.result.rawCode(code`${emittedName}`);
    }

    // TODO: remove?
    // eslint-disable-next-line no-unused-private-class-members
    #emitParameterAttribute(parameter: HttpOperationParameter): EmitterOutput<string> {
      switch (parameter.type) {
        case "header":
          return code`[FromHeader("${parameter.name}")] `;
        case "query":
          return code`[FromQuery("${parameter.name}")] `;
        default:
          return "";
      }
    }
    #createOrGetResourceContext(
      name: string,
      operation: Operation,
      resource?: Model
    ): ControllerContext {
      let context: ControllerContext | undefined = controllers.get(name);
      if (context !== undefined) return context;
      const sourceFile: SourceFile<string> = this.emitter.createSourceFile(
        `controllers/${name}ControllerBase.cs`
      );
      sourceFile.meta[this.#sourceTypeKey] = CSharpSourceType.Controller;
      sourceFile.meta["resource"] = `${name}Controller`;
      sourceFile.meta["namespace"] = `${
        operation.namespace
          ? ensureCSharpIdentifier(
              this.emitter.getProgram(),
              operation.namespace,
              getNamespaceFullName(operation.namespace)
            )
          : "TypeSpec"
      }`;
      context = {
        file: sourceFile,
        resourceName: name,
        scope: sourceFile.globalScope,
        resourceType: resource,
      };
      controllers.set(name, context);
      return context;
    }

    #getNamespaceFullName(namespace: Namespace | undefined): string {
      return namespace
        ? ensureCSharpIdentifier(
            this.emitter.getProgram(),
            namespace,
            getNamespaceFullName(namespace)
          )
        : "TypeSpec";
    }
    reference(
      targetDeclaration: Declaration<string>,
      pathUp: Scope<string>[],
      pathDown: Scope<string>[],
      commonScope: Scope<string> | null
    ): string | EmitEntity<string> {
      return super.reference(targetDeclaration, pathUp, pathDown, commonScope);
    }

    scalarDeclaration(scalar: Scalar, name: string): EmitterOutput<string> {
      const scalarType = getCSharpTypeForScalar(this.emitter.getProgram(), scalar);
      return scalarType.getTypeReference();
    }

    sourceFile(sourceFile: SourceFile<string>): EmittedSourceFile {
      const emittedSourceFile: EmittedSourceFile = {
        path: sourceFile.path,
        contents: "",
      };

      switch (sourceFile.meta[this.#sourceTypeKey]) {
        case CSharpSourceType.Model:
          emittedSourceFile.contents = this.#emitModelContents(sourceFile);
          break;
        case CSharpSourceType.Controller:
          emittedSourceFile.contents = this.#emitControllerContents(sourceFile);
          break;
        case CSharpSourceType.OperationState:
          emittedSourceFile.contents = emitOperationState();
          break;
        case CSharpSourceType.OperationStatus:
          emittedSourceFile.contents = emitOperationStatus();
          break;
        case CSharpSourceType.ResourceOperationStatus:
          emittedSourceFile.contents = emitResourceOperationStatus();
          break;
        default:
          break;
      }

      return emittedSourceFile;
    }

    #emitModelContents(file: SourceFile<string>): string {
      const contents: StringBuilder = new StringBuilder();
      for (const decl of file.globalScope.declarations) {
        contents.push(decl.value);
      }

      return contents.segments.join("\n") + "\n";
    }

    #emitControllerContents(file: SourceFile<string>): string {
      const namespace = file.meta.namespace;
      const contents: StringBuilder = new StringBuilder();
      contents.push(`${this.#licenseHeader}\n`);
      contents.push("// <auto-generated />\n");
      contents.push("using System;\n");
      contents.push("using System.Net;\n");
      contents.push("using System.Threading.Tasks;\n");
      contents.push("using Microsoft.AspNetCore.Mvc;\n");
      contents.push("using Microsoft.TypeSpec.ProviderHub;\n");
      contents.push("using Microsoft.TypeSpec.ProviderHub.Controller;\n");
      contents.push("using Microsoft.Extensions.Logging;\n");
      contents.push(`using ${namespace}.Service.Models;\n`);
      contents.push(`namespace ${namespace}.Service.Controllers\n`);
      contents.push("{\n");
      contents.push("[ApiController]\n");
      contents.push(`public abstract partial class ${file.meta["resource"]}Base: ControllerBase\n`);
      contents.push("{\n");
      for (const decl of file.globalScope.declarations) {
        contents.push(decl.value + "\n");
      }
      contents.push("\n}");
      contents.push("\n}");

      return contents.segments.join("\n") + "\n";
    }

    stringLiteral(string: StringLiteral): EmitterOutput<string> {
      return this.emitter.result.rawCode(code`"${string.value}"`);
    }

    tupleLiteral(tuple: Tuple): EmitterOutput<string> {
      return this.emitter.result.rawCode(code`{
        ${this.emitter.emitTupleLiteralValues(tuple)}
      }`);
    }

    tupleLiteralValues(tuple: Tuple): EmitterOutput<string> {
      const result = new StringBuilder();
      for (const tupleValue of tuple.values) {
        result.push(code`${this.emitter.emitType(tupleValue)}`);
      }
      return this.emitter.result.rawCode(result.segments.join(",\n"));
    }

    createModelScope(baseScope: Scope<string>, namespace: string): Scope<string> {
      let current: Scope<string> = baseScope;
      for (const part of namespace.split(".")) {
        current = this.emitter.createScope({}, getCSharpIdentifier(part), current);
      }
      return current;
    }

    #getTemplateParameters(model: Model): EmitterOutput<string> {
      if (!model.templateMapper) return "";
      let i = 0;
      const params = new StringBuilder();
      const args = model.templateMapper.args.filter(
        (parameter): parameter is Type =>
          isType(parameter) &&
          parameter.kind !== "Boolean" &&
          parameter.kind !== "Intrinsic" &&
          parameter.kind !== "Number" &&
          parameter.kind !== "String" &&
          parameter.kind !== "Tuple"
      );
      for (const parameter of args) {
        i++;
        params.push(code`${this.emitter.emitTypeReference(parameter)}`);
        if (i < args.length) {
          params.pushLiteralSegment(",");
        }
      }
      if (params.segments.length > 0) return params.reduce();
      return "";
    }

    #coalesceUnionTypes(union: Union): CSharpType {
      const defaultValue: CSharpType = new CSharpType({
        name: "object",
        namespace: "System",
        isValueType: false,
      });
      let current: CSharpType | undefined = undefined;
      for (const [_, variant] of union.variants.entries()) {
        let candidate: CSharpType;
        switch (variant.type.kind) {
          case "Boolean":
            candidate = new CSharpType({ name: "bool", namespace: "System", isValueType: true });
            break;
          case "String":
            candidate = new CSharpType({ name: "string", namespace: "System", isValueType: false });
            break;
          case "Union":
            candidate = this.#coalesceUnionTypes(variant.type);
            break;
          case "Scalar":
            candidate = getCSharpTypeForScalar(this.emitter.getProgram(), variant.type);
            break;
          default:
            return defaultValue;
        }

        current = current ?? candidate;
        if (current === undefined || !candidate.equals(current)) return defaultValue;
      }
      return current ?? defaultValue;
    }

    writeOutput(sourceFiles: SourceFile<string>[]): Promise<void> {
      const state = this.emitter.createSourceFile("lib/OperationState.cs");
      state.meta[this.#sourceTypeKey] = CSharpSourceType.OperationState;
      const status = this.emitter.createSourceFile("lib/OperationStatus.cs");
      status.meta[this.#sourceTypeKey] = CSharpSourceType.OperationStatus;
      const resourceStatus = this.emitter.createSourceFile("lib/ResourceOperationStatus.cs");
      resourceStatus.meta[this.#sourceTypeKey] = CSharpSourceType.ResourceOperationStatus;
      return super.writeOutput(sourceFiles.concat([state, status, resourceStatus]));
    }
  }

  function processNameSpace(program: Program, target: Namespace) {
    const service = getService(program, target);
    if (service) {
      for (const [_, model] of target.models) {
        emitter.emitType(model);
      }
      for (const [_, en] of target.enums) {
        emitter.emitType(en);
      }
      for (const [_, sc] of target.scalars) {
        emitter.emitType(sc);
      }
      for (const [_, iface] of target.interfaces) {
        emitter.emitType(iface);
      }
      for (const [_, op] of target.operations) {
        emitter.emitType(op);
      }
    } else {
      for (const [_, sub] of target.namespaces) {
        processNameSpace(program, sub);
      }
    }
  }

  const emitter = createAssetEmitter(context.program, CSharpCodeEmitter, context as any);
  const ns = context.program.checker.getGlobalNamespaceType();
  processNameSpace(context.program, ns);
  const options = emitter.getOptions();
  await ensureCleanDirectory(context.program, options.emitterOutputDir);
  await emitter.writeOutput();
  if (options["skip-format"] === undefined || options["skip-format"] === false) {
    await exec(
      `dotnet format whitespace ${
        emitter.getOptions().emitterOutputDir
      } --include-generated --folder`
    );
  }
}
